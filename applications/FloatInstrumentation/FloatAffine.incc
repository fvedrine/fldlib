/**************************************************************************/
/*                                                                        */
/*  This file is part of FLDLib                                           */
/*                                                                        */
/*  Copyright (C) 2011-2017                                               */
/*    CEA (Commissariat a l'Energie Atomique et aux Energies              */
/*         Alternatives)                                                  */
/*                                                                        */
/*  you can redistribute it and/or modify it under the terms of the GNU   */
/*  Lesser General Public License as published by the Free Software       */
/*  Foundation, version 2.1.                                              */
/*                                                                        */
/*  It is distributed in the hope that it will be useful,                 */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of        */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
/*  GNU Lesser General Public License for more details.                   */
/*                                                                        */
/*  See the GNU Lesser General Public License version 2.1                 */
/*  for more details (enclosed in the file LICENSE).                      */
/*                                                                        */
/**************************************************************************/

/////////////////////////////////
//
// Library   : NumericalDomains
// Unit      : Affine relationships
// File      : FloatAffine.incc
// Description :
//   Implementation of a class of affine relations.
//

#include "FloatInstrumentation/BackTrace.h"

namespace NumericalDomains { namespace DAffine {

class ExecutionPath::IFStream : public STG::IOObject::ISBase {
  public:
   typedef STG::IOObject::ISBase ISBase;

  private:
   std::ifstream fsIn;

  public:
   IFStream(const char* name) : fsIn(name) {}
   IFStream(const char* name, std::ios_base::openmode mode) : fsIn(name, mode) {}
   IFStream(const IFStream& source) = delete;

   bool isValid() const { return true; }
   virtual bool isStreamBased() const { return true; }
   std::ifstream& inputStream() { return fsIn; }

   #define DefineDeclareIMethods
   #include "StandardClasses/IOStreamMethods.inch"
   #undef DefineDeclareIMethods
};

class ExecutionPath::IStringStream : public STG::IOObject::ISBase {
  public:
   typedef STG::IOObject::ISBase ISBase;

  private:
   std::istringstream isIn;

  public:
   IStringStream(const char* content) : isIn(content) {}
   IStringStream(const IStringStream& source) = delete;

   bool isValid() const { return true; }
   virtual bool isStreamBased() const { return true; }
   std::istringstream& inputStream() { return isIn; }

   #define DefineDeclareIMethods
   #include "StandardClasses/IOStreamMethods.inch"
   #undef DefineDeclareIMethods
};

class ExecutionPath::OFStream : public STG::IOObject::OSBase {
  public:
   typedef STG::IOObject::OSBase OSBase;

  private:
   std::ofstream ofsOut;

  public:
   OFStream(const char* fileName) : ofsOut(fileName) {}
   OFStream(const char* fileName, std::ios_base::openmode mode) : ofsOut(fileName, mode) {}
   OFStream(const OFStream& source) = delete;

   bool isValid() const { return true; }
   void close() { ofsOut.close(); }
   virtual bool isStreamBased() const { return true; }

   #define DefineDeclareOMethods
   #include "StandardClasses/IOStreamMethods.inch"
   #undef DefineDeclareOMethods
};

class ExecutionPath::DebugStream : public STG::IOObject::OSBase {
  public:
   typedef STG::IOObject::OSBase OSBase;

  private:
   std::ostringstream ssOut;

  public:
   DebugStream() {}
   DebugStream(const DebugStream& source) = delete;

   bool isValid() const { return true; }
   void clear() { ssOut.str(""); ssOut.clear(); }
   std::string content() const { return ssOut.str(); }

   #define DefineDeclareOMethods
   #include "StandardClasses/IOStreamMethods.inch"
   #undef DefineDeclareOMethods
};

#define DefineInlineIStreamMethods

#define DefineTypeObject ExecutionPath::IFStream
#define DefineLinkStream fsIn
#include "StandardClasses/IOStreamMethods.inch"
#undef DefineLinkStream
#undef DefineTypeObject

#define DefineTypeObject ExecutionPath::IStringStream
#define DefineLinkStream isIn
#include "StandardClasses/IOStreamMethods.inch"
#undef DefineLinkStream
#undef DefineTypeObject

#undef DefineInlineIStreamMethods

#define DefineInlineOStreamMethods

#define DefineTypeObject ExecutionPath::OFStream
#define DefineLinkStream ofsOut
#include "StandardClasses/IOStreamMethods.inch"
#undef DefineLinkStream
#undef DefineTypeObject

#define DefineTypeObject ExecutionPath::DebugStream
#define DefineLinkStream ssOut
#include "StandardClasses/IOStreamMethods.inch"
#undef DefineLinkStream
#undef DefineTypeObject

#undef DefineInlineOStreamMethods

   /* class IFStream */

#define DefineImplementsIStreamMethods
#define DefineTypeObject ExecutionPath::IFStream
#define DefineLinkStream fsIn
#include "StandardClasses/IOStreamMethods.incc"
#undef DefineLinkStream
#undef DefineTypeObject
#undef DefineImplementsIStreamMethods

#define DefineImplementsIStreamMethods
#define DefineTypeObject ExecutionPath::IStringStream
#define DefineLinkStream isIn
#include "StandardClasses/IOStreamMethods.incc"
#undef DefineLinkStream
#undef DefineTypeObject
#undef DefineImplementsIStreamMethods

   /* class OFStream */

#define DefineImplementsOStreamMethods
#define DefineTypeObject ExecutionPath::OFStream
#define DefineLinkStream ofsOut
#include "StandardClasses/IOStreamMethods.incc"
#undef DefineLinkStream
#undef DefineTypeObject

#define DefineImplementsOStreamMethods
#define DefineTypeObject ExecutionPath::DebugStream
#define DefineLinkStream ssOut
#include "StandardClasses/IOStreamMethods.incc"
#undef DefineLinkStream
#undef DefineTypeObject

STG::IOObject::OSBase* ExecutionPath::oTraceFile = nullptr;
STG::IOObject::ISBase* ExecutionPath::iTraceFile = nullptr;
STG::IOObject::ISBase* ExecutionPath::iConstantStream = nullptr;
ExecutionPath::PathExplorer ExecutionPath::pPathExplorer;

bool ExecutionPath::fDoesFollow = false;
ExecutionPath::PathExplorer* ExecutionPath::currentPathExplorer = &ExecutionPath::pPathExplorer;
const char* ExecutionPath::szFile = nullptr;
int ExecutionPath::uLine = 0;
const char* ExecutionPath::szSynchronisationFile = nullptr;
int ExecutionPath::uSynchronisationLine = 0;
const char* ExecutionPath::szCurrentFile = nullptr;
int ExecutionPath::uCurrentLine = 0;
bool ExecutionPath::fHasNewFile = false;
bool ExecutionPath::fHasNewLine = false;

bool ExecutionPath::fSupportAtomic = false;
bool ExecutionPath::fSupportUnstableInLoop = false;
bool ExecutionPath::fSupportBacktrace = false;
bool ExecutionPath::fSupportVerbose = false;
bool ExecutionPath::fSupportThreshold = false;
bool ExecutionPath::fSupportFirstFollowFloat = false;
bool ExecutionPath::fSupportPureZonotope = false;
bool ExecutionPath::fTrackErrorOrigin = false;
int ExecutionPath::uLimitNoiseSymbolsNumber = 0;

BuiltReal ExecutionPath::brThreshold;
BuiltReal ExecutionPath::brThresholdDomain;
BuiltReal ExecutionPath::brMaximalAccuracy;

#if !defined(FLOAT_GENERIC_BASE_UNSIGNED) && !defined(FLOAT_GENERIC_BASE_LONG)
PNT::AutoPointer<TConstraintsSet<FLOAT_REAL_BITS_NUMBER, TBaseFloatAffine<ExecutionPath> > >
#elif defined(FLOAT_GENERIC_BASE_LONG)
PNT::AutoPointer<TGConstraintsSet<Numerics::UnsignedLongBaseStoreTraits, FLOAT_REAL_BITS_NUMBER, TBaseFloatAffine<ExecutionPath> > >
#else // defined(FLOAT_GENERIC_BASE_UNSIGNED)
PNT::AutoPointer<TGConstraintsSet<Numerics::UnsignedBaseStoreTraits, FLOAT_REAL_BITS_NUMBER, TBaseFloatAffine<ExecutionPath> > >
#endif
ExecutionPath::apcsConstraints;
BaseExecutionPathParams* ExecutionPath::pParams = nullptr;

BaseExecutionPathParams&
ExecutionPath::setParams()
   {  if (!fClosedParams) {
         fClosedParams = true;
         pParams = new BaseExecutionPathParams;
         pParams->initializeParams();
      };
      return *pParams;
   }

bool ExecutionPath::fClosedParams = false;

STG::IOObject::ISBase*
ExecutionPath::acquireConstantStream(const char* content) {
   if (!iConstantStream)
      iConstantStream = new IStringStream(content);
   else {
      ((IStringStream*) iConstantStream)->inputStream().str(content);
      ((IStringStream*) iConstantStream)->inputStream().clear();
   };
   return iConstantStream;
}

void
ExecutionPath::releaseConstantStream(STG::IOObject::ISBase* in) {}

class ExecutionPath::ExpressionBuilder::Content
   :  public std::vector<std::vector<std::string> > {
  public:
   Content() = default;
   Content(const Content&) = default;
   Content(Content&&) = default;
};

ExecutionPath::ExpressionBuilder::ExpressionBuilder()
   :  pvContent(new Content())
   {  ((Content*) pvContent)->push_back(std::vector<std::string>()); }

ExecutionPath::ExpressionBuilder::~ExpressionBuilder()
   {  if (pvContent) delete ((Content*) pvContent); }

void
ExecutionPath::ExpressionBuilder::_pushSubExpression()
   {  ((Content*) pvContent)->push_back(std::vector<std::string>());
      ((Content*) pvContent)->back().push_back("(");
   }

void
ExecutionPath::ExpressionBuilder::_pushZeroConstant()
   {  ((Content*) pvContent)->back().push_back("0"); }
   
void
ExecutionPath::ExpressionBuilder::_pushConstant(const void* avalue)
   {  DebugStream out;
      const BuiltReal& value = *(const BuiltReal*) avalue;
      value.writeDecimal(out);
      ((Content*) pvContent)->back().push_back(out.content());
   }

void
ExecutionPath::ExpressionBuilder::_addTerm(const void* acoefficient, const Symbol& symbol)
   {  const BuiltReal& coefficient = *(const BuiltReal*) acoefficient;
      DebugStream out;
      out.put('+');
      coefficient.writeDecimal(out);
      out.put('*');
      // out.writesome(symbol.getOwnPrefix());
      out.writesome(Equation::getSymbolPrefix(symbol.getType()));
      out.write(symbol.getOrder(), false /* isRaw */);
      ((Content*) pvContent)->back().back() += out.content();
   }

void
ExecutionPath::ExpressionBuilder::_pushTerm(const void* acoefficient, const Symbol& symbol)
   {  const BuiltReal& coefficient = *(const BuiltReal*) acoefficient;
      DebugStream out;
      coefficient.writeDecimal(out);
      out.put('*');
      // out.writesome(symbol.getOwnPrefix());
      out.writesome(Equation::getSymbolPrefix(symbol.getType()));
      out.write(symbol.getOrder(), false /* isRaw */);
      ((Content*) pvContent)->back().push_back(out.content());
   }

void
ExecutionPath::ExpressionBuilder::_popSubExpression()
   {  ((Content*) pvContent)->back().push_back(")");
      std::string newContent;
      for (const auto& content : ((Content*) pvContent)->back())
         newContent += content;
      ((Content*) pvContent)->pop_back();
      ((Content*) pvContent)->back().push_back(newContent);
   }

void
ExecutionPath::ExpressionBuilder::_applyOpposite()
   {  ((Content*) pvContent)->back().back().insert(0, "-"); }

void
ExecutionPath::ExpressionBuilder::_applyBinaryPlus()
   {  std::string last = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string first = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().back() = std::string("(") + first + " + " + last + ")";
   }

void
ExecutionPath::ExpressionBuilder::_applyBinaryMinus()
   {  std::string last = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string first = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().back() = std::string("(") + first + " - " + last + ")";
   }

void
ExecutionPath::ExpressionBuilder::_applyBinaryMult()
   {  std::string last = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string first = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().back() = first + " * " + last;
   }

void
ExecutionPath::ExpressionBuilder::_applyBinaryDivide()
   {  std::string last = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string first = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().back() = first + " / " + last;
   }

void
ExecutionPath::ExpressionBuilder::_applyUnarySquare()
   {  ((Content*) pvContent)->back().back() += " ** 2"; }

void
ExecutionPath::ExpressionBuilder::_compareStrictBetween()
   {  std::string max = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string min = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string val = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().back()
         = std::string("(") + min + " < " + val + " < " + max + ")";
   }

void
ExecutionPath::ExpressionBuilder::_applyQuadConditional()
   {  std::string condition = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string greaterVal = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string inVal = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().pop_back();
      std::string lessVal = ((Content*) pvContent)->back().back();
      ((Content*) pvContent)->back().back()
         = std::string("(") + condition + " ? " + lessVal + " : " + inVal + " : " + greaterVal + ")";
   }

void
ExecutionPath::ExpressionBuilder::_applySetMantissaToZero()
   {  std::string& val = ((Content*) pvContent)->back().back();
      val.insert(0, "|_");
      val += "_|";
   }

void
ExecutionPath::ExpressionBuilder::_clear()
   {  ((Content*) pvContent)->clear();
      ((Content*) pvContent)->push_back(std::vector<std::string>());
   }

void
ExecutionPath::ExpressionBuilder::_assumeCleared()
   {  AssumeCondition(((Content*) pvContent)->size() == 1
         && ((Content*) pvContent)->back().empty())
   }

void
ExecutionPath::ExpressionBuilder::_duplicateExpression()
   {  auto& expressionVector = ((Content*) pvContent)->back();
      expressionVector.push_back(expressionVector.back());
   }

void
ExecutionPath::ExpressionBuilder::_moveUp(int shift)
   {  auto& expressionVector = ((Content*) pvContent)->back();
      std::string movedValue = expressionVector.back();
      expressionVector.pop_back();
      expressionVector.insert(expressionVector.cend()-shift, movedValue);
   }

void
ExecutionPath::ExpressionBuilder::_clearExpression(int index)
   {  auto& expressionVector = ((Content*) pvContent)->back();
      expressionVector.erase(expressionVector.cend()-index-1);
   }

void
ExecutionPath::ExpressionBuilder::write(STG::IOObject::OSBase& out) {
   AssumeCondition(((Content*) pvContent)->size() == 1)
   for (const auto& content : ((Content*) pvContent)->back())
      out.writesome(content.c_str());
}

void
ExecutionPath::SymbolDefinitionTracker::_setDefinition(const void* acoefficient, const Symbol& symbol,
      VirtualExpressionBuilder& expression) {
   const BuiltReal& coefficient = *(const BuiltReal*) acoefficient;
   poDefinitionFile->put('\t');
   // poDefinitionFile->writesome(symbol.getOwnPrefix());
   poDefinitionFile->writesome(Equation::getSymbolPrefix(symbol.getType()));

   poDefinitionFile->write(symbol.getOrder(), false /* isRaw */);
   poDefinitionFile->writesome(" =_def (");
   ((ExpressionBuilder&) expression).write(*poDefinitionFile);
   poDefinitionFile->writesome(") / ");
   DebugStream out;
   coefficient.writeDecimal(out);
   poDefinitionFile->writesome(out.content().c_str());
   poDefinitionFile->put('\n');
}

void
ExecutionPath::SymbolDefinitionTracker::_setAddDefinition(const void* acoefficient, const Symbol& symbol, VirtualExpressionBuilder& expression) {
   const BuiltReal& coefficient = *(const BuiltReal*) acoefficient;
   poDefinitionFile->put('\t');
   // poDefinitionFile->writesome(symbol.getOwnPrefix());
   poDefinitionFile->writesome(Equation::getSymbolPrefix(symbol.getType()));
   poDefinitionFile->write(symbol.getOrder(), false /* isRaw */);
   poDefinitionFile->writesome(" +=_def (");
   ((ExpressionBuilder&) expression).write(*poDefinitionFile);
   poDefinitionFile->writesome(") / ");
   DebugStream out;
   coefficient.writeDecimal(out);
   poDefinitionFile->writesome(out.content().c_str());
   poDefinitionFile->put('\n');
}

void
ExecutionPath::initializeGlobals(const char* fileSuffix) {
   apcsConstraints.absorbElement(
#if !defined(FLOAT_GENERIC_BASE_UNSIGNED) && !defined(FLOAT_GENERIC_BASE_LONG)
      new TConstraintsSet<FLOAT_REAL_BITS_NUMBER, BaseFloatAffine>()
#elif defined(FLOAT_GENERIC_BASE_LONG)
      new TGConstraintsSet<Numerics::UnsignedLongBaseStoreTraits, FLOAT_REAL_BITS_NUMBER, BaseFloatAffine>()
#else // defined(FLOAT_GENERIC_BASE_UNSIGNED)
      new TGConstraintsSet<Numerics::UnsignedBaseStoreTraits, FLOAT_REAL_BITS_NUMBER, BaseFloatAffine>()
#endif
   );
   int suffixLength = strlen(fileSuffix);
   char* file = (char*) malloc(suffixLength+5);
   strcpy(file, fileSuffix);
   strcpy(file+suffixLength, "_out");
   oTraceFile = new OFStream(file);
   strcpy(file+suffixLength, "_in");
   iTraceFile = new IFStream(file);
   free(file);
   fDoesFollow = iTraceFile->good();
   pPathExplorer.mode() = MRealAndImplementation;
   if (fDoesFollow) {
      try {
         iTraceFile->assume("path condition: ");
         (*iTraceFile) >> pPathExplorer.numberOfUnstableBranches();
         if (pPathExplorer.numberOfUnstableBranches() < 0)
            throw STG::EReadError("wrong number of unstable branches");
         iTraceFile->assume(' ');
         pPathExplorer.stackTrace().read(*iTraceFile, Numerics::BigInteger::FormatParameters().setBinary());
         iTraceFile->assume('\n');
         fDoesFollow = !pPathExplorer.stackTrace().isZero() || (pPathExplorer.numberOfUnstableBranches() > 0);
         if (fSupportThreshold) {
            iTraceFile->assume("maximal accuracy: ");
            BuiltReal::ReadParameters defaultParams;
            brThreshold.read(*iTraceFile, defaultParams);
            char ch = iTraceFile->get();
            if (ch == ' ') {
               ch = iTraceFile->get();
               if (ch == 's') {
                  iTraceFile->unget();
                  ch = ' ';
               }
               else {
                  defaultParams.clear();
                  brThresholdDomain.read(*iTraceFile, defaultParams);
                  ch = iTraceFile->get();
               };
            };
            if (ch == ' ') {
               iTraceFile->assume("s\n");
               delete iTraceFile;
               iTraceFile = nullptr;
               fDoesFollow = false;
            }
            else if (ch != '\n')
               throw STG::EReadError();
         };
      }
      catch (STG::EReadError& error) {
         if (!error.getMessage())
            error = STG::EReadError("initialisation problem");
         throw;
      };
   }
   else {
      delete iTraceFile;
      iTraceFile = nullptr;
      fDoesFollow = false;
   };
   if (fTrackErrorOrigin) {
      if (!pParams)
         setParams();
      if (oTraceFile)
         pParams->absorbDefinitionTracker(new SymbolDefinitionTracker(*oTraceFile));
   };
}

void
ExecutionPath::finalizeGlobals() {
   if (oTraceFile) {
      if (fSupportThreshold) {
         oTraceFile->writesome("maximal accuracy: ");
         brMaximalAccuracy.write(*oTraceFile, BuiltReal::WriteParameters().setDecimal());
         oTraceFile->put(' ');
         brThresholdDomain.write(*oTraceFile, BuiltReal::WriteParameters().setDecimal());
         oTraceFile->put('\n');
      };
      oTraceFile->writesome("path condition: ");
      if (pPathExplorer.mode() == MRealAndImplementation)
         pPathExplorer.currentUnstableBranch() = pPathExplorer.lastUnstableBranch();
      (*oTraceFile) << pPathExplorer.currentUnstableBranch();
      oTraceFile->put(' ');
      if (pPathExplorer.lastLogCases() > 0) {
         AssumeCondition(pPathExplorer.currentStackPosition() >= (int) pPathExplorer.lastLogCases())
         if (pPathExplorer.lastResult() == 0) { // pop from last branch/conversion
            AssumeCondition(pPathExplorer.lastZeroBit() == 0 || pPathExplorer.lastIncBit() < pPathExplorer.lastZeroBit())
            pPathExplorer.stackTrace().clearHigh(pPathExplorer.lastZeroBit());
            if (pPathExplorer.lastZeroBit() > 0) {
               while (pPathExplorer.stackTrace().cbitArray(pPathExplorer.lastIncBit())) {
                  pPathExplorer.stackTrace().setFalseBitArray(pPathExplorer.lastIncBit());
                  ++pPathExplorer.lastIncBit();
               };
               AssumeCondition(pPathExplorer.lastIncBit() < pPathExplorer.lastZeroBit());
               pPathExplorer.stackTrace().setTrueBitArray(pPathExplorer.lastIncBit());
            };
         }
         else if (pPathExplorer.lastLogCases() <= 3) { // branch
            if (pPathExplorer.lastLogCases() >= 3)
               pPathExplorer.stackTrace().bitArray(pPathExplorer.currentStackPosition()+2-pPathExplorer.lastLogCases()) = (pPathExplorer.lastResult() >> 2);
            if (pPathExplorer.lastLogCases() >= 2)
               pPathExplorer.stackTrace().bitArray(pPathExplorer.currentStackPosition()+1-pPathExplorer.lastLogCases()) = ((pPathExplorer.lastResult() & 2) >> 1);
            pPathExplorer.stackTrace().bitArray(pPathExplorer.currentStackPosition()-pPathExplorer.lastLogCases()) = pPathExplorer.lastResult() & 0x1;
         }
         else { // conversion
            AssumeCondition(pPathExplorer.currentStackPosition() >= (int) pPathExplorer.lastLogCases())
            int index = (pPathExplorer.currentStackPosition()-pPathExplorer.lastLogCases())/(8*sizeof(unsigned));
            int shiftIndex = (pPathExplorer.currentStackPosition()-pPathExplorer.lastLogCases()) % (8*sizeof(unsigned));
            if ((int) (8*sizeof(unsigned) - shiftIndex) > (int) pPathExplorer.lastLogCases()) {
               pPathExplorer.stackTrace()[index] &= ~(~(~0U << pPathExplorer.lastLogCases()) << shiftIndex);
               pPathExplorer.stackTrace()[index] |= pPathExplorer.lastResult() << shiftIndex;
            }
            else { // pPathExplorer.lastLogCases() >= (8*sizeof(unsigned) - shiftIndex)
               pPathExplorer.stackTrace()[index] &= ~(~0U << shiftIndex);
               pPathExplorer.stackTrace()[index+1]
                  &= ~0U << (pPathExplorer.lastLogCases() - (8*sizeof(unsigned) - shiftIndex));
               pPathExplorer.stackTrace()[index] |= pPathExplorer.lastResult() << shiftIndex;
               pPathExplorer.stackTrace()[index+1] |= pPathExplorer.lastResult()
                  >> (pPathExplorer.lastLogCases() - (8*sizeof(unsigned) - shiftIndex));
            };
         }
      };
      pPathExplorer.stackTrace().write(*oTraceFile, Numerics::BigInteger::FormatParameters().setBinary());
      oTraceFile->put('\n');
      delete oTraceFile;
      oTraceFile = nullptr;
   }
   if (iTraceFile)
      delete iTraceFile;
   iTraceFile = nullptr;
   if (iConstantStream)
      delete iConstantStream;
   iConstantStream = nullptr;
   apcsConstraints.release();
   if (pParams) delete pParams;
   pParams = nullptr;
}

void
ExecutionPath::setSimplificationTriggerPercent(double percent) {
   if (!pParams)
      setParams();
   DAffine::TFloatZonotope<ExecutionPath, 52, 11, double> val;
   if (!fSupportAtomic)
      val.initFrom(percent);
   else
      val.initFromAtomic(percent);
   pParams->setSimplificationTriggerPercent(val.getRealDomain().getCentral());
}

void
ExecutionPath::followNewBranch(int cases, BooleanChoice& realChoice, BooleanChoice& errorChoice,
      bool doesChooseDefaultErrorChoice, BooleanChoice defaultErrorChoice) {
   int result = 0;
   int logCases = (cases > 4) ? 3 : ((cases > 2) ? 2 : 1);
   bool initialDoesFollow = fDoesFollow;
   if (fDoesFollow) {
      fDoesFollow = (currentPathExplorer->currentStackPosition()
               < ((int) currentPathExplorer->stackTrace().log_base_2() - logCases))
            || currentPathExplorer->currentUnstableBranch()
               < currentPathExplorer->numberOfUnstableBranches();
      initialDoesFollow = fDoesFollow || (currentPathExplorer->mode() != MRealAndImplementation);
      if (logCases >= 3)
         result = (currentPathExplorer->stackTrace().cbitArray(currentPathExplorer->currentStackPosition()+2) << 2);
      if (logCases >= 2)
         result |= (currentPathExplorer->stackTrace().cbitArray(currentPathExplorer->currentStackPosition()+1) << 1);
      result |= currentPathExplorer->stackTrace().cbitArray(currentPathExplorer->currentStackPosition());
   }
   else
      result = 0;
   int oldResult = result;

   bool isLastCaseIfFollow = false;
   if (realChoice == BCNone) {
      AssumeCondition(errorChoice == BCTop && result <= 1)
      if (!doesChooseDefaultErrorChoice)
         errorChoice = (result == 0) ? BCTrue : BCFalse;
      else
         errorChoice = (result == 0) ? defaultErrorChoice
               : ((defaultErrorChoice == BCTrue) ? BCFalse : BCTrue);
      currentPathExplorer->doesCurrentUnstableHasOtherBranches() = (result == 0);
   }
   else if (errorChoice == BCNone) {
      AssumeCondition(realChoice == BCTop && result <= 1)
      realChoice = (result == 0) ? BCTrue : BCFalse;
      currentPathExplorer->doesCurrentUnstableHasOtherBranches() = (result == 0);
   }
   else if (realChoice == errorChoice) {
      AssumeCondition(realChoice == BCTop && result < 6 && currentPathExplorer->mode() == MRealAndImplementation)
      switch (result) {
         case 0:
            if (!doesChooseDefaultErrorChoice)
               realChoice = errorChoice = BCTrue;
            else
               realChoice = errorChoice = defaultErrorChoice;
            break;
         case 1:
            if (!doesChooseDefaultErrorChoice)
               realChoice = errorChoice = BCFalse;
            else
               realChoice = errorChoice = (defaultErrorChoice == BCTrue) ? BCFalse : BCTrue;
            break;
         case 2:
            realChoice = BCNone; errorChoice = BCTrue;
            ++currentPathExplorer->currentUnstableBranch();
            if (fDoesFollow) {
               fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
               if (fDoesFollow)
                  result = 3;
            };
            break;
         case 3:
            realChoice = BCFalse; errorChoice = BCNone;
            ++currentPathExplorer->currentUnstableBranch();
            if (fDoesFollow) {
               fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
               if (fDoesFollow)
                  result = 2;
            };
            break;
         case 4:
            realChoice = BCNone; errorChoice = BCFalse;
            ++currentPathExplorer->currentUnstableBranch();
            if (fDoesFollow) {
               fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
               if (fDoesFollow) {
                  result = 5;
                  isLastCaseIfFollow = true;
               };
            };
            break;
         case 5:
            realChoice = BCTrue; errorChoice = BCNone;
            ++currentPathExplorer->currentUnstableBranch();
            if (fDoesFollow) {
               fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
               if (fDoesFollow) {
                  result = 4;
                  isLastCaseIfFollow = true;
               };
            };
            break;
      };
   }
   else if (realChoice == BCTop || errorChoice == BCTop) {
      // realChoice == BCTop && (errorChoice == BCFalse || errorChoice == BCTrue)
      // errorChoice == BCTop && (realChoice == BCFalse || realChoice == BCTrue)
      AssumeCondition(result < 3 && currentPathExplorer->mode() == MRealAndImplementation)
      if (realChoice == BCTop) { // errorChoice == BCFalse || errorChoice == BCTrue
         switch (result) {
            case 0:
               realChoice = errorChoice;
               break;
            case 1:
               realChoice = BCNone;
               ++currentPathExplorer->currentUnstableBranch();
               if (fDoesFollow) {
                  fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
                  if (fDoesFollow) {
                     result = 2;
                     isLastCaseIfFollow = true;
                  };
               };
               break;
            case 2:
               realChoice = (errorChoice == BCTrue) ? BCFalse : BCTrue;
               errorChoice = BCNone;
               ++currentPathExplorer->currentUnstableBranch();
               if (fDoesFollow) {
                  fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
                  if (fDoesFollow) {
                     result = 1;
                     isLastCaseIfFollow = true;
                  };
               };
               break;
         };
      }
      else { // errorChoice == BCTop && (realChoice == BCFalse || realChoice == BCTrue)
         int fakeResult = result;
         if (doesChooseDefaultErrorChoice && defaultErrorChoice != realChoice) {
            if (result == 0)
               fakeResult = 2;
            else
               --fakeResult;
         };
         switch (fakeResult) {
            case 0:
               errorChoice = realChoice;
               break;
            case 1:
               errorChoice = (realChoice == BCTrue) ? BCFalse : BCTrue;
               realChoice = BCNone;
               ++currentPathExplorer->currentUnstableBranch();
               if (fDoesFollow) {
                  fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
                  if (fDoesFollow) {
                     result = result+1;
                     isLastCaseIfFollow = true;
                  };
               };
               break;
            case 2:
               errorChoice = BCNone;
               ++currentPathExplorer->currentUnstableBranch();
               if (fDoesFollow) {
                  fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
                  if (fDoesFollow) {
                     result = result-1;
                     isLastCaseIfFollow = true;
                  };
               };
               break;
         };
      }
   }
   else {
      // (realChoice == BCFalse && errorChoice == BCTrue)
      // (realChoice == BCTrue && errorChoice == BCFalse)
      AssumeCondition(currentPathExplorer->mode() == MRealAndImplementation)
      if (result == 0)
         realChoice = BCNone; 
      else
         errorChoice = BCNone;
      ++currentPathExplorer->currentUnstableBranch();
      if (fDoesFollow) {
         fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
         if (fDoesFollow) {
            result = (result == 0) ? 1 : 0;
            isLastCaseIfFollow = true;
         };
      };
   };

   if (!fDoesFollow) {
      ++result;
      if (result == cases)
         result = 0;
      currentPathExplorer->lastResult() = result;
      currentPathExplorer->lastLogCases() = logCases;
      currentPathExplorer->lastResultCases() = cases;
      if (logCases >= 3)
         currentPathExplorer->stackTrace().bitArray(currentPathExplorer->currentStackPosition()+2) = (oldResult >> 2);
      if (logCases >= 2)
         currentPathExplorer->stackTrace().bitArray(currentPathExplorer->currentStackPosition()+1) = ((oldResult & 2) >> 1);
      currentPathExplorer->stackTrace().bitArray(currentPathExplorer->currentStackPosition()) = oldResult & 0x1;
      if (oldResult < cases-1) {
         if (currentPathExplorer->mode() == MRealAndImplementation
               && (realChoice == BCNone || errorChoice == BCNone)
               && oldResult == cases-2) {
            currentPathExplorer->previousLastZeroBit() = currentPathExplorer->lastZeroBit();
            currentPathExplorer->previousLastIncBit() = currentPathExplorer->lastIncBit();
         };
         currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+logCases;
         currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
      };
   }
   else if (result < cases-1 && !isLastCaseIfFollow) {
      if (currentPathExplorer->mode() == MRealAndImplementation
            && (realChoice == BCNone || errorChoice == BCNone)
            && oldResult == cases-2) {
         currentPathExplorer->previousLastZeroBit() = currentPathExplorer->lastZeroBit();
         currentPathExplorer->previousLastIncBit() = currentPathExplorer->lastIncBit();
      };
      currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+logCases;
      currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
   };
   currentPathExplorer->currentStackPosition() += logCases;

   if (realChoice == BCNone) {
      if (!fDoesFollow)
         fDoesFollow = initialDoesFollow;
      AssumeCondition(currentPathExplorer->mode() != MOnlyReal)
      if (currentPathExplorer->mode() == MRealAndImplementation) {
         AssumeCondition(szSynchronisationFile == nullptr)
         szSynchronisationFile = szFile;
         uSynchronisationLine = uLine;
         currentPathExplorer->mode() = MOnlyImplementation;
         initialMergeTable() .setInitial(symbolsManager());
         if (!fDoesFollow && szFile == nullptr) {
            oTraceFile->writesome("the macros FLOAT_SPLIT_ALL and FLOAT_MERGE_ALL should be correctly defined!\n");
            writeBackTrace(*oTraceFile);
            oTraceFile->flush();
            throw anticipated_termination();
         }
         szFile = nullptr;
         uLine = 0;
      }
   }
   else if (errorChoice == BCNone) {
      if (!fDoesFollow)
         fDoesFollow = initialDoesFollow;
      AssumeCondition(currentPathExplorer->mode() != MOnlyImplementation)
      if (currentPathExplorer->mode() == MRealAndImplementation) {
         AssumeCondition(szSynchronisationFile == nullptr)
         szSynchronisationFile = szFile;
         uSynchronisationLine = uLine;
         currentPathExplorer->mode() = MOnlyReal;
         initialMergeTable().setInitial(symbolsManager());
         if (!fDoesFollow && szFile == nullptr) {
            oTraceFile->writesome("the macros FLOAT_SPLIT_ALL and FLOAT_MERGE_ALL should be correctly defined!\n");
            writeBackTrace(*oTraceFile);
            oTraceFile->flush();
            throw anticipated_termination();
         }
         szFile = nullptr;
         uLine = 0;
      }
   }
}

unsigned
ExecutionPath::followNewConversionBranch(unsigned conversion, bool& realChoice,
      bool& implementationChoice, unsigned realNumber, unsigned implementationNumber,
      unsigned commonNumber, unsigned firstRealCommon, unsigned firstImplementationCommon,
      unsigned& alternativeResult) {
   unsigned result;
   int number = Numerics::DInteger::Access::log_base_2(conversion);
   int index = currentPathExplorer->currentStackPosition()/(8*sizeof(unsigned));
   int shiftIndex = currentPathExplorer->currentStackPosition() % (8*sizeof(unsigned));
   bool initialDoesFollow = fDoesFollow;
   if (fDoesFollow) {
      result = (currentPathExplorer->stackTrace()[index] >> shiftIndex);
      if ((int) (8*sizeof(unsigned) - shiftIndex) < number)
         result |= (currentPathExplorer->stackTrace()[index+1] & ~(~0U << shiftIndex)) << (8*sizeof(unsigned) - shiftIndex);
      result &= ~(~0U << number);
      fDoesFollow = ((currentPathExplorer->currentStackPosition() + number)
               < (int) currentPathExplorer->stackTrace().log_base_2())
            || currentPathExplorer->currentUnstableBranch()
               < currentPathExplorer->numberOfUnstableBranches();
      initialDoesFollow = fDoesFollow || (currentPathExplorer->mode() != MRealAndImplementation);
   }
   else
      result = 0;
   unsigned oldResult = result;

   bool isLastCaseIfFollow = false;
   if (realNumber == 0 || implementationNumber == 0) {
      if (implementationNumber != 0) {
         AssumeCondition(result < implementationNumber)
         realChoice = false;
         implementationChoice = true;
         currentPathExplorer->doesCurrentUnstableHasOtherBranches() = (result == 0); // result == implementationNumber-1
      }
      else {
         AssumeCondition(result < realNumber)
         realChoice = true;
         implementationChoice = false;
         currentPathExplorer->doesCurrentUnstableHasOtherBranches() = (result == 0); // result == realNumber-1
      };
   }
   else if (realNumber == 1 || implementationNumber == 1) {
      if (implementationNumber > 1) { // realNumber == 1
         AssumeCondition(result < 2*implementationNumber-commonNumber)
         if (result == 0) {
            if (commonNumber == 1) {
               implementationChoice = true;
               realChoice = true;
            }
            else {
               implementationChoice = true;
               realChoice = false;
               currentPathExplorer->doesCurrentUnstableHasOtherBranches() = true; // false
            };
         }
         else {
            if (commonNumber == 1) {
               implementationChoice = (result & 0x1);
               realChoice = !(result & 0x1);
            }
            else {
               implementationChoice = !(result & 0x1);
               realChoice = (result & 0x1);
               currentPathExplorer->doesCurrentUnstableHasOtherBranches() = false; // result == 2*implementationNumber-1
            };
         };
      }
      else { // implementationNumber == 1 && realNumber >= 1
         AssumeCondition(result < 2*realNumber-commonNumber)
         if (result == 0) {
            if (commonNumber == 1) {
               implementationChoice = true;
               realChoice = true;
            }
            else {
               implementationChoice = true;
               realChoice = false;
               currentPathExplorer->doesCurrentUnstableHasOtherBranches() = true; // result == 2*realNumber-1
            };
         }
         else {
            if (commonNumber == 1) {
               implementationChoice = (result & 0x1);
               realChoice = !(result & 0x1);
            }
            else {
               implementationChoice = !(result & 0x1);
               realChoice = (result & 0x1);
               currentPathExplorer->doesCurrentUnstableHasOtherBranches() = false; // result == 2*realNumber-1
            };
         };
      }
      if (implementationChoice != realChoice) {
         ++currentPathExplorer->currentUnstableBranch();
         // fDoesFollow = ((currentPathExplorer->currentStackPosition() + number) < (int) currentPathExplorer->stackTrace().log_base_2())
         //       || currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
         if (fDoesFollow) {
            fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
            if (fDoesFollow) {
               result = implementationChoice ? (result+1) : (result-1);
               isLastCaseIfFollow = true;
            };
         };
      };
   }
   else { // realNumber > 1 and implementationNumber > 1
      AssumeCondition(result < 2*realNumber*implementationNumber - commonNumber)
   
      if (result < commonNumber)
         realChoice = implementationChoice = true;
      else {
         realChoice = (result - commonNumber) & 0x1;
         implementationChoice = !((result - commonNumber) & 0x1);
      }
      if (implementationChoice != realChoice) {
         ++currentPathExplorer->currentUnstableBranch();
         // fDoesFollow = ((currentPathExplorer->currentStackPosition() + number) < (int) currentPathExplorer->stackTrace().log_base_2())
         //       || currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
         if (fDoesFollow) {
            fDoesFollow = currentPathExplorer->currentUnstableBranch() < currentPathExplorer->numberOfUnstableBranches();
            if (fDoesFollow) {
               result = implementationChoice ? (result+1) : (result-1);
               isLastCaseIfFollow = true;
            };
         };
      };
   };

   if (!fDoesFollow) {
      ++result;
      if (result == (unsigned) (2*realNumber*implementationNumber - commonNumber))
         result = 0;
      currentPathExplorer->lastResult() = result;
      currentPathExplorer->lastLogCases() = number;
      currentPathExplorer->lastResultCases() = conversion;
      if (oldResult < conversion-1) {
         if (currentPathExplorer->mode() == MRealAndImplementation
               && (realChoice == false || implementationChoice == false)
               && oldResult == conversion-2) {
            currentPathExplorer->previousLastZeroBit() = currentPathExplorer->lastZeroBit();
            currentPathExplorer->previousLastIncBit() = currentPathExplorer->lastIncBit();
         };
         currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+number;
         currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
      };
      if ((int) (8*sizeof(unsigned) - shiftIndex) > number) {
         currentPathExplorer->stackTrace()[index] &= ~(~(~0U << number) << shiftIndex);
         currentPathExplorer->stackTrace()[index] |= oldResult << shiftIndex;
      }
      else { // number >= (8*sizeof(unsigned) - shiftIndex)
         currentPathExplorer->stackTrace()[index] &= ~(~0U << shiftIndex);
         currentPathExplorer->stackTrace()[index+1] &= ~0U << (number - (8*sizeof(unsigned) - shiftIndex));
         currentPathExplorer->stackTrace()[index] |= oldResult << shiftIndex;
         currentPathExplorer->stackTrace()[index+1] |= oldResult >> (number - (8*sizeof(unsigned) - shiftIndex));
      };
   }
   else if (result < conversion-1 && !isLastCaseIfFollow) {
      if (currentPathExplorer->mode() == MRealAndImplementation
            && (realChoice == false || implementationChoice == false)
            && oldResult == conversion-2) {
         currentPathExplorer->previousLastZeroBit() = currentPathExplorer->lastZeroBit();
         currentPathExplorer->previousLastIncBit() = currentPathExplorer->lastIncBit();
      };
      currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+number;
      currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
   }
   currentPathExplorer->currentStackPosition() += number;

   if (realChoice != implementationChoice) {
      if (!fDoesFollow)
         fDoesFollow = initialDoesFollow;
      if (!realChoice) {
         AssumeCondition(currentPathExplorer->mode() != MOnlyReal)
         if (currentPathExplorer->mode() == MRealAndImplementation) {
            AssumeCondition(szSynchronisationFile == nullptr)
            szSynchronisationFile = szFile;
            uSynchronisationLine = uLine;
            currentPathExplorer->mode() = MOnlyImplementation;
            initialMergeTable().setInitial(symbolsManager());
            if (!fDoesFollow && szFile == nullptr) {
               oTraceFile->writesome("the macros FLOAT_SPLIT_ALL and FLOAT_MERGE_ALL should be correctly defined!\n");
               writeBackTrace(*oTraceFile);
               oTraceFile->flush();
               throw anticipated_termination();
            }
            szFile = nullptr;
            uLine = 0;
         }
      }
      else { // !implementationChoice
         AssumeCondition(currentPathExplorer->mode() != MOnlyImplementation)
         if (currentPathExplorer->mode() == MRealAndImplementation) {
            AssumeCondition(szSynchronisationFile == nullptr)
            szSynchronisationFile = szFile;
            uSynchronisationLine = uLine;
            currentPathExplorer->mode() = MOnlyReal;
            initialMergeTable().setInitial(symbolsManager());
            if (!fDoesFollow && szFile == nullptr) {
               oTraceFile->writesome("the macros FLOAT_SPLIT_ALL and FLOAT_MERGE_ALL should be correctly defined!\n");
               writeBackTrace(*oTraceFile);
               oTraceFile->flush();
               throw anticipated_termination();
            }
            szFile = nullptr;
            uLine = 0;
         }
      }
   }

   result = oldResult;
   if (result >= commonNumber) {
      if (implementationNumber == 0 || realNumber == 0)
         return result;

      if (commonNumber == 0) {
         // 0 <= result < 2*implementationNumber*realNumber
         bool isImplementation = result & 0x1;
         result >>= 1;
         // 0 <= result < implementationNumber*realNumber
         unsigned implementation = (result / realNumber), real = (result % realNumber);
         AssumeCondition(realChoice != implementationChoice)
         alternativeResult = isImplementation ? real : implementation;
         return isImplementation ? implementation : real;
      };

      if (implementationNumber == 1 || realNumber == 1) {
         // 1 <= result < 2*implementationNumber*realNumber-1
         --result;
         bool isImplementation = result & 0x1;
         result >>= 1;
         // 0 <= result < implementationNumber*realNumber-1
         if (isImplementation) {
            if (implementationNumber == 1) {
               alternativeResult = (result >= firstRealCommon) ? result+1 : result;
               return 0;
            };
            // 0 <= result < implementationNumber-1
            alternativeResult = 0;
            return (result >= firstImplementationCommon) ? result+1 : result;
         };
         if (realNumber == 1) {
            alternativeResult = (result >= firstImplementationCommon) ? result+1 : result;
            return 0;
         };
         // 0 <= result < realNumber-1
         alternativeResult = 0;
         return (result >= firstRealCommon) ? result+1 : result;
      };

      // implementationNumber > 1 && realNumber > 1 && commonNumber > 0
      // commonNumber <= result < 2*implementationNumber*realNumber-commonNumber
      result -= commonNumber;
      bool isImplementation = !(result & 0x1);
      result >>= 1;
      // 0 <= result < implementationNumber*realNumber-commonNumber
      unsigned implementationResult = result / realNumber;
      if (implementationResult >= firstImplementationCommon + commonNumber)
         result += commonNumber;
      else if (implementationResult >= firstImplementationCommon) {
         // firstRealCommon <= result/realNumber < firstRealCommon + commonNumber
         result += (implementationResult-firstImplementationCommon);
         // result += (firstRealCommon-implementationResult);
         if (result / realNumber > implementationResult)
            ++result;
      };
      implementationResult = result / realNumber;
      unsigned realResult = result % realNumber;
      if (implementationResult >= firstImplementationCommon) {
         if (realResult - firstRealCommon >= implementationResult - firstImplementationCommon) {
            ++realResult;
            if (realResult == realNumber) {
               ++implementationResult;
               realResult = (implementationResult == firstImplementationCommon) ? 1 : 0;
            };
         };
      };
      if (isImplementation) {
         alternativeResult = realResult;
         result = implementationResult;
      }
      else {
         alternativeResult = implementationResult;
         result = realResult;
      };
   };
   return result;
}

}} // end of namespace NumericalDomains::DAffine

