/**************************************************************************/
/*                                                                        */
/*  This file is part of FLDLib                                           */
/*                                                                        */
/*  Copyright (C) 2014-2017                                               */
/*    CEA (Commissariat à l'énergie atomique et aux énergies              */
/*         alternatives)                                                  */
/*                                                                        */
/*  you can redistribute it and/or modify it under the terms of the GNU   */
/*  Lesser General Public License as published by the Free Software       */
/*  Foundation, version 2.1.                                              */
/*                                                                        */
/*  It is distributed in the hope that it will be useful,                 */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of        */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
/*  GNU Lesser General Public License for more details.                   */
/*                                                                        */
/*  See the GNU Lesser General Public License version 2.1                 */
/*  for more details (enclosed in the file LICENSE).                      */
/*                                                                        */
/**************************************************************************/

/////////////////////////////////
//
// Library   : Collection
// Unit      : Concrete collections
// File      : MultiSorted.template
// Description :
//   Implementation of multiple collections based on sorted collections
//   and double linked lists for the elements with the same key.
//

#ifndef COL_MultiSortedTEMPLATE
#define COL_MultiSortedTEMPLATE

#include "Collection/ConcreteCollection/MultiSorted.h"
// #include "Collection/Collection.hpp"

namespace COL {

/******************************************************************/
/* Implementation of the template class TMultipleSortedCollection */
/******************************************************************/

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::correctDuplicationSplitReceiver(
      const typename SortedCollection::Cursor* scursor,
      VirtualCollection::RelativePosition direction, int addReceiver, bool isFirstExcluded) {
   typename SortedCollection::Cursor cursor(scSortedCollection);
   if (scursor) {
      cursor = *scursor;
      if (isFirstExcluded && cursor.isValid()) {
         if (direction == RPAfter)
            cursor.setToNext();
         else
            cursor.setToPrevious();
      }
      else if (!cursor.isValid()) {
         if (direction == RPAfter)
            cursor.setToFirst();
         else
            cursor.setToLast();
      };
   }
   else if (direction == RPAfter)
      cursor.setToFirst();
   else
      cursor.setToLast();
   try {
      for (bool doesContinue = (cursor.isValid() && (addReceiver != 0)); doesContinue;
            doesContinue = (((direction == RPAfter) ? cursor.setToNext() : cursor.setToPrevious())
               && (--addReceiver != 0))) {
         typename SortedCollection::Node* node = &cursor.elementSAt();
         IdentificationElement identification = TypeTraits::identifyElementFromSorted(*node);
         if (identification == IEReceiverMultiple) {
            scSortedCollection.replaceElementAtWith(cursor,
               ((ReceiverMultipleElement*) node)->extractCopyAndShareElement(),
               VirtualCollection::RMFree);
         }
         else if (identification == IEReceiverSingle) {
            scSortedCollection.replaceElementAtWith(cursor,
               ((ReceiverSingleElement*) node)->extractCopyAndShareElement(),
               VirtualCollection::RMFree);
         };
      };
   }
   catch (...) {
      if (cursor.isValid()) {
         bool doesFreeNext = false;
         while((direction == RPAfter) ? cursor.setToPrevious() : cursor.setToNext()) {
            if (doesFreeNext)
               scSortedCollection.remove(ExtendedSuppressParameters()
                  .setRelativePosition(direction).setFree(), &cursor);
            typename SortedCollection::Node* node = &cursor.elementSAt();
            IdentificationElement identification = TypeTraits::identifyElementFromSorted(*node);
            if (identification == IEReceiverMultiple) {
               ((ReceiverMultipleElement&) *node).removeAll(ExtendedSuppressParameters());
               doesFreeNext = true;
            }
            else if (identification == IEReceiverSingle) {
               ((ReceiverSingleElement&) *node).extractElement();
               doesFreeNext = true;
            }
            else
               doesFreeNext = false;
         };
         if (doesFreeNext)
            scSortedCollection.remove(ExtendedSuppressParameters()
               .setRelativePosition(direction).setFree(), nullptr);
      };
      throw;
   };
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::correctDuplicationCopyReceiver(const thisType& source,
      const VirtualCast* retrieveMultipleRegistrationFromCopy, const VirtualCast* retrieveSingleRegistrationFromCopy,
      const typename SortedCollection::Cursor* scursor,
      const typename SortedCollection::Cursor* sourceStart,
      const typename SortedCollection::Cursor* sourceEnd,
      RelativePosition direction, bool isFirstExcluded) {
   typename SortedCollection::Cursor cursor(scSortedCollection), sourceCursor(source.scSortedCollection);
   if (direction == RPAfter) {
      if (sourceStart)
         sourceCursor = *sourceStart;
      else
         sourceCursor.setToFirst();
   }
   else if (sourceEnd)
      sourceCursor = *sourceEnd;
   else
      sourceCursor.setToLast();

   if (scursor) {
      cursor = *scursor;
      if (isFirstExcluded && cursor.isValid()) {
         if (direction == RPAfter)
            cursor.setToNext();
         else
            cursor.setToPrevious();
      }
      else if (!cursor.isValid()) {
         if (direction == RPAfter)
            cursor.setToFirst();
         else
            cursor.setToLast();
      };
   }
   else if (direction == RPAfter)
      cursor.setToFirst();
   else
      cursor.setToLast();

   for (bool doesContinue = (cursor.isValid() && sourceCursor.isValid()); doesContinue;
      doesContinue = (direction == RPAfter)
         ? (cursor.setToNext() && sourceCursor.setToNext() && (!sourceEnd || !sourceCursor.isEqual(*sourceEnd)))
         : (cursor.setToPrevious() && sourceCursor.setToPrevious() && (!sourceStart || !sourceCursor.isEqual(*sourceStart)))) {
      typename SortedCollection::Node* node = &cursor.elementSAt();
      IdentificationElement identification = TypeTraits::identifyElementFromSorted(*node);
      if (identification == IEReceiverMultiple) {
         AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>(&sourceCursor.elementAt())
            && dynamic_cast<const ReceiverMultipleElement*>(&cursor.elementAt()))
         ((ReceiverMultipleElement&) cursor.elementSAt()).adjustCopy(
            (const ReceiverMultipleElement&) sourceCursor.elementAt(), retrieveMultipleRegistrationFromCopy);
      }
      else if (identification == IEReceiverSingle) {
         AssumeCondition(dynamic_cast<const ReceiverSingleElement*>(&sourceCursor.elementAt())
            && dynamic_cast<const ReceiverSingleElement*>(&cursor.elementAt()));
         ((ReceiverSingleElement&) cursor.elementAt()).adjustCopy(
            (const ReceiverSingleElement&) sourceCursor.elementAt(), retrieveSingleRegistrationFromCopy);
      };
   };
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_fullAssign(const thisType& source,
      const ExtendedReplaceParameters& parameters) {
   inherited::_fullAssign(source, parameters);
   if (this == &source)
      return;

   if (!parameters.isFree())
      _removeAll(ExtendedSuppressParameters());
   else {
      scSortedCollection.freeAll();
      uCount = 0;
   };

   try {
      duplicateBody(source, parameters.getDuplicate(), parameters.getSCast());
      uCount = source.uCount;
   }
   catch (...) {
      uCount = 0;
      scSortedCollection.foreachDo([this](const typename SortedCollection::Node& node)
         {  IdentificationElement identification = TypeTraits::identifyElementFromSorted(node);
            if (identification == IEReceiverMultiple)
               uCount += ((const ReceiverMultipleElement&) node).count();
            else
               uCount += 1;
            return true;
         });
      throw;
   };
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_add(EnhancedObject* anObject,
   const ExtendedInsertionParameters& parameters, VirtualCollectionCursor* cursor) {
   inherited::_add(anObject, parameters, cursor);
   AddGuardian<EnhancedObject> guard(*this, anObject, parameters);
   CommonElement* element = BaseCast::castFrom(anObject);

   IdentificationElement identification = TypeTraits::identifyElementFromCommon(*element);
   if (parameters.hasKey()) {
      if (identification == IESingle) {
         guard.release();
         _add(TypeTraits::queryKey(parameters.getKeyHandler()),
              SingleBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      }
      else if (identification == IEMultiple) {
         guard.release();
         _add(TypeTraits::queryKey(parameters.getKeyHandler()),
              MultipleBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      }
      else {
         AssumeCondition(identification == IEUnique)
         guard.release();
         _add(UniqueBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      };
   }
   else if (parameters.containsKey()) {
      if (identification == IESingle) {
         guard.release();
         _add(key(SingleBaseCast::castFrom(*element)),
              SingleBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      }
      else if (identification == IEMultiple) {
         guard.release();
         _add(key(MultipleBaseCast::castFrom(*element)),
              MultipleBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      }
      else {
         AssumeCondition(identification == IEUnique)
         guard.release();
         _add(UniqueBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      };
   }
   else {
      if (identification == IEMultiple) {
         guard.release();
         _add(MultipleBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      }
      else {
         AssumeCondition(identification == IEUnique)
         guard.release();
         _add(UniqueBaseCast::castFrom(element), parameters, (Cursor*) cursor);
      };
   };
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_add(UniqueElement* element,
      const ExtendedInsertionParameters& parameters, Cursor* cursor) {
   inherited::_add(BaseCast::castTo(TypeTraits::UniqueBaseCast::castTo(element)), parameters, cursor);
   if (!parameters.isInsertion()) {
      AddGuardian<UniqueElement> guard(*this, element, parameters);
      element = (UniqueElement*) guard.handleDuplication(parameters.hasCast()
         ? &((const VirtualCast&) RetrieveUniqueAssistedRegistrationFromCopyCast(parameters.getCast()))
         : (HasCopyHandlerOnSorted ? nullptr
         : &((const VirtualCast&) RetrieveUniqueRegistrationFromCopyCast())));
      typename SortedCollection::Cursor* newCursor = (cursor != nullptr) ? &cursor->sortedCursor() : nullptr;
      typename SortedCollection::PPCursor garbage;
      if ((cursor == nullptr) || parameters.isRemote()) {
         garbage = scSortedCollection.newCursor();
         newCursor = garbage.key();
      };
      typename SortedCollection::LocationResult result
         = parameters.hasKey()
            ? scSortedCollection.locateKey(TypeTraits::queryKey(parameters), *newCursor)
            : scSortedCollection.locate(*element, *newCursor);
      if (result)
         throw EConflictKeyError();
      scSortedCollection.add(element, result.queryInsertionParameters(), newCursor);
      guard.release();
   }
   else {
      if (!parameters.isDuplicate() || (HasCopyHandlerOnSorted && !parameters.hasCast()))
         scSortedCollection.add(element, parameters, cursor ? &cursor->sortedCursor() : nullptr);
      else {
         typedef DVirtualCollection::TReferenceInsertionParameters<
               ExtendedInsertionParameters, ExtendedInsertionParameters> ReferenceInsertionParameters;
         DVirtualCollection::TCastParameters<ReferenceInsertionParameters>
            enhancedParameters(ReferenceInsertionParameters(parameters, parameters));

         if (parameters.hasCast())
            scSortedCollection.add(element, enhancedParameters.setExternCast(
               RetrieveUniqueAssistedRegistrationFromCopyCast(parameters.getCast())),
               cursor ? &cursor->sortedCursor() : nullptr);
         else // !HasCopyHandlerOnSorted
            scSortedCollection.add(element, enhancedParameters.setExternCast(
               RetrieveUniqueRegistrationFromCopyCast()),
               cursor ? &cursor->sortedCursor() : nullptr);
      };
   };
   if ((cursor != nullptr)  && !parameters.isRemote() && cursor->multipleCursor().isValid())
      cursor->multipleCursor().release();
   ++uCount;
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_add(MultipleElement* element,
      const ExtendedInsertionParameters& parameters, Cursor* cursor) {
   inherited::_add(BaseCast::castTo(TypeTraits::MultipleBaseCast::castTo(element)), parameters, cursor);
   AddGuardian<MultipleElement> guard(*this, element, parameters);
   ReceiverMultipleElement* receiver=nullptr;
   receiver = cursor ? (ReceiverMultipleElement*) &cursor->sortedCursor().elementSAt() : nullptr;
   AssumeCondition((cursor != nullptr) && dynamic_cast<const ReceiverMultipleElement*>(receiver))

   if (!parameters.isDuplicate() || (HasCopyHandlerOnMultiple && !parameters.hasCast())) {
      guard.release();
      receiver->add(element, parameters, cursor->multipleCursor().isValid() ?
         cursor->multipleCursor().key() : nullptr);
   }
   else { // parameters.isDuplicate()
      DVirtualCollection::TCastParameters<ExtendedInsertionParameters>
         enhancedParameters(parameters);
      guard.release();
      if (parameters.hasCast())
         receiver->add(element, enhancedParameters.setExternCast(
            RetrieveMultipleAssistedRegistrationFromCopyCast(parameters.getCast())),
            cursor->multipleCursor().isValid() ?  cursor->multipleCursor().key() : nullptr);
      else
         receiver->add(element, enhancedParameters.setExternCast(
            RetrieveMultipleRegistrationFromCopyCast()),
            cursor->multipleCursor().isValid() ?  cursor->multipleCursor().key() : nullptr);
   };
   ++uCount;
}
   
template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_add(typename Key::KeyType key, UniqueElement* element,
      const ExtendedInsertionParameters& parameters, Cursor* cursor) {
   inherited::_add(BaseCast::castTo(TypeTraits::UniqueBaseCast::castTo(element)), parameters, cursor);
   if (!parameters.isInsertion()) {
      AddGuardian<UniqueElement> guard(*this, element, parameters);
      element = (UniqueElement*) guard.handleDuplication(parameters.hasCast()
         ? &((const VirtualCast&) RetrieveUniqueAssistedRegistrationFromCopyCast(parameters.getCast()))
         : (HasCopyHandlerOnSorted ? nullptr
         : &((const VirtualCast&) RetrieveUniqueRegistrationFromCopyCast())));
      Cursor* newCursor = cursor;
      PPCursor garbage;
      if ((cursor == nullptr) || parameters.isRemote()) {
         garbage = newCursor();
         newCursor = garbage.key();
      };
      typename SortedCollection::LocationResult result = scSortedCollection.locateKey(key, newCursor->sortedCursor());
      if (result)
         throw EConflictKeyError();
      scSortedCollection.add(element, result.queryInsertionParameters(), &newCursor->sortedCursor());
      guard.release();
   }
   else {
      typedef DVirtualCollection::TReferenceInsertionParameters<ExtendedInsertionParameters, ExtendedInsertionParameters>
         ReferenceInsertionParameters;
      typedef DVirtualCollection::TMapParameters<ReferenceInsertionParameters, typename TypeTraits::KeyTraits>
         MapInsertionParameters;

      if (!parameters.isDuplicate() || (HasCopyHandlerOnSorted && !parameters.hasCast())) {
         MapInsertionParameters mapParameters(ReferenceInsertionParameters(parameters, parameters), key);
         scSortedCollection.add(element, mapParameters, cursor ? &cursor->sortedCursor() : nullptr);
      }
      else {
         DVirtualCollection::TCastParameters<MapInsertionParameters>
            enhancedParameters(MapInsertionParameters(&(const ReferenceInsertionParameters&)
               ReferenceInsertionParameters(parameters, parameters), key));
         if (parameters.hasCast())
            scSortedCollection.add(element, enhancedParameters.setExternCast(
               RetrieveUniqueAssistedRegistrationFromCopyCast(parameters.getCast())),
               cursor ? &cursor->sortedCursor() : nullptr);
         else // !HasCopyHandlerOnSorted
            scSortedCollection.add(element, enhancedParameters.setExternCast(
               RetrieveUniqueRegistrationFromCopyCast()),
               cursor ? &cursor->sortedCursor() : nullptr);
      };
   };
   if ((cursor != nullptr)  && !parameters.isRemote() && cursor->multipleCursor().isValid())
      cursor->multipleCursor().release();
   ++uCount;
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_add(typename Key::KeyType key, MultipleElement* element,
      const ExtendedInsertionParameters& params, Cursor* cursor) {
   inherited::_add(BaseCast::castTo(TypeTraits::MultipleBaseCast::castTo(element)), params, cursor);
   AddGuardian<CommonElement> guard(*this, element, params);
   element = (MultipleElement*) guard.handleDuplication(params.hasCast()
      ? &((const VirtualCast&) RetrieveMultipleAssistedRegistrationFromCopyCast(params.getCast()))
      : (HasCopyHandlerOnMultiple ? nullptr
      : &((const VirtualCast&) RetrieveMultipleRegistrationFromCopyCast())));
   AssumeCondition(MultipleDynamicBaseCast::castFrom(MultipleBaseCast::castTo(element)))
   DVirtualCollection::TReferenceParameters<ExtendedInsertionParameters, ExtendedInsertionParameters>
      parameters(params, params);
   parameters.releaseFreeOnError().releaseDuplicate();
   if (parameters.isInsertion()) {
      if ((cursor == nullptr) || (!cursor->Cursor::isValid())) {
         ComparisonResult compare = scSortedCollection.isEmpty()
            ? getComparison(parameters)
            : Key::compare(key, scSortedCollection.queryKey(parameters));
         AssumeCondition((compare == CREqual) || (parameters.isAfter()
            ? (compare == CRLess) : (compare == CRGreater)))
         if (compare != CREqual) {
            parameters.setFreeOnError();
            ReceiverMultipleElement* receiver = nullptr;
            scSortedCollection.add(receiver = new ReceiverMultipleElement(key), parameters);
            parameters.releaseFreeOnError();
            receiver->add(element, parameters);
            guard.release();
            if (cursor && !parameters.isRemote()) {
               VirtualCollectionCursor::Position position;
               position.setStartDirection(parameters.getRelativePosition());
               cursor->sortedCursor().position(position);
               cursor->multipleCursor() = receiver->newCursor();
               cursor->multipleCursor()->position(position);
            };
         }
         else { // compare == CREqual
            if (TypeTraits::identifyElementFromSorted(scSortedCollection.getElement(parameters))
                  != IEReceiverMultiple)
               throw EConflictKeyError();

            ReceiverMultipleElement* receiver = (ReceiverMultipleElement*)
               &scSortedCollection.getElement(parameters);
            AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>(
               (typename SortedCollection::Node*) receiver))
            if (cursor && !parameters.isRemote()) {
               cursor->sortedCursor().position(VirtualCollectionCursor::Position()
                  .setStartDirection(parameters.getRelativePosition()));
               cursor->multipleCursor() = receiver->newCursor();
            };
            receiver->add(element, parameters, ((cursor != nullptr)  && !parameters.isRemote())
               ? cursor->multipleCursor().key() : nullptr);
            guard.release();
         };
      }
      else { // cursor->isValid() && parameters.isInsertion()
         typename SortedCollection::Cursor& sortedCursor = cursor->sortedCursor();
         ComparisonResult
            compare = Key::compare(key, sortedCursor.queryKey()),
            compareNext = sortedCursor.isPositionned(
               ExtendedLocateParameters(inverse(parameters.getRelativePosition())))
               ? getComparison(parameters)
               : Key::compare(key, scSortedCollection.queryKey(parameters,
                     &sortedCursor));
         AssumeCondition(
            ((compare == inverse(getComparison(parameters))) || (compare == CREqual))
            && ((compareNext == getComparison(parameters)) || (compareNext == CREqual))
            && (compare != compareNext))
         ReceiverMultipleElement* receiver = nullptr;
         if (compare == CREqual) {
            if (TypeTraits::identifyElementFromSorted(sortedCursor.elementAt()) != IEReceiverMultiple)
               throw EConflictKeyError();
            receiver = (ReceiverMultipleElement*) &sortedCursor.elementSAt();
            AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>(
               (typename SortedCollection::Node*) receiver))
            receiver->add(element, parameters, cursor->multipleCursor().key());
            guard.release();
         }
         else if (compareNext == CREqual) {
            if (TypeTraits::identifyElementFromSorted(scSortedCollection.getElement(
                  parameters, &sortedCursor)) != IEReceiverMultiple)
               throw EConflictKeyError();
            receiver = (ReceiverMultipleElement*)
               &scSortedCollection.getElement(parameters, &sortedCursor);
            AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>(
               (typename SortedCollection::Node*) receiver))
            if (!parameters.isRemote()) {
               cursor->sortedCursor().position((typename Cursor::Position()).setDirection(parameters.getRelativePosition()));
               cursor->multipleCursor() = receiver->newCursor();
               receiver->add(element, parameters, cursor->multipleCursor().key());
            }
            else
               receiver->add(element, parameters, nullptr);
            guard.release();
         }
         else {
            parameters.setFreeOnError();
            scSortedCollection.add(receiver = new ReceiverMultipleElement(key),
               parameters, &cursor->sortedCursor());
            parameters.releaseFreeOnError();
            receiver->add(element, parameters);
            guard.release();
            if (!parameters.isRemote()) {
               cursor->multipleCursor() = receiver->newCursor();
               cursor->multipleCursor()->position((typename Cursor::Position())
                  .setStartDirection(parameters.getRelativePosition()));
            };
         };
      };
   }
   else { // !parameters.isInsertion()
      if (cursor && !parameters.isRemote()) {
         typename SortedCollection::LocationResult result
            = scSortedCollection.locateKey(key, cursor->sortedCursor());
         ReceiverMultipleElement* receiver = nullptr;
         if (!result) {
            scSortedCollection.add(receiver = new ReceiverMultipleElement(key),
               result.queryInsertionParameters().setFreeOnError(), &cursor->sortedCursor());
            receiver->add(element, parameters);
            guard.release();
            cursor->multipleCursor() = receiver->newCursor();
            cursor->multipleCursor()->setToFirst();
         }
         else {
            if (TypeTraits::identifyElementFromSorted(cursor->sortedCursor().elementAt())
                  != IEReceiverMultiple)
               throw EConflictKeyError();
            receiver = (ReceiverMultipleElement*) &cursor->sortedCursor().elementSAt();
            AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>(
               (typename SortedCollection::Node*) receiver))
            cursor->multipleCursor() = receiver->newCursor();
            receiver->add(element, parameters, cursor->multipleCursor().key());
            guard.release();
         };
      }
      else { // !cursor || parameters.isRemote()
         typename SortedCollection::Cursor sortedCursor(scSortedCollection);
         typename SortedCollection::LocationResult result
            = scSortedCollection.locateKey(key, sortedCursor);
         ReceiverMultipleElement* receiver = nullptr;
         if (!result) {
            scSortedCollection.add(receiver = new ReceiverMultipleElement(key),
               result.queryInsertionParameters().setFreeOnError(), &sortedCursor);
            receiver->add(element, parameters);
         }
         else {
            if (TypeTraits::identifyElementFromSorted(sortedCursor.elementAt()) != IEReceiverMultiple)
               throw EConflictKeyError();
            receiver = (ReceiverMultipleElement*) &sortedCursor.elementSAt();
            AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>(
               (typename SortedCollection::Node*) receiver))
            receiver->add(element, parameters);
         };
         guard.release();
      };
   };

   ++uCount;
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_add(typename Key::KeyType key, SingleElement* element,
      const ExtendedInsertionParameters& params, Cursor* cursor) {
   inherited::_add(BaseCast::castTo(TypeTraits::SingleBaseCast::castTo(element)), params, cursor);

   AddGuardian<CommonElement> guard(*this, element, params);
   element = (SingleElement*) guard.handleDuplication(params.hasCast()
      ? &((const VirtualCast&) RetrieveSingleAssistedRegistrationFromCopyCast(params.getCast()))
      : (HasCopyHandlerOnSingle ? nullptr : &((const VirtualCast&) RetrieveSingleRegistrationFromCopyCast())));
   AssumeCondition(SingleDynamicBaseCast::castFrom(SingleBaseCast::castTo(element)))

   if (!params.isInsertion()) {
      typename SortedCollection::Cursor* newCursor = (cursor != nullptr) ? &cursor->sortedCursor() : nullptr;
      typename SortedCollection::PPCursor garbage;
      if ((cursor == nullptr) || params.isRemote()) {
         garbage = scSortedCollection.newCursor();
         newCursor = garbage.key();
      };
      typename SortedCollection::LocationResult result = scSortedCollection.locateKey(key, *newCursor);
      if (result)
         throw EConflictKeyError();
      ReceiverSingleElement* receiver = nullptr;
      scSortedCollection.add(receiver = new ReceiverSingleElement(key),
         result.queryInsertionParameters().setFreeOnError(), newCursor);
      receiver->absorbElement(element);
      guard.release();
   }
   else {
      DVirtualCollection::TReferenceParameters<ExtendedInsertionParameters, ExtendedInsertionParameters>
         parameters(params, params);

      ReceiverSingleElement* receiver = nullptr;
      parameters.setLocal().setFreeOnError().releaseDuplicate();
      scSortedCollection.add(receiver = new ReceiverSingleElement(key),
         parameters, (cursor != nullptr) ? &cursor->sortedCursor() : nullptr);
      receiver->absorbElement(element);
      guard.release();
   };

   if (cursor && !params.isRemote())
      cursor->multipleCursor().release();
   ++uCount;
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::paddAll(const thisType& source,
      const ExtendedInsertionParameters& parameters, Cursor* cursor,
      const Cursor* startSource, const Cursor* endSource) {
   const VirtualCollectionCursor *sstartSource = startSource,
                                 *sendSource = endSource;
   VirtualCollection::_addAll(source, parameters, cursor, sstartSource, sendSource);
   if (!source.normalize(sstartSource, sendSource)) {
      if (cursor) cursor->invalidate();
      return;
   };
   startSource = (const Cursor*) sstartSource,
   endSource = (const Cursor*) sendSource;

   typename thisType::PPCursor sourceCursor(source.newCursor());
   bool isForward = !parameters.isRemote() || !parameters.isAfter();
   if (isForward) {
      if (startSource)
         *sourceCursor = *startSource;
      else
         sourceCursor->setToFirst();
   }
   else {
      if (endSource)
         *sourceCursor = *endSource;
      else
         sourceCursor->setToLast();
   };

   if (this == &source) // collision fortement probable pouvant mener à une non-terminaison
      throw ENotImplemented();

   if (sourceCursor->isValid() && (isForward
            ? ((endSource==nullptr) || (!sourceCursor->isEqual(*endSource)))
            : ((startSource==nullptr) || (!sourceCursor->isEqual(*startSource))))) {
      CommonElement* sourceElement = sourceCursor->getSElement();
      DVirtualCollection::TReferenceInsertionParameters<ExtendedInsertionParameters,
         ExtendedInsertionParameters> paramsCopy(parameters, parameters);
      paramsCopy.setUndefined();
      IdentificationElement identification = TypeTraits::identifyElementFromCommon(*sourceElement);
      if (identification == IEMultiple)
         _add(sourceCursor->queryKey(), MultipleBaseCast::castFrom(sourceElement), paramsCopy, cursor);
      else if (identification == IESingle)
         _add(sourceCursor->queryKey(), SingleBaseCast::castFrom(sourceElement), paramsCopy, cursor);
      else {
         AssumeCondition(identification == IEUnique)
         _add(sourceCursor->queryKey(), UniqueBaseCast::castFrom(sourceElement), paramsCopy, cursor);
      };

      for (sourceCursor->position(VirtualCollectionCursor::Position().setDirection(isForward ? COL::VirtualCollection::RPAfter : COL::VirtualCollection::RPBefore));
           sourceCursor->isValid() && (isForward
               ? ((endSource==nullptr) || (!sourceCursor->isEqual(*endSource)))
               : ((startSource==nullptr) || (!sourceCursor->isEqual(*startSource))));
           sourceCursor->position(VirtualCollectionCursor::Position()
               .setDirection(isForward ? COL::VirtualCollection::RPAfter : COL::VirtualCollection::RPBefore))) {
         sourceElement = sourceCursor->getSElement();
         identification = TypeTraits::identifyElementFromCommon(*sourceElement);
         if (identification == IEMultiple)
            _add(sourceCursor->queryKey(), MultipleBaseCast::castFrom(sourceElement), paramsCopy, cursor);
         else if (identification == IESingle)
            _add(sourceCursor->queryKey(), SingleBaseCast::castFrom(sourceElement), paramsCopy, cursor);
         else {
            AssumeCondition(identification == IEUnique)
            _add(sourceCursor->queryKey(), UniqueBaseCast::castFrom(sourceElement), paramsCopy, cursor);
         };
      };
   };
   if ((endSource != nullptr) && (sourceCursor->isValid())) {
      CommonElement* sourceElement = sourceCursor->getSElement();
      IdentificationElement identification = TypeTraits::identifyElementFromCommon(*sourceElement);
      if (identification == IEMultiple)
         _add(sourceCursor->queryKey(), MultipleBaseCast::castFrom(sourceElement), parameters, cursor);
      else if (identification == IESingle)
         _add(sourceCursor->queryKey(), SingleBaseCast::castFrom(sourceElement), parameters, cursor);
      else {
         AssumeCondition(identification == IEUnique)
         _add(sourceCursor->queryKey(), UniqueBaseCast::castFrom(sourceElement), parameters, cursor);
      };
      // _add(sourceCursor->getSElement(), parameters, cursor);
   };
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_addAll(const thisType& source,
      const ExtendedInsertionParameters& parameters, Cursor* cursor,
      const Cursor* startSource, const Cursor* endSource) {
   inherited::_addAll(source, parameters, cursor, startSource, endSource);
   if (source.uCount == 0)
      return;
   if (scSortedCollection.isEmpty()
         && ((startSource == nullptr) || !startSource->isValid() || !startSource->multipleCursor().isValid())
         && ((endSource == nullptr) || !endSource->isValid() || !endSource->multipleCursor().isValid())) {
      int newCount = source.uCount;
      if (((startSource != nullptr) && startSource->isValid())
         || ((endSource != nullptr) && endSource->isValid())) {
         CountReceiver countReceiver;
         source.scSortedCollection.foreachDo(countReceiver, ExtendedLocateParameters().setExact(),
            startSource ? &startSource->sortedCursor() : nullptr,
            endSource ? &endSource->sortedCursor() : nullptr);
         newCount = countReceiver.getCountElement();
      };

      try {
         addBody(source, ExtendedInsertionParameters(parameters).setLocal(),
            parameters.getSCast(), nullptr,
            startSource ? &startSource->sortedCursor() : nullptr,
            endSource ? &endSource->sortedCursor() : nullptr);
         uCount = newCount;
      }
      catch (...) {
         uCount = 0;
         scSortedCollection.foreachDo([this](const typename SortedCollection::Node& node)
            {  IdentificationElement identification = TypeTraits::identifyElementFromSorted(node);
               if (identification == IEReceiverMultiple)
                  uCount += ((const ReceiverMultipleElement&) node).count();
               else
                  uCount += 1;
               return true;
            });
         throw;
      };
   }
   else if (parameters.isDuplicate() && parameters.isInsertion()
         && ((startSource == nullptr) || !startSource->isValid() || !startSource->multipleCursor().isValid())
         && ((endSource == nullptr) || !endSource->isValid() || !endSource->multipleCursor().isValid())
         && ((cursor == nullptr) || !cursor->isValid() || !cursor->multipleCursor().isValid())) {
      int addCount = source.uCount, addCountReceiver = 0;
      if (((startSource != nullptr) && startSource->isValid())
         || ((endSource != nullptr) && endSource->isValid())) {
         CountReceiver countReceiver;
         source.scSortedCollection.foreachDo(countReceiver, ExtendedLocateParameters().setExact(),
            startSource ? &startSource->sortedCursor() : nullptr,
            endSource ? &endSource->sortedCursor() : nullptr);
         addCount = countReceiver.getCountElement();
         addCountReceiver = countReceiver.getCountReceiver();
      };

      addBody(source, ExtendedInsertionParameters(parameters).setLocal(),
         parameters.getSCast(),
         cursor != nullptr ? &cursor->sortedCursor() : nullptr,
         startSource ? &startSource->sortedCursor() : nullptr,
         endSource ? &endSource->sortedCursor() : nullptr,
         parameters.isAfter() ? (parameters.isRemote() ? COL::VirtualCollection::RPAfter : COL::VirtualCollection::RPBefore)
            : (parameters.isRemote() ? COL::VirtualCollection::RPBefore : COL::VirtualCollection::RPAfter), addCountReceiver);
      uCount += addCount;
   }
   else if (this != &source)
      paddAll(source, parameters, cursor, startSource, endSource);
   else
      AssumeUncalled
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_moveTo(thisType& destination,
      const ExtendedReplaceParameters& parameters, Cursor* cursor, Cursor* destinationCursor) {
   inherited::_moveTo(destination, parameters, cursor, destinationCursor);
   if (&destination != this) {
      CommonElement* movedObject = _getElement((const ExtendedSuppressParameters&) parameters, cursor);
      IdentificationElement identification = TypeTraits::identifyElementFromCommon(*movedObject);
      _remove((const ExtendedSuppressParameters&) parameters, cursor);
      try {
         if (identification == IEUnique)
            destination._add(_queryKey((const ExtendedSuppressParameters&) parameters, cursor),
               UniqueBaseCast::castFrom(movedObject), parameters, destinationCursor);
         else if (identification == IESingle)
            destination._add(_queryKey((const ExtendedSuppressParameters&) parameters, cursor),
               SingleBaseCast::castFrom(movedObject), parameters, destinationCursor);
         else {
            AssumeCondition(identification == IEMultiple)
            destination._add(_queryKey((const ExtendedSuppressParameters&) parameters, cursor),
               MultipleBaseCast::castFrom(movedObject), parameters, destinationCursor);
         };
      }
      catch (...) {
         if (identification == IEUnique)
            _add(_queryKey((const ExtendedSuppressParameters&) parameters, cursor),
               UniqueBaseCast::castFrom(movedObject), parameters, destinationCursor);
         else if (identification == IESingle)
            _add(_queryKey((const ExtendedSuppressParameters&) parameters, cursor),
               SingleBaseCast::castFrom(movedObject), parameters, destinationCursor);
         else {
            _add(_queryKey((const ExtendedSuppressParameters&) parameters, cursor),
               MultipleBaseCast::castFrom(movedObject), parameters, destinationCursor);
         };
         throw;
      };
   }
   else {
      AssumeCondition(cursor && destinationCursor)
      IdentificationElement
         sourceIdentification = TypeTraits::identifyElementFromSorted(cursor->sortedCursor().elementSAt()),
         destinationIdentification = TypeTraits::identifyElementFromSorted(destinationCursor->sortedCursor().elementSAt());
      if ((sourceIdentification == IEReceiverMultiple) && (destinationIdentification == IEReceiverMultiple)) {
         ReceiverMultipleElement* source = (ReceiverMultipleElement*) &cursor->sortedCursor().elementSAt();
         ReceiverMultipleElement* destination = (ReceiverMultipleElement*) &destinationCursor->sortedCursor().elementSAt();
         if (source->moveTo(*destination, parameters,
            *cursor->multipleCursor(), *destinationCursor->multipleCursor()))
            scSortedCollection.freeAt(cursor->sortedCursor());
      };
   };
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_moveAllTo(thisType& destination,
      const ExtendedReplaceParameters& parameters, const Cursor* startCursor,
      const Cursor* endCursor, Cursor* destinationCursor) {
   VirtualCollection::pmoveAllTo(destination, parameters, startCursor, endCursor, destinationCursor);
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_remove(const ExtendedSuppressParameters& parameters,
      Cursor* cursor) {
   inherited::_remove(parameters, cursor);
   
   typename SortedCollection::Node* node = nullptr;
   if (cursor && cursor->isValid()) {
      node = &cursor->sortedCursor().elementSAt();
      if (cursor->multipleCursor().isValid()) {
         ReceiverMultipleElement* snode = (ReceiverMultipleElement*) node;
         if (!parameters.isNear() || !cursor->multipleCursor()->isPositionned(
                  ExtendedLocateParameters(inverse(parameters.getRelativePosition())))) {
            if (snode->remove(parameters, cursor->multipleCursor().key()))
               scSortedCollection.freeAt(cursor->sortedCursor());
            uCount--;
            if (!cursor->multipleCursor().isValid())
               cursor->invalidate();
            return;
         }
      };
   };

   node = &scSortedCollection.getElement(parameters,
      (cursor && cursor->isValid()) ? &cursor->sortedCursor() : nullptr);
   IdentificationElement identification = TypeTraits::identifyElementFromSorted(*node);
   if (identification == IEReceiverMultiple) {
      if (((ReceiverMultipleElement*) node)->remove(
            ExtendedSuppressParameters(parameters)
               .setRelativePosition(inverse(parameters.getRelativePosition())), nullptr))
         scSortedCollection.remove(ExtendedSuppressParameters(parameters).setFree(),
            cursor ? &cursor->sortedCursor() : nullptr);
   }
   else if (identification == IEReceiverSingle) {
      if (parameters.isFree())
         scSortedCollection.remove(parameters, cursor ? &cursor->sortedCursor() : nullptr);
      else {
         ((ReceiverSingleElement*) node)->extractElement();
         scSortedCollection.remove(ExtendedSuppressParameters(parameters).setFree(),
            cursor ? &cursor->sortedCursor() : nullptr);
      };
   }
   else
      scSortedCollection.remove(parameters, cursor ? &cursor->sortedCursor() : nullptr);
   uCount--;
}

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_removeAll(const ExtendedSuppressParameters& parameters,
      const Cursor* start, const Cursor* end) {
   inherited::_removeAll(parameters, start, end);
   if (((start == nullptr) || !start->isValid()) && ((end == nullptr) || !end->isValid())
         && parameters.isFree()) {
      scSortedCollection.freeAll();
      uCount = 0;
   }
   else {
      if ((start != nullptr) && start->isValid() && (end != nullptr) && end->isValid()
               && start->multipleCursor().isValid() && end->multipleCursor().isValid()
               && start->sortedCursor().isEqual(end->sortedCursor())) {
         ReceiverMultipleElement* base = (ReceiverMultipleElement*) &start->sortedCursor().elementSAt();
         AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>((typename SortedCollection::Node*) base))
         int removed = base->count();
         if (base->removeAll(parameters, start->multipleCursor().key(), end->multipleCursor().key()))
            scSortedCollection.freeAt(const_cast<typename SortedCollection::Cursor&>(start->sortedCursor()));
         else
            removed -= base->count();
         uCount -= removed;
         return;
      };

      if (start && !start->isValid()) start = nullptr;
      if (end && !end->isValid()) end = nullptr;
      if (start && end && (start->sortedCursor() > end->sortedCursor()))
         return;

      typename SortedCollection::Node
         *startNode = (start != nullptr)
            ? (typename SortedCollection::Node*) &start->sortedCursor().elementSAt() : nullptr,
         *endNode = (end != nullptr)
            ? (typename SortedCollection::Node*) &end->sortedCursor().elementSAt() : nullptr;
      ExtendedSuppressParameters copyParameters(parameters);
      IdentificationElement identification = TypeTraits::identifyElementFromSorted(*startNode);
      if (startNode && (identification == IEReceiverMultiple)) {
         ReceiverMultipleElement* sstartNode = (ReceiverMultipleElement*) startNode;
         int removed = sstartNode->count();
         if (sstartNode->removeAll(parameters, start->multipleCursor().key(), nullptr)) {
            uCount -= removed;
            copyParameters.unsetFirstExcluded();
         }
         else {
            removed -= sstartNode->count();
            uCount -= removed;
            if (copyParameters.isBefore()) { // the cursor will be invalid in all cases
               if (!const_cast<typename SortedCollection::Cursor&>(start->sortedCursor())
                     .setToNext())
                  return;
            }
            else
               copyParameters.setFirstExcluded();
         };
      };

      if (endNode && (identification == IEReceiverMultiple)) {
         ReceiverMultipleElement* sendNode = (ReceiverMultipleElement*) endNode;
         int removed = sendNode->count();
         if (sendNode->removeAll(parameters, nullptr, end->multipleCursor().key())) {
            uCount -= removed;
            copyParameters.unsetLastExcluded();
         }
         else {
            removed -= sendNode->count();
            uCount -= removed;
            if (copyParameters.isAfter()) { // le curseur sera invalidé dans tous les cas
               if (!const_cast<typename SortedCollection::Cursor&>(end->sortedCursor())
                     .setToPrevious())
                  return;
            }
            else
               copyParameters.setLastExcluded();
         };
      };

      const typename SortedCollection::Cursor
         *sortedStart = (start != nullptr) ? &start->sortedCursor() : nullptr,
         *sortedEnd = (end != nullptr) ? &end->sortedCursor() : nullptr;

      CountReceiver countReceiver;
      scSortedCollection.foreachDo(countReceiver, copyParameters, sortedStart, sortedEnd);
         
      if (parameters.isFree())
         scSortedCollection.removeAll(copyParameters, sortedStart, sortedEnd);
      else {
         // suppress all the referenced elements
         FreeReceiver freeReceiver(countReceiver.getCountReceiver());
         scSortedCollection.foreachDo(freeReceiver, copyParameters, sortedStart, sortedEnd);
         scSortedCollection.removeAll(copyParameters, sortedStart, sortedEnd);
         freeReceiver.freeAll();
      };
      uCount -= countReceiver.getCountElement();
   };
}

namespace DMultipleSortedCollection {

template <class TypeReceiver, class TypeElement, class TypeSortedCollection>
class ReplaceWithReceiver : public PNT::AutoPointer<TypeReceiver> {
  private:
   typedef PNT::AutoPointer<TypeReceiver> inherited;
   VirtualCollection::ExtendedReplaceParameters erpParameters;
   bool fFreeOnError;

  public:
   ReplaceWithReceiver(TypeElement* element, const VirtualCollection::ExtendedReplaceParameters& params,
         typename TypeSortedCollection::Key::KeyType key, bool doesFree=true)
      :  erpParameters(params), fFreeOnError(params.isFreeOnError())
      {  if (erpParameters.isDuplicate()) {
            fFreeOnError = true;
            erpParameters.releaseDuplicate();
            element = element->createSCopy();
         };
         erpParameters.setFree(doesFree ? VirtualCollection::RMFree : VirtualCollection::RMRemove)
            .releaseFreeOnError();
         inherited::absorbElement(new TypeReceiver(key, element));
      }
   virtual ~ReplaceWithReceiver()
      {  if (inherited::isValid() && !fFreeOnError)
            inherited::getElement().extractElement();
      }
   void replace(TypeSortedCollection& collection, typename TypeSortedCollection::Cursor* cursor)
      {  collection.replace(&inherited::getElement(), erpParameters, cursor);
         inherited::getElement();
      }
};

} // end of namespace DMultipleSortedCollection

template <class TypeTraits>
void
TMultipleSortedCollection<TypeTraits>::_replace(CommonElement* newElement,
      const ExtendedReplaceParameters& parameters, Cursor* cursor) {
   inherited::_replace(BaseCast::castTo(newElement), parameters, cursor);
   if (cursor && !cursor->isValid()) cursor = nullptr;
   AddGuardian<CommonElement> guard(*this, newElement, parameters);
   IdentificationElement newIdentification = TypeTraits::identifyElementFromCommon(*newElement);

   if (cursor && cursor->multipleCursor().isValid()) {
      ReceiverMultipleElement* node = (ReceiverMultipleElement*) &cursor->sortedCursor().elementSAt();
      AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>((typename SortedCollection::Node*) node))
      if (!parameters.getSuppress().isNear() || (!cursor->multipleCursor()->isPositionned(
            ExtendedLocateParameters(inverse(parameters.getRemovePosition()))))) {
         // replacement at a multiple place
         if (!node->isSingleton() || (newIdentification == IEMultiple)) { // replacement multiple -> multiple
            AssumeCondition(newIdentification == IEMultiple)
            guard.release();
            if (!parameters.isDuplicate() || (!parameters.hasCast() && HasCopyHandlerOnMultiple))
               node->replace(MultipleBaseCast::castFrom(newElement), parameters,
                  cursor->multipleCursor().key());
            else if (parameters.hasCast())
               node->replace(MultipleBaseCast::castFrom(newElement),
                  DVirtualCollection::TCastParameters<ExtendedReplaceParameters>()
                     .setExternCast(RetrieveMultipleAssistedRegistrationFromCopyCast(parameters.getCast())),
                  cursor->multipleCursor().key());
            else // !HasCopyHandlerOnMultiple && parameters.isDuplicate() && !parameters.hasCast()
               node->replace(MultipleBaseCast::castFrom(newElement),
                  DVirtualCollection::TCastParameters<ExtendedReplaceParameters>()
                     .setExternCast(RetrieveMultipleRegistrationFromCopyCast()),
                  cursor->multipleCursor().key());
         }
         else { // node->isSingleton() && (identification != IEMultiple)
            node->remove(parameters, cursor->multipleCursor().key());
               
            try {
               if (newIdentification == IESingle) { // replacement multiple -> single
                  ExtendedReplaceParameters sortedParams(parameters);
                  sortedParams.setLocal().setFreeOnError().releaseDuplicate().setFree();
                  ReceiverSingleElement* receiver = nullptr;
                  scSortedCollection.replace(receiver = new ReceiverSingleElement(
                     cursor->sortedCursor().queryKey()), sortedParams, &cursor->sortedCursor());
                  receiver->absorbElement((SingleElement*) guard.handleDuplication(parameters.hasCast()
                     ? &((const VirtualCast&) RetrieveSingleAssistedRegistrationFromCopyCast(parameters.getCast()))
                     : (HasCopyHandlerOnSingle ? nullptr
                     : &((const VirtualCast&) RetrieveSingleRegistrationFromCopyCast()))));
                  guard.release();
               }
               else { // replacement multiple -> unique
                  AssumeCondition(newIdentification == IEUnique)
                  ExtendedReplaceParameters sortedParams(parameters);
                  sortedParams.setLocal().releaseFreeOnError().releaseDuplicate().setFree();
                  scSortedCollection.replace((UniqueElement*) guard.handleDuplication(parameters.hasCast()
                     ? &((const VirtualCast&) RetrieveUniqueAssistedRegistrationFromCopyCast(parameters.getCast()))
                     : (HasCopyHandlerOnSorted ? nullptr
                     : &((const VirtualCast&) RetrieveUniqueRegistrationFromCopyCast()))),
                     sortedParams, &cursor->sortedCursor());
                  guard.release();
               };
            }
            catch (...) {
               if (node->isEmpty())
                  scSortedCollection.remove(ExtendedSuppressParameters(parameters).setFree(),
                     &cursor->sortedCursor());
               throw;
            };
         };
         return;
      };
   };

   typename SortedCollection::Cursor* sortedCursor = cursor ? &cursor->sortedCursor() : nullptr;
   typename SortedCollection::Node* node = &scSortedCollection.getElement(
      (const ExtendedSuppressParameters&) parameters, sortedCursor);
   IdentificationElement sortedIdentification = TypeTraits::identifyElementFromSorted(*node);
   if (sortedIdentification == IEReceiverMultiple) {
      // replace at a multiple place
      ReceiverMultipleElement* snode = (ReceiverMultipleElement*) node;
      if (!snode->isSingleton() || (newIdentification == IEMultiple)) { // replacement multiple -> multiple
         AssumeCondition(newIdentification == IEMultiple)
         guard.release();
         if (!parameters.isDuplicate() || (!parameters.hasCast() && HasCopyHandlerOnMultiple))
            snode->replace(MultipleBaseCast::castFrom(newElement), parameters, nullptr);
         else if (parameters.hasCast())
            snode->replace(MultipleBaseCast::castFrom(newElement),
               DVirtualCollection::TCastParameters<ExtendedReplaceParameters>()
               .setExternCast(RetrieveMultipleAssistedRegistrationFromCopyCast(parameters.getCast())), nullptr);
         else // !HasCopyHandlerOnMultiple && parameters.isDuplicate() && !parameters.hasCast()
            snode->replace(MultipleBaseCast::castFrom(newElement),
               DVirtualCollection::TCastParameters<ExtendedReplaceParameters>()
               .setExternCast(RetrieveMultipleRegistrationFromCopyCast()), nullptr);
      }
      else {
         snode->remove(parameters, nullptr);
         try {
            if (newIdentification == IESingle) { // replacement multiple -> single
               ExtendedReplaceParameters sortedParams(parameters);
               sortedParams.setLocal().setFreeOnError().releaseDuplicate().setFree();
               ReceiverSingleElement* receiver = nullptr;
               scSortedCollection.replace(receiver = new ReceiverSingleElement(
                  scSortedCollection.queryKey((const ExtendedSuppressParameters&) parameters, sortedCursor)),
                  sortedParams, sortedCursor);
               receiver->absorbElement((SingleElement*) guard.handleDuplication(parameters.hasCast()
                  ? &((const VirtualCast&) RetrieveSingleAssistedRegistrationFromCopyCast(parameters.getCast()))
                  : (HasCopyHandlerOnSingle ? nullptr
                  : &((const VirtualCast&) RetrieveSingleRegistrationFromCopyCast()))));
               guard.release();
            }
            else { // replacement multiple -> unique
               AssumeCondition(newIdentification == IEUnique)
               ExtendedReplaceParameters sortedParams(parameters);
               sortedParams.setLocal().releaseFreeOnError().releaseDuplicate().setFree();
               scSortedCollection.replace((UniqueElement*) guard.handleDuplication(parameters.hasCast()
                  ? &((const VirtualCast&) RetrieveUniqueAssistedRegistrationFromCopyCast(parameters.getCast()))
                  : (HasCopyHandlerOnSorted ? nullptr
                  : &((const VirtualCast&) RetrieveUniqueRegistrationFromCopyCast()))),
                  sortedParams, sortedCursor);
               guard.release();
            };
         }
         catch (...) {
            if (snode->isEmpty())
               scSortedCollection.remove(ExtendedSuppressParameters(parameters).setFree(), sortedCursor);
            throw;
         };
      };
      return;
   }
   else if (sortedIdentification == IEReceiverSingle) {
      ReceiverSingleElement* snode = (ReceiverSingleElement*) node;
      SingleElement* oldElement = snode->extractElement();
      if (oldElement && parameters.isFree())
         delete oldElement;
      oldElement = nullptr;
      try {
         if (newIdentification == IESingle)
            snode->absorbElement((SingleElement*) guard.handleDuplication(parameters.hasCast()
               ? &((const VirtualCast&) RetrieveSingleAssistedRegistrationFromCopyCast(parameters.getCast()))
               : (HasCopyHandlerOnSingle ? nullptr
               : &((const VirtualCast&) RetrieveSingleRegistrationFromCopyCast()))));
         else if (newIdentification == IEMultiple) { // single -> multiple
            ExtendedReplaceParameters sortedParams(parameters);
            sortedParams.setLocal().setFreeOnError().releaseDuplicate().setFree();
            ReceiverMultipleElement* receiver = nullptr;
            scSortedCollection.replace(receiver = new ReceiverMultipleElement(
               scSortedCollection.queryKey((const ExtendedSuppressParameters&) parameters, sortedCursor)),
               sortedParams, sortedCursor);
            receiver->add((MultipleElement*) guard.handleDuplication(parameters.hasCast()
               ? &((const VirtualCast&) RetrieveMultipleAssistedRegistrationFromCopyCast(parameters.getCast()))
               : (HasCopyHandlerOnMultiple ? nullptr
               : &((const VirtualCast&) RetrieveMultipleRegistrationFromCopyCast()))),
               ExtendedInsertionParameters());
            guard.release();
         }
         else { // single -> unique
            AssumeCondition(newIdentification == IEUnique)
            ExtendedReplaceParameters sortedParams(parameters);
            sortedParams.setLocal().releaseFreeOnError().releaseDuplicate().setFree();
            scSortedCollection.replace((UniqueElement*) guard.handleDuplication(parameters.hasCast()
               ? &((const VirtualCast&) RetrieveSingleAssistedRegistrationFromCopyCast(parameters.getCast()))
               : (HasCopyHandlerOnSorted ? nullptr
               : &((const VirtualCast&) RetrieveUniqueRegistrationFromCopyCast()))),
               sortedParams, sortedCursor);
            guard.release();
         }
      }
      catch (...) {
         scSortedCollection.remove(ExtendedSuppressParameters(parameters).setFree(), sortedCursor);
         throw;
      };
   }
   else {
      AssumeCondition((sortedIdentification == IEUnique)
         && UniqueDynamicBaseCast::castFrom(UniqueBaseCast::castTo((const UniqueElement*) node)))
      if (newIdentification == IEMultiple) { // unique -> multiple
         ExtendedReplaceParameters sortedParams(parameters);
         sortedParams.setLocal().setFreeOnError().releaseDuplicate();
         ReceiverMultipleElement* receiver = nullptr;
         scSortedCollection.replace(receiver = new ReceiverMultipleElement(
            scSortedCollection.queryKey((const ExtendedSuppressParameters&) parameters, sortedCursor)),
            sortedParams, sortedCursor);
         receiver->add((MultipleElement*) guard.handleDuplication(parameters.hasCast()
            ? &((const VirtualCast&) RetrieveMultipleAssistedRegistrationFromCopyCast(parameters.getCast()))
            : (HasCopyHandlerOnMultiple ? nullptr :
            &((const VirtualCast&) RetrieveMultipleRegistrationFromCopyCast()))),
            ExtendedInsertionParameters());
         guard.release();
      }
      else if (newIdentification == IESingle) { // unique -> single
         ExtendedReplaceParameters sortedParams(parameters);
         sortedParams.setLocal().setFreeOnError().releaseDuplicate();
         ReceiverSingleElement* receiver = nullptr;
         scSortedCollection.replace(receiver = new ReceiverSingleElement(
            scSortedCollection.queryKey((const ExtendedSuppressParameters&) parameters, sortedCursor)),
            sortedParams, sortedCursor);
         receiver->absorbElement((SingleElement*) guard.handleDuplication(parameters.hasCast()
            ? &((const VirtualCast&) RetrieveSingleAssistedRegistrationFromCopyCast(parameters.getCast()))
            : (HasCopyHandlerOnSingle ? nullptr
            : &((const VirtualCast&) RetrieveSingleRegistrationFromCopyCast()))));
         guard.release();
      }
      else { // unique -> unique
         AssumeCondition(newIdentification == IEUnique)
         ExtendedReplaceParameters sortedParams(parameters);
         sortedParams.setLocal().releaseFreeOnError().releaseDuplicate();
         scSortedCollection.replace((UniqueElement*) guard.handleDuplication(parameters.hasCast()
            ? &((const VirtualCast&) RetrieveUniqueAssistedRegistrationFromCopyCast(parameters.getCast()))
            : (HasCopyHandlerOnSorted ? nullptr
            : &((const VirtualCast&) RetrieveUniqueRegistrationFromCopyCast()))),
            sortedParams, sortedCursor);
         guard.release();
      };
   };
}

template <class TypeTraits>
typename TMultipleSortedCollection<TypeTraits>::CommonElement*
TMultipleSortedCollection<TypeTraits>::_getElement(
   const ExtendedLocateParameters& parameters, const Cursor* cursor) const {
   inherited::_getElement(parameters, cursor);
   
   typename SortedCollection::Node* node = nullptr;
   if (cursor && cursor->isValid()) {
      node = &cursor->sortedCursor().elementSAt();
      if (cursor->multipleCursor().isValid()) {
         ReceiverMultipleElement* snode = (ReceiverMultipleElement*) node;
         if (!parameters.isNear() || !cursor->multipleCursor()->isPositionned(
               ExtendedLocateParameters(inverse(parameters.getRelativePosition()))))
            return MultipleBaseCast::castTo(
               &snode->getElement(parameters, cursor->multipleCursor().key()));
      };
   };

   node = &scSortedCollection.getElement(parameters,
      (cursor && cursor->isValid()) ? &cursor->sortedCursor() : nullptr);
   IdentificationElement identification = TypeTraits::identifyElementFromSorted(*node);
   if (identification == IEReceiverMultiple)
      return MultipleBaseCast::castTo(&((ReceiverMultipleElement*) node)->getElement(
            ExtendedLocateParameters(inverse(parameters.getRelativePosition())), nullptr));
   else if (identification == IEReceiverSingle)
      return SingleBaseCast::castTo(&((ReceiverSingleElement*) node)->getElement());
   else
      return UniqueBaseCast::castTo((UniqueElement*) node);
}

template <class TypeTraits>
typename TypeTraits::KeyTraits::ControlKeyType
TMultipleSortedCollection<TypeTraits>::_queryKey(
      const ExtendedLocateParameters& parameters,
      const typename TMultipleSortedCollection<TypeTraits>::Cursor* cursor) const {
   if (cursor && cursor->isValid()) {
      if (cursor->multipleCursor().isValid()) {
         if (!parameters.isNear() || !cursor->multipleCursor()->isPositionned(
               ExtendedLocateParameters(inverse(parameters.getRelativePosition()))))
            return cursor->sortedCursor().queryKey();
      };
   };

   return scSortedCollection.queryKey(parameters,
      (cursor && cursor->isValid()) ? &cursor->sortedCursor() : nullptr);
}

template <class TypeTraits>
typename TMultipleSortedCollection<TypeTraits>::LocationResult
TMultipleSortedCollection<TypeTraits>::_locate(const EnhancedObject& source, const ExtendedLocateParameters& parameters,
      VirtualMultiSortedCollectionCursor* pvsccCursor, const VirtualMultiSortedCollectionCursor* pvsccStart,
      const VirtualMultiSortedCollectionCursor* pvsccEnd) const {
   Cursor* cursor = (Cursor*) pvsccCursor;
   const Cursor *start = (const Cursor*) pvsccStart, *end = (const Cursor*) pvsccEnd;
   const CommonElement& element = BaseCast::castFrom(source);

   IdentificationElement identification = TypeTraits::identifyElementFromCommon(element);
   if (parameters.hasNoKey() || (identification == IEUnique)) {
      AssumeCondition(!parameters.hasNoKey() || (identification == IEUnique))
      return _locate(UniqueBaseCast::castFrom(element), parameters, cursor, start, end);
   }
   else if (parameters.hasKey())
      return _locateKey(TypeTraits::queryKey(parameters), parameters, cursor, start, end);

   AssumeCondition(parameters.containsKey())
   if (identification == IESingle)
      return _locateKey(key(SingleBaseCast::castFrom(element)), parameters, cursor, start, end);
   else {
      AssumeCondition(identification == IEMultiple)
      return _locateKey(key(MultipleBaseCast::castFrom(element)), parameters, cursor, start, end);
   };
}

template <class TypeTraits>
typename TMultipleSortedCollection<TypeTraits>::LocationResult
TMultipleSortedCollection<TypeTraits>::_locate(const UniqueElement& element, const ExtendedLocateParameters& parameters,
      Cursor* cursor, const Cursor* start, const Cursor* end) const {
   KeyLocationResult result;
   PPCursor garbage;
   if (!cursor) {
      garbage = newCursor();
      cursor = garbage.key();
   };
   ((VirtualSortedCollection::LocationResult&) result) = scSortedCollection.locate(element,
      parameters, &cursor->sortedCursor(),
      start ? &start->sortedCursor() : nullptr, end ? &end->sortedCursor() : nullptr).asSortedLocation();
   if (cursor->multipleCursor().isValid())
      cursor->multipleCursor().release();
   if (result)
      result.setCount(1);
   if (cursor->sortedCursor().isOnLocation()) {
      const typename SortedCollection::Node& node = cursor->sortedCursor().elementAt();
      IdentificationElement identification = TypeTraits::identifyElementFromSorted(node);
      if (identification == IEReceiverMultiple) {
         const ReceiverMultipleElement& snode = (const ReceiverMultipleElement&) node;
         cursor->multipleCursor() = snode.newCursor();
         cursor->multipleCursor()->position(parameters.isBefore() ? VirtualCollectionCursor::Position::DEnd
            : VirtualCollectionCursor::Position::DStart);
         if (result) {
            result.setCount(snode.count());
            if (parameters.isBefore())
               result.setCursorPosition(snode.count()-1);
         };
      };
   };
   return result;
}

template <class TypeTraits>
typename TMultipleSortedCollection<TypeTraits>::LocationResult
TMultipleSortedCollection<TypeTraits>::_locateKey(typename Key::KeyType key, const ExtendedLocateParameters& parameters,
      Cursor* cursor, const Cursor* start, const Cursor* end) const {
   KeyLocationResult result;
   PPCursor garbage;
   if (!cursor) {
      garbage = newCursor();
      cursor = garbage.key();
   };
   ((VirtualSortedCollection::LocationResult&) result) = scSortedCollection.locateKey(key,
      parameters, &cursor->sortedCursor(),
      start ? &start->sortedCursor() : nullptr, end ? &end->sortedCursor() : nullptr).asSortedLocation();
   if (cursor->multipleCursor().isValid())
      cursor->multipleCursor().release();
   if (result)
      result.setCount(1);
   if (cursor->sortedCursor().isOnLocation()) {
      const typename SortedCollection::Node& node = cursor->sortedCursor().elementAt();
      IdentificationElement identification = TypeTraits::identifyElementFromSorted(node);
      if (identification == IEReceiverMultiple) {
         const ReceiverMultipleElement& snode = (const ReceiverMultipleElement&) node;
         cursor->multipleCursor() = snode.newCursor();
         cursor->multipleCursor()->position(parameters.isBefore() ? VirtualCollectionCursor::Position::DEnd
            : VirtualCollectionCursor::Position::DStart);
         if (result) {
            result.setCount(snode.count());
            if (parameters.isBefore())
               result.setCursorPosition(snode.count()-1);
         };
      };
   };
   return result;
}

/************************************************************************/
/* Implementation of the template class TMultipleSortedCollectionCursor */
/************************************************************************/

template <class TypeTraits>
void
TMultipleSortedCollectionCursor<TypeTraits>::_gotoReference(const EnhancedObject& eoElement) {
   const CommonElement& element = BaseCast::castFrom(eoElement);
   IdentificationElement identification = TypeTraits::identifyElementFromCommon(element);
   if (identification == IEMultiple) {
      sccCursor.gotoReference(TypeTraits::getMultipleBase((const MultipleElement&) element));
      const typename SortedCollection::Node* node = &sccCursor.elementAt();
      AssumeCondition(dynamic_cast<const ReceiverMultipleElement*>(node))
      ppmccMultipleCursor = ((const ReceiverMultipleElement&) *node).newCursor();
      ppmccMultipleCursor->gotoReference(MultipleBaseCast::castFrom(element));
   }
   else {
      if (ppmccMultipleCursor.isValid())
         ppmccMultipleCursor.release();
      if (identification == IESingle)
         sccCursor.gotoReference(TypeTraits::getSingleBase((const SingleElement&) SingleBaseCast::castFrom(element)));
      else {
         AssumeCondition(identification == IEUnique)
         sccCursor.gotoReference((const UniqueElement&) UniqueBaseCast::castFrom(element));
      };
   };
}

template <class TypeTraits>
bool
TMultipleSortedCollectionCursor<TypeTraits>::_isPositionned(const ExtendedLocateParameters& pos,
      const VirtualCollectionCursor* pvccCursor) const {
   const thisType* cursor = (const thisType*) pvccCursor;
   if (cursor && cursor->isValid()) {
      if (ppmccMultipleCursor.isValid()) {
         if (cursor->ppmccMultipleCursor.isValid()) // Les deux curseurs sont multiples
            return (sccCursor.isEqual(cursor->sccCursor))
                ? ppmccMultipleCursor->isPositionned(pos, cursor->ppmccMultipleCursor.key())
                : (sccCursor.isPositionned(pos, &cursor->sccCursor)
                  && ppmccMultipleCursor->isPositionned(pos)
                  && cursor->ppmccMultipleCursor->isPositionned(
                     ExtendedLocateParameters(inverse(pos.getRelativePosition()))));
         else // multiple this and unique source
            return sccCursor.isPositionned(pos, &cursor->sccCursor)
                  && ppmccMultipleCursor->isPositionned(pos);
      }
      else if (cursor->ppmccMultipleCursor.isValid()) // unique this and multiple source
         return sccCursor.isPositionned(pos, &cursor->sccCursor)
               && cursor->ppmccMultipleCursor->isPositionned(
                  ExtendedLocateParameters(inverse(pos.getRelativePosition())));
      else // unique this and source
         return sccCursor.isPositionned(pos, &cursor->sccCursor);
   }
   else {
      if (sccCursor.isPositionned(pos))
         return (ppmccMultipleCursor.isValid()) ? ppmccMultipleCursor->isPositionned(pos) : true;
   };
   return false;
}

template <class TypeTraits>
bool
TMultipleSortedCollectionCursor<TypeTraits>::_position(const inherited::Position& pos) {
   typedef inherited::Position Position;
   inherited::_position(pos);
   bool result = false;
   if (pos.isNear()) {
      normalize();
      if (ppmccMultipleCursor.isValid()) {
         if (!(result = ppmccMultipleCursor->position(pos))) {
            if (((result = sccCursor.position(pos)) != false)
                  && (TypeTraits::identifyElementFromSorted(sccCursor.elementAt()) == TypeTraits::IEReceiverMultiple)) {
               ppmccMultipleCursor = ((const ReceiverMultipleElement&) sccCursor.elementAt()).newCursor();
               result = ppmccMultipleCursor->position(Position(pos.isForward() ? Position::DStart : Position::DEnd));
            }
            else
               ppmccMultipleCursor.release();
         };
      }
      else {
         if (((result = sccCursor.position(pos)) != false)
               && (TypeTraits::identifyElementFromSorted(sccCursor.elementAt()) == TypeTraits::IEReceiverMultiple)) {
            ppmccMultipleCursor = ((const ReceiverMultipleElement&) sccCursor.elementAt()).newCursor();
            result = ppmccMultipleCursor->position(Position(pos.isForward() ? Position::DStart : Position::DEnd));
         };
      };
   }
   else if (pos.isExact()) {
      normalize();
      return isValid();
   }
   else { // pos.isExtremity() || pos.isAny() || pos.isInvalid()
      result = sccCursor.position(pos);
      if (sccCursor.isValid()
            && (TypeTraits::identifyElementFromSorted(sccCursor.elementAt()) == TypeTraits::IEReceiverMultiple)) {
         ppmccMultipleCursor = ((const ReceiverMultipleElement&) sccCursor.elementAt()).newCursor();
         result = ppmccMultipleCursor->position(pos);
      };
   };
   return result;
}

} // end of namespace COL

#endif // COL_MultiSortedTEMPLATE

