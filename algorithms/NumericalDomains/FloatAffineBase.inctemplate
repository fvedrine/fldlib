/**************************************************************************/
/*                                                                        */
/*  This file is part of FLDLib                                           */
/*                                                                        */
/*  Copyright (C) 2011-2017                                               */
/*    CEA (Commissariat a l'Energie Atomique et aux Energies              */
/*         Alternatives)                                                  */
/*                                                                        */
/*  you can redistribute it and/or modify it under the terms of the GNU   */
/*  Lesser General Public License as published by the Free Software       */
/*  Foundation, version 2.1.                                              */
/*                                                                        */
/*  It is distributed in the hope that it will be useful,                 */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of        */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
/*  GNU Lesser General Public License for more details.                   */
/*                                                                        */
/*  See the GNU Lesser General Public License version 2.1                 */
/*  for more details (enclosed in the file LICENSE).                      */
/*                                                                        */
/**************************************************************************/

/////////////////////////////////
//
// Library   : NumericalDomains
// Unit      : Affine relationships
// File      : FloatAffineBase.template
// Description :
//   Implementation of a class of affine relations.
//

#ifndef DefineGeneric

#define DefineEquationTemplateHeader(RealBitsNumber)                 \
   template <int RealBitsNumber, class TypeBaseFloatAffine>
#define DefineEquationTemplateParameters(RealBitsNumber)             \
   <RealBitsNumber, TypeBaseFloatAffine>
#define DefineSizeofBaseTypeInBits                                   \
   (sizeof(unsigned int)*8)
#define DefineDefinedSymbol TDefinedSymbol
#define DefineBuiltDouble TBuiltDouble
#define DefineBuiltDoubleTraits BuiltDoubleTraits
#define DefineRealMantissaExponentTemplateParameters(RealBitsNumber, SizeMantissa, SizeExponent) \
   <RealBitsNumber, SizeMantissa, SizeExponent>
#define DefineSetContent setContent
#define DefineFillContent fillContent
#define DefineBasicFloatZonotopeTemplateHeader(RealBitsNumber, SizeMantissa, SizeExponent) \
   template <int RealBitsNumber, class TypeBaseFloatAffine, int SizeMantissa, int SizeExponent, typename TypeImplementation>
#define DefineBaseFloatZonotope TBaseFloatZonotope
#define DefineBasicFloatZonotope TBasicFloatZonotope
#define DefineBasicFloatZonotopeTemplateParameters(RealBitsNumber, SizeMantissa, SizeExponent) \
   <RealBitsNumber, TypeBaseFloatAffine, SizeMantissa, SizeExponent, TypeImplementation>
#define DefineTaylorDouble TTaylorDouble

#else

#define DefineEquationTemplateHeader(RealBitsNumber)                 \
   template <class BaseStoreTraits, int RealBitsNumber, class TypeBaseFloatAffine>
#define DefineEquationTemplateParameters(RealBitsNumber)             \
   <BaseStoreTraits, RealBitsNumber, TypeBaseFloatAffine>
#define DefineSizeofBaseTypeInBits                                   \
   BaseStoreTraits::sizeBaseInBits()
#define DefineDefinedSymbol TGDefinedSymbol
#define DefineBuiltDouble TGBuiltDouble
#define DefineBuiltDoubleTraits GBuiltDoubleTraits
#define DefineRealMantissaExponentTemplateParameters(RealBitsNumber, SizeMantissa, SizeExponent) \
   <BaseStoreTraits, RealBitsNumber, SizeMantissa, SizeExponent>
#define DefineSetContent gsetContent
#define DefineFillContent gfillContent
#define DefineBasicFloatZonotopeTemplateHeader(RealBitsNumber, SizeMantissa, SizeExponent) \
   template <class BaseStoreTraits, int RealBitsNumber, class TypeBaseFloatAffine, int SizeMantissa, int SizeExponent, typename TypeImplementation>
#define DefineBaseFloatZonotope TGBaseFloatZonotope
#define DefineBasicFloatZonotope TGBasicFloatZonotope
#define DefineBasicFloatZonotopeTemplateParameters(RealBitsNumber, SizeMantissa, SizeExponent) \
   <BaseStoreTraits, RealBitsNumber, TypeBaseFloatAffine, SizeMantissa, SizeExponent, TypeImplementation>
#define DefineTaylorDouble TGTaylorDouble

#endif

namespace DAffine {

/***************************************************************************/
/* Implementation of the classe TBaseFloatZonotope and TGBaseFloatZonotope */
/***************************************************************************/

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::optimizeUnstableForRealFlow(
      const thisType& source, bool isRealLess, bool& hasThisIntervalConstraint,
      bool& hasSourceIntervalConstraint, BuiltReal& newMin, BuiltReal& newMax,
      BuiltReal& newSourceMin, BuiltReal& newSourceMax) const {
   // constraint = eRealDomain - source.eRealDomain <= 0
   // constraintWithError = (eRealDomain + eError) - (source.eRealDomain + source.eError) >= 0

   auto& symbolsManager = thisType::symbolsManager();
   if (!source.hasTopReal()) {
      hasThisIntervalConstraint = true;
      BuiltReal temp;
      if (isRealLess) {
         // source.eRealDomain >= eRealDomain >= source.eRealDomain + (source.eError - eError)
         constraints().retrieveBound(source.eRealDomain, temp, newMax);
         Equation newMinEquation(source.eError);
         newMinEquation.minusAssign(eError, Equation::PCSourceRValue, symbolsManager);
         newMinEquation.plusAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMinEquation, newMin, temp);
      }
      else {
         // source.eRealDomain <= eRealDomain <= source.eRealDomain + (source.eError - eError)
         constraints().retrieveBound(source.eRealDomain, newMin, temp);
         Equation newMaxEquation(source.eError);
         newMaxEquation.minusAssign(eError, Equation::PCSourceRValue, symbolsManager);
         newMaxEquation.plusAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMaxEquation, temp, newMax);
      };
   };

   if (!hasTopReal()) {
      hasSourceIntervalConstraint = true;
      BuiltReal temp;
      if (isRealLess) {
         // eRealDomain <= source.eRealDomain <= eRealDomain + (eError - source.eError)
         constraints().retrieveBound(eRealDomain, newSourceMin, temp);
         Equation newMaxEquation(eError);
         newMaxEquation.minusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
         newMaxEquation.plusAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMaxEquation, temp, newSourceMax);
      }
      else {
         // eRealDomain >= source.eRealDomain >= eRealDomain + (eError - source.eError)
         constraints().retrieveBound(eRealDomain, temp, newSourceMax);
         Equation newMinEquation(eError);
         newMinEquation.minusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
         newMinEquation.plusAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMinEquation, newSourceMin, temp);
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::optimizeUnstableForRealFlowWithInterval(
      const thisType& source, bool hasThisIntervalConstraint,
      bool hasSourceIntervalConstraint, const BuiltReal& newMin, const BuiltReal& newMax,
      const BuiltReal& newSourceMin, const BuiltReal& newSourceMax) const {
   auto& symbolsManager = thisType::symbolsManager();
   if (hasThisIntervalConstraint) {
      if (hasTopReal())
         const_cast<thisType*>(this)->eRealDomain.setInterval(newMin, newMax, symbolsManager);
      else {
         BuiltReal min, max;
         constraints().retrieveBound(eRealDomain, min, max);
         if (min <= newMin && newMax <= max) {
            BuiltReal diff(newMax);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            diff.minusAssign(newMin, nearestParams);
            nearestParams.clear();
            max.minusAssign(min, nearestParams);
            nearestParams.clear();
            diff.multAssign(10U, nearestParams);
            nearestParams.clear();
            max.multAssign(9U, nearestParams);
            nearestParams.clear();
            if (diff < max)
               const_cast<thisType*>(this)->eRealDomain.setInterval(newMin, newMax, symbolsManager);
         };
      };
   };
   if (hasSourceIntervalConstraint) {
      if (source.hasTopReal())
         const_cast<thisType&>(source).eRealDomain.setInterval(newSourceMin, newSourceMax, symbolsManager);
      else {
         BuiltReal min, max;
         constraints().retrieveBound(source.eRealDomain, min, max);
         if (min <= newSourceMin && newSourceMax <= max) {
            BuiltReal diff(newSourceMax);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            diff.minusAssign(newSourceMin, nearestParams);
            nearestParams.clear();
            max.minusAssign(min, nearestParams);
            nearestParams.clear();
            diff.multAssign(10U, nearestParams);
            nearestParams.clear();
            max.multAssign(9U, nearestParams);
            nearestParams.clear();
            if (diff < max)
               const_cast<thisType&>(source).eRealDomain.setInterval(newSourceMin, newSourceMax, symbolsManager);
         };
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::optimizeUnstableForImplementationFlow(
      const thisType& source, bool isImplementationLess, bool& hasThisIntervalConstraint,
      bool& hasSourceIntervalConstraint, BuiltReal& newMinError, BuiltReal& newMaxError,
      BuiltReal& newSourceMinError, BuiltReal& newSourceMaxError) const {
   // constraint = eRealDomain - source.eRealDomain >= 0
   // constraintWithError = (eRealDomain + eError) - (source.eRealDomain + source.eError) <= 0

   auto& symbolsManager = thisType::symbolsManager();
   if (!source.hasTopError() && !hasTopError()) {
      hasThisIntervalConstraint = true;
      BuiltReal temp;
      if (isImplementationLess) {
         // source.eRealDomain + source.eError >= eRealDomain + eError >= source.eRealDomain + eError
         Equation newMaxEquation(source.eRealDomain);
         newMaxEquation.plusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMaxEquation, temp, newMaxError);
         Equation newMinEquation(source.eRealDomain);
         newMinEquation.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMinEquation, newMinError, temp);
      }
      else {
         // source.eRealDomain + source.eError <= eRealDomain + eError <= source.eRealDomain + eError
         Equation newMinEquation(source.eRealDomain);
         newMinEquation.plusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMinEquation, newMinError, temp);
         Equation newMaxEquation(source.eRealDomain);
         newMaxEquation.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMaxEquation, temp, newMaxError);
      };
   };

   if (!hasTopReal()) {
      hasSourceIntervalConstraint = true;
      BuiltReal temp;
      if (isImplementationLess) {
         // eRealDomain + eError <= source.eRealDomain + source.eError <= eRealDomain + source.eError
         Equation newMinEquation(eRealDomain);
         newMinEquation.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(eRealDomain, newSourceMinError, temp);
         Equation newMaxEquation(eRealDomain);
         newMaxEquation.plusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMaxEquation, temp, newSourceMaxError);
      }
      else {
         // eRealDomain + eError >= source.eRealDomain + source.eError >= eRealDomain + source.eError
         Equation newMaxEquation(eRealDomain);
         newMaxEquation.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(eRealDomain, temp, newSourceMaxError);
         Equation newMinEquation(eRealDomain);
         newMinEquation.plusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
         constraints().retrieveBound(newMinEquation, newSourceMinError, temp);
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::optimizeUnstableForImplementationFlowWithInterval(
      const thisType& source, bool hasThisIntervalConstraint,
      bool hasSourceIntervalConstraint, const BuiltReal& newMinError, const BuiltReal& newMaxError,
      const BuiltReal& newSourceMinError, const BuiltReal& newSourceMaxError) const {
   auto& symbolsManager = thisType::symbolsManager();
   if (hasThisIntervalConstraint) {
      if (hasTopError())
         const_cast<thisType*>(this)->eError.setInterval(newMinError, newMaxError, symbolsManager);
      else {
         BuiltReal min, max;
         constraints().retrieveBound(eError, min, max);
         if (min <= newMinError && newMaxError <= max) {
            BuiltReal diff(newMaxError);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            diff.minusAssign(newMinError, nearestParams);
            nearestParams.clear();
            max.minusAssign(min, nearestParams);
            nearestParams.clear();
            diff.multAssign(10U, nearestParams);
            nearestParams.clear();
            max.multAssign(9U, nearestParams);
            nearestParams.clear();
            if (diff < max)
               const_cast<thisType*>(this)->eError.setInterval(newMinError, newMaxError, symbolsManager);
         };
      };
   };
   if (hasSourceIntervalConstraint) {
      if (source.hasTopError())
         const_cast<thisType&>(source).eError.setInterval(newSourceMinError, newSourceMaxError, symbolsManager);
      else {
         BuiltReal min, max;
         constraints().retrieveBound(source.eError, min, max);
         if (min <= newSourceMinError && newSourceMaxError <= max) {
            BuiltReal diff(newSourceMaxError);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            diff.minusAssign(newSourceMinError, nearestParams);
            nearestParams.clear();
            max.minusAssign(min, nearestParams);
            nearestParams.clear();
            diff.multAssign(10U, nearestParams);
            nearestParams.clear();
            max.multAssign(9U, nearestParams);
            nearestParams.clear();
            if (diff < max)
               const_cast<thisType&>(source).eError.setInterval(newSourceMinError, newSourceMaxError, symbolsManager);
         };
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::isLessThan(
      const thisType& source, bool& hasMultiple, bool executionResult,
      bool doesAssumeErrorValue, bool errorValue) const {
   typename TypeBaseFloatAffine::BooleanChoice
      realChoice = TypeBaseFloatAffine::BCTop,
      errorChoice = TypeBaseFloatAffine::BCTop;
   BuiltReal min, max;
   EquationHolder constraint(eRealDomain);
   auto& symbolsManager = thisType::symbolsManager();
   bool hasReal = doesComputeReal() && source.doesComputeReal();
   if (hasReal) {
      constraint.minusAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraint, min, max);
   }
   else {
      realChoice = (hasNoReal() || source.hasNoReal())
         ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      if (doesComputeReal())
         const_cast<thisType*>(this)->mergeComputeReal(source);
   };

   BuiltReal minWithError, maxWithError;
   EquationHolder constraintWithError;
   if (doesComputeError() && source.doesComputeError()) {
      if (hasReal)
         constraintWithError = constraint;
      else if (source.doesComputeReal()) {
         constraintWithError = source.eRealDomain;
         constraintWithError.oppositeAssign();
      };
      constraintWithError.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
      constraintWithError.minusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraintWithError, minWithError, maxWithError);
      if (doesAssumeErrorValue)
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
   }
   else {
      if (!doesAssumeErrorValue)
         errorChoice = (hasNoError() || source.hasNoError())
            ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      else
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
      if (doesComputeError())
         const_cast<thisType*>(this)->mergeComputeError(source);
   };

   hasMultiple = false;
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && !max.isZero() && max.isNegative()) {
      realChoice = TypeBaseFloatAffine::BCTrue;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return true;
         if (!hasTopError()) {
            if (!maxWithError.isZero() && maxWithError.isNegative())
               return true;
            if (minWithError.isZero() || minWithError.isPositive()
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               errorChoice = TypeBaseFloatAffine::BCFalse;
         };
      }
      else if (errorChoice == TypeBaseFloatAffine::BCTrue)
         return true;
   };
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && (min.isZero() || min.isPositive() || (min.isNaN() && max.isNaN()))) {
      realChoice = TypeBaseFloatAffine::BCFalse;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return false;
         if (!hasTopError()) {
            if (minWithError.isZero() || minWithError.isPositive()
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               return false;
            if (!maxWithError.isZero() && maxWithError.isNegative())
               errorChoice = TypeBaseFloatAffine::BCTrue;
         };
      }
      else if (errorChoice == TypeBaseFloatAffine::BCFalse)
         return false;
   }
   if (!doesAssumeErrorValue) {
      if (errorChoice != TypeBaseFloatAffine::BCNone) {
         if (realChoice == TypeBaseFloatAffine::BCNone) {
            if (!hasTopError()) {
               if (minWithError.isZero() || minWithError.isPositive()
                        || (minWithError.isNaN() && maxWithError.isNaN()))
                  return false;
               else if (!maxWithError.isZero() && maxWithError.isNegative())
                  return true;
            };
         }
         else if (realChoice == TypeBaseFloatAffine::BCTop) {
            if (!hasTopError()) {
               if (minWithError.isZero() || minWithError.isPositive()
                     || (minWithError.isNaN() && maxWithError.isNaN()))
                  errorChoice = TypeBaseFloatAffine::BCFalse;
               else if (!maxWithError.isZero() && maxWithError.isNegative())
                  errorChoice = TypeBaseFloatAffine::BCTrue;
            };
         };
      };
   }
   else if (realChoice == TypeBaseFloatAffine::BCNone)
      return errorValue;

   hasMultiple = true;
   bool doesRestrictFlow = (realChoice != TypeBaseFloatAffine::BCNone)
         && (errorChoice != TypeBaseFloatAffine::BCNone);
   int cases = TypeBaseFloatAffine::getCasesNumber(realChoice, errorChoice);
   TypeBaseFloatAffine::retrieveBranch(cases, realChoice, errorChoice, executionResult);
   if (doesRestrictFlow)
      doesRestrictFlow = (realChoice == TypeBaseFloatAffine::BCNone)
            || (errorChoice == TypeBaseFloatAffine::BCNone);
   bool doesTakeThen;
   if (realChoice == TypeBaseFloatAffine::BCTrue) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCTrue) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, true /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCTrue)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, !hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = true;
   }
   else if (realChoice == TypeBaseFloatAffine::BCFalse) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCFalse) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, false /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCFalse)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = false;
   }
   else if (errorChoice == TypeBaseFloatAffine::BCTrue) {
      AssumeCondition(realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, true /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, true,
                  symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, true);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, false /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = true;
   }
   else {
      AssumeCondition(errorChoice == TypeBaseFloatAffine::BCFalse
         && realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, false /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, false);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, true /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = false;
   }
   return doesTakeThen;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::isLessOrEqualThan(
      const thisType& source, bool& hasMultiple, bool executionResult,
      bool doesAssumeErrorValue, bool errorValue) const {
   typename TypeBaseFloatAffine::BooleanChoice
      realChoice = TypeBaseFloatAffine::BCTop,
      errorChoice = TypeBaseFloatAffine::BCTop;
   BuiltReal min, max;
   EquationHolder constraint(eRealDomain);
   auto& symbolsManager = thisType::symbolsManager();
   bool hasReal = doesComputeReal() && source.doesComputeReal();
   if (hasReal) {
      constraint.minusAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraint, min, max);
   }
   else {
      realChoice = (hasNoReal() || source.hasNoReal())
         ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      if (doesComputeReal())
         const_cast<thisType*>(this)->mergeComputeReal(source);
   };

   BuiltReal minWithError, maxWithError;
   EquationHolder constraintWithError;
   if (doesComputeError() && source.doesComputeError()) {
      if (hasReal)
         constraintWithError = constraint;
      else if (source.doesComputeReal()) {
         constraintWithError = source.eRealDomain;
         constraintWithError.oppositeAssign();
      };
      constraintWithError.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
      constraintWithError.minusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraintWithError, minWithError, maxWithError);
      if (doesAssumeErrorValue)
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
   }
   else {
      if (!doesAssumeErrorValue)
         errorChoice = (hasNoError() || source.hasNoError())
            ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      else
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
      if (doesComputeError())
         const_cast<thisType*>(this)->mergeComputeError(source);
   };

   hasMultiple = false;
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && (max.isZero() || max.isNegative())) {
      realChoice = TypeBaseFloatAffine::BCTrue;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return true;
         if (!hasTopError()) {
            if (maxWithError.isZero() || maxWithError.isNegative())
               return true;
            if ((!minWithError.isZero() && minWithError.isPositive())
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               errorChoice = TypeBaseFloatAffine::BCFalse;
         }
      }
      else if (errorChoice == TypeBaseFloatAffine::BCTrue)
         return true;
   };
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && ((!min.isZero() && min.isPositive()) || (min.isNaN() && max.isNaN()))) {
      realChoice = TypeBaseFloatAffine::BCFalse;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return false;
         if (!hasTopError()) {
            if ((!minWithError.isZero() && minWithError.isPositive())
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               return false;
            if (maxWithError.isZero() || maxWithError.isNegative())
               errorChoice = TypeBaseFloatAffine::BCTrue;
         };
      }
      else if (errorChoice == TypeBaseFloatAffine::BCFalse)
         return false;
   }
   if (!doesAssumeErrorValue) {
      if (errorChoice != TypeBaseFloatAffine::BCNone) {
         if (realChoice == TypeBaseFloatAffine::BCNone) {
            if (!hasTopError()) {
               if ((!minWithError.isZero() && minWithError.isPositive())
                     || (minWithError.isNaN() && maxWithError.isNaN()))
                  return false;
               else if (maxWithError.isZero() || maxWithError.isNegative())
                  return true;
            };
         }
         else if (realChoice == TypeBaseFloatAffine::BCTop) {
            if (!hasTopError()) {
               if ((!minWithError.isZero() && minWithError.isPositive())
                     || (minWithError.isNaN() && maxWithError.isNaN()))
                  errorChoice = TypeBaseFloatAffine::BCFalse;
               else if (maxWithError.isZero() || maxWithError.isNegative())
                  errorChoice = TypeBaseFloatAffine::BCTrue;
            };
         };
      };
   }
   else if (realChoice == TypeBaseFloatAffine::BCNone)
      return errorValue;

   hasMultiple = true;
   bool doesRestrictFlow = (realChoice != TypeBaseFloatAffine::BCNone)
         && (errorChoice != TypeBaseFloatAffine::BCNone);
   int cases = TypeBaseFloatAffine::getCasesNumber(realChoice, errorChoice);
   TypeBaseFloatAffine::retrieveBranch(cases, realChoice, errorChoice, executionResult);
   if (doesRestrictFlow)
      doesRestrictFlow = (realChoice == TypeBaseFloatAffine::BCNone)
            || (errorChoice == TypeBaseFloatAffine::BCNone);
   bool doesTakeThen;
   if (realChoice == TypeBaseFloatAffine::BCTrue) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCTrue) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, true /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCTrue)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, !hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = true;
   }
   else if (realChoice == TypeBaseFloatAffine::BCFalse) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCFalse) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, false /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCFalse)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = false;
   }
   else if (errorChoice == TypeBaseFloatAffine::BCTrue) {
      AssumeCondition(realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, true /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, true, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, true);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, false /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = true;
   }
   else {
      AssumeCondition(errorChoice == TypeBaseFloatAffine::BCFalse
         && realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, false /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, false);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, true /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = false;
   }
   return doesTakeThen;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::isGreaterOrEqualThan(
      const thisType& source, bool& hasMultiple, bool executionResult,
      bool doesAssumeErrorValue, bool errorValue) const {
   typename TypeBaseFloatAffine::BooleanChoice
      realChoice = TypeBaseFloatAffine::BCTop,
      errorChoice = TypeBaseFloatAffine::BCTop;
   BuiltReal min, max;
   EquationHolder constraint(eRealDomain);
   auto& symbolsManager = thisType::symbolsManager();
   bool hasReal = doesComputeReal() && source.doesComputeReal();
   if (hasReal) {
      constraint.minusAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraint, min, max);
   }
   else {
      realChoice = (hasNoReal() || source.hasNoReal())
         ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      if (doesComputeReal())
         const_cast<thisType*>(this)->mergeComputeReal(source);
   };

   BuiltReal minWithError, maxWithError;
   EquationHolder constraintWithError;
   if (doesComputeError() && source.doesComputeError()) {
      if (hasReal)
         constraintWithError = constraint;
      else if (source.doesComputeReal()) {
         constraintWithError = source.eRealDomain;
         constraintWithError.oppositeAssign();
      };
      constraintWithError.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
      constraintWithError.minusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraintWithError, minWithError, maxWithError);
      if (doesAssumeErrorValue)
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
   }
   else {
      if (!doesAssumeErrorValue)
         errorChoice = (hasNoError() || source.hasNoError())
            ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      else
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
      if (doesComputeError())
         const_cast<thisType*>(this)->mergeComputeError(source);
   };

   hasMultiple = false;
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && (min.isZero() || min.isPositive())) {
      realChoice = TypeBaseFloatAffine::BCTrue;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return true;
         if (!hasTopError()) {
            if (maxWithError.isZero() || maxWithError.isNegative())
               return true;
            if ((!minWithError.isZero() && minWithError.isPositive())
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               errorChoice = TypeBaseFloatAffine::BCFalse;
         };
      }
      else if (errorChoice == TypeBaseFloatAffine::BCTrue)
         return true;
   };
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && ((!max.isZero() && max.isNegative()) || (min.isNaN() && max.isNaN()))) {
      realChoice = TypeBaseFloatAffine::BCFalse;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return false;
         if (!hasTopError()) {
            if ((!maxWithError.isZero() && maxWithError.isNegative())
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               return false;
            if (minWithError.isZero() || minWithError.isPositive())
               errorChoice = TypeBaseFloatAffine::BCTrue;
         };
      }
      else if (errorChoice == TypeBaseFloatAffine::BCFalse)
         return false;
   }
   if (!doesAssumeErrorValue) {
      if (errorChoice != TypeBaseFloatAffine::BCNone) {
         if (realChoice == TypeBaseFloatAffine::BCNone) {
            if (!hasTopError()) {
               if ((!maxWithError.isZero() && maxWithError.isNegative())
                     || (minWithError.isNaN() && maxWithError.isNaN()))
                  return false;
               else if (minWithError.isZero() || minWithError.isPositive())
                  return true;
            };
         }
         else if (realChoice == TypeBaseFloatAffine::BCTop) {
            if (!hasTopError()) {
               if ((!maxWithError.isZero() && maxWithError.isNegative())
                     || (minWithError.isNaN() && maxWithError.isNaN()))
                  errorChoice = TypeBaseFloatAffine::BCFalse;
               else if (minWithError.isZero() || minWithError.isPositive())
                  errorChoice = TypeBaseFloatAffine::BCTrue;
            };
         };
      };
   }
   else if (realChoice == TypeBaseFloatAffine::BCNone)
      return errorValue;

   hasMultiple = true;
   bool doesRestrictFlow = (realChoice != TypeBaseFloatAffine::BCNone)
         && (errorChoice != TypeBaseFloatAffine::BCNone);
   int cases = TypeBaseFloatAffine::getCasesNumber(realChoice, errorChoice);
   TypeBaseFloatAffine::retrieveBranch(cases, realChoice, errorChoice, executionResult);
   if (doesRestrictFlow)
      doesRestrictFlow = (realChoice == TypeBaseFloatAffine::BCNone)
            || (errorChoice == TypeBaseFloatAffine::BCNone);
   bool doesTakeThen;
   if (realChoice == TypeBaseFloatAffine::BCTrue) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCTrue) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, false /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCTrue)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = true;
   }
   else if (realChoice == TypeBaseFloatAffine::BCFalse) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCFalse) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, true /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCFalse)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, !hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = false;
   }
   else if (errorChoice == TypeBaseFloatAffine::BCTrue) {
      AssumeCondition(realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, false /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, false);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, true /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = true;
   }
   else {
      AssumeCondition(errorChoice == TypeBaseFloatAffine::BCFalse
         && realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, true /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, true, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, true);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, false /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = false;
   }
   return doesTakeThen;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::isGreaterThan(
      const thisType& source, bool& hasMultiple, bool executionResult,
      bool doesAssumeErrorValue, bool errorValue) const {
   typename TypeBaseFloatAffine::BooleanChoice
      realChoice = TypeBaseFloatAffine::BCTop,
      errorChoice = TypeBaseFloatAffine::BCTop;
   BuiltReal min, max;
   EquationHolder constraint(eRealDomain);
   auto& symbolsManager = thisType::symbolsManager();
   bool hasReal = doesComputeReal() && source.doesComputeReal();
   if (hasReal) {
      constraint.minusAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraint, min, max);
   }
   else {
      realChoice = (hasNoReal() || source.hasNoReal())
         ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      if (doesComputeReal())
         const_cast<thisType*>(this)->mergeComputeReal(source);
   };

   BuiltReal minWithError, maxWithError;
   EquationHolder constraintWithError;
   if (doesComputeError() && source.doesComputeError()) {
      if (hasReal)
         constraintWithError = constraint;
      else if (source.doesComputeReal()) {
         constraintWithError = source.eRealDomain;
         constraintWithError.oppositeAssign();
      };
      constraintWithError.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
      constraintWithError.minusAssign(source.eError, Equation::PCSourceRValue, symbolsManager);
      constraints().retrieveBound(constraintWithError, minWithError, maxWithError);
      if (doesAssumeErrorValue)
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
   }
   else {
      if (!doesAssumeErrorValue)
         errorChoice = (hasNoError() || source.hasNoError())
            ? TypeBaseFloatAffine::BCNone : TypeBaseFloatAffine::BCTop;
      else
         errorChoice = errorValue ? TypeBaseFloatAffine::BCTrue : TypeBaseFloatAffine::BCFalse;
      if (doesComputeError())
         const_cast<thisType*>(this)->mergeComputeError(source);
   };

   hasMultiple = false;
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && (!min.isZero() && min.isPositive())) {
      realChoice = TypeBaseFloatAffine::BCTrue;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return true;
         if (!hasTopError()) {
            if (!minWithError.isZero() && minWithError.isPositive())
               return true;
            if (maxWithError.isZero() || maxWithError.isNegative()
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               errorChoice = TypeBaseFloatAffine::BCFalse;
         };
      }
      else if (errorChoice == TypeBaseFloatAffine::BCTrue)
         return true;
   };
   if (realChoice != TypeBaseFloatAffine::BCNone && !hasTopReal()
         && (max.isZero() || max.isNegative() || (min.isNaN() && max.isNaN()))) {
      realChoice = TypeBaseFloatAffine::BCFalse;
      if (!doesAssumeErrorValue) {
         if (errorChoice == TypeBaseFloatAffine::BCNone)
            return false;
         if (!hasTopError()) {
            if (maxWithError.isZero() || maxWithError.isNegative()
                  || (minWithError.isNaN() && maxWithError.isNaN()))
               return false;
            if (!minWithError.isZero() && minWithError.isPositive())
               errorChoice = TypeBaseFloatAffine::BCTrue;
         };
      }
      else if (errorChoice == TypeBaseFloatAffine::BCFalse)
         return false;
   }
   if (!doesAssumeErrorValue) {
      if (errorChoice != TypeBaseFloatAffine::BCNone) {
         if (realChoice == TypeBaseFloatAffine::BCNone) {
            if (!hasTopError()) {
               if (maxWithError.isZero() || maxWithError.isNegative()
                     || (minWithError.isNaN() && maxWithError.isNaN()))
                  return false;
               else if (!minWithError.isZero() && minWithError.isPositive())
                  return true;
            };
         }
         else if (realChoice == TypeBaseFloatAffine::BCTop) {
            if (!hasTopError()) {
               if (maxWithError.isZero() || maxWithError.isNegative()
                     || (minWithError.isNaN() && maxWithError.isNaN()))
                  errorChoice = TypeBaseFloatAffine::BCFalse;
               else if (!minWithError.isZero() && minWithError.isPositive())
                  errorChoice = TypeBaseFloatAffine::BCTrue;
            };
         };
      };
   }
   else if (realChoice == TypeBaseFloatAffine::BCNone)
      return errorValue;

   hasMultiple = true;
   bool doesRestrictFlow = (realChoice != TypeBaseFloatAffine::BCNone)
         && (errorChoice != TypeBaseFloatAffine::BCNone);
   int cases = TypeBaseFloatAffine::getCasesNumber(realChoice, errorChoice);
   TypeBaseFloatAffine::retrieveBranch(cases, realChoice, errorChoice, executionResult);
   if (doesRestrictFlow)
      doesRestrictFlow = (realChoice == TypeBaseFloatAffine::BCNone)
            || (errorChoice == TypeBaseFloatAffine::BCNone);
   bool doesTakeThen;
   if (realChoice == TypeBaseFloatAffine::BCTrue) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCTrue) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, false /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCTrue)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = true;
   }
   else if (realChoice == TypeBaseFloatAffine::BCFalse) {
      BuiltReal newMin, newMax, newSourceMin, newSourceMax;
      bool hasInverseErrorFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (errorChoice != TypeBaseFloatAffine::BCFalse) {
         if (doesComputeError() && source.doesComputeError()) {
            hasInverseErrorFlow = true;
            optimizeUnstableForRealFlow(source, true /* isRealLess */, hasThisIntervalConstraint,
                  hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
         };
         const_cast<thisType*>(this)->mergeNoError();
      };
      if (!hasTopReal()) {
         Symbol* constrainedSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
         if ((!hasTopError() && errorChoice == TypeBaseFloatAffine::BCFalse)
               || hasInverseErrorFlow) {
            Symbol* constrainedErrorSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraintWithError);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol,
                     !hasInverseErrorFlow, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraintWithError, !hasInverseErrorFlow);
         };
      };
      optimizeUnstableForRealFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMin, newMax, newSourceMin, newSourceMax);
      doesTakeThen = false;
   }
   else if (errorChoice == TypeBaseFloatAffine::BCTrue) {
      AssumeCondition(realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, false /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, false, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, false, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, false);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     true /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, true /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = true;
   }
   else {
      AssumeCondition(errorChoice == TypeBaseFloatAffine::BCFalse && realChoice == TypeBaseFloatAffine::BCNone)
      BuiltReal newMinError, newMaxError, newSourceMinError, newSourceMaxError;
      bool hasInverseRealFlow = false,
           hasThisIntervalConstraint = false, hasSourceIntervalConstraint = false;
      if (doesComputeReal() && source.doesComputeReal()) {
         hasInverseRealFlow = true;
         optimizeUnstableForImplementationFlow(source, true /* isImplementationLess */, hasThisIntervalConstraint,
               hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      };
      const_cast<thisType*>(this)->mergeNoReal();
      if (!hasTopError()) {
         Symbol* constrainedErrorSymbol = symbolsManager
               .createDefinedSymbol(TemplateTraits(), constraintWithError);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraintWithError.simplifyAllEquationsIf(*constrainedErrorSymbol, true, symbolsManager,
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintWithError.simplifyAllEquations(*constrainedErrorSymbol, true, symbolsManager);
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintWithError, true);
         if (hasInverseRealFlow) {
            Symbol* constrainedRealSymbol = symbolsManager
                  .createDefinedSymbol(TemplateTraits(), constraint);
            bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
               ? constraint.simplifyAllEquationsIf(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager, TypeBaseFloatAffine::getConditionSameBranch())
               : constraint.simplifyAllEquations(*constrainedRealSymbol,
                     false /* isNegative */, symbolsManager);
            if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
               constraints().pushConstraint().setFrom(constraint, false /* isNegative */);
         };
      };
      optimizeUnstableForImplementationFlowWithInterval(source, hasThisIntervalConstraint,
            hasSourceIntervalConstraint, newMinError, newMaxError, newSourceMinError, newSourceMaxError);
      doesTakeThen = false;
   }
   return doesTakeThen;
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)&
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::multAssign(
      const thisType& source, typename Equation::PolicyCall policyCall) {
   if (this == &source) {
      thisType sourceCopy(source);
      return multAssign(sourceCopy, Equation::PCSourceXValue);
   }
   updateLocalState();
   GuardStateZonotope sourceGuard(source, true /* isConstEquation*/, policyCall == Equation::PCSourceXValue);
   // const_cast<thisType&>(source).updateLocalState();
   bool hasReal = doesComputeReal() && source.doesComputeReal();
   bool hasInftyExponent = false;
   if (!hasReal)
      mergeComputeReal(source);
   if (doesComputeError() && source.doesComputeError()) {
      if (hasReal) {
         if (eRealDomain.getCentral().isInftyExponent() || source.eRealDomain.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eRealDomain, source.eRealDomain, &BuiltReal::multAssignDouble, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else if ((source.eRealDomain.getCentral().isZero() && source.eRealDomain.isEmpty()
                  && source.eError.getCentral().isZero() && source.eError.isEmpty())
               || (eRealDomain.getCentral().isZero() && eRealDomain.isEmpty()
                  && eError.getCentral().isZero() && eError.isEmpty()))
            eError.clear();
         else {
            Equation error(eError);
            error.multAssign(source.eError, Equation::PCSourceRValue,
                  symbolsManager(), TypeBaseFloatAffine::doesAbsorbHighLevel());
            eError.multAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager());
            eError.plusAssign(error, Equation::PCSourceXValue, symbolsManager());
            if (policyCall == Equation::PCSourceXValue)
               error.swap(const_cast<EquationHolder&>(source.eError));
            else
               error = source.eError;
            error.multAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager());
            eError.plusAssign(error, Equation::PCSourceXValue, symbolsManager());
         };
      }
      else if (source.doesComputeReal()) {
         Equation error(source.eRealDomain);
         error.plusAssign(source.eError, policyCall, symbolsManager());
         if (eError.getCentral().isInftyExponent() || error.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eError, error, &BuiltReal::multAssignDouble, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else
            eError.multAssign(error, Equation::PCSourceXValue, symbolsManager());
      }
      else {
         if (eError.getCentral().isInftyExponent() || source.eError.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eError, source.eError, &BuiltReal::multAssignDouble, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else if ((source.eError.getCentral().isZero() && source.eError.isEmpty())
               || (eError.getCentral().isZero() && eError.isEmpty())) {
            bool isNegative = eError.getCentral().isNegative();
            eError.clear();
            eError.getSCentral().setNegative(isNegative != source.eError.getCentral().isNegative());
         }
         else
            eError.multAssign(source.eError, policyCall, symbolsManager());
      };
   }
   else
      mergeComputeError(source);
   if (hasReal) {
      if (eRealDomain.getCentral().isInftyExponent() || source.eRealDomain.getCentral().isInftyExponent()) {
         if (!hasInftyExponent)
            performInftyNaNComputation(eRealDomain, source.eRealDomain, &BuiltReal::multAssignDouble, TypeBaseFloatAffine::nearestParams());
      }
      else if ((source.eRealDomain.getCentral().isZero() && source.eRealDomain.isEmpty())
            || (eRealDomain.getCentral().isZero() && eRealDomain.isEmpty())) {
         bool isNegative = eRealDomain.getCentral().isNegative();
         eRealDomain.clear();
         eRealDomain.getSCentral().setNegative(isNegative != source.eRealDomain.getCentral().isNegative());
      }
      else
         eRealDomain.multAssign(source.eRealDomain, policyCall, symbolsManager());
   };
   return *this;
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)&
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::divAssign(
      const thisType& source, typename Equation::PolicyCall policyCall) {
   if (this == &source) {
      thisType sourceCopy(source);
      return divAssign(sourceCopy, Equation::PCSourceXValue);
   }
   updateLocalState();
   GuardStateZonotope sourceGuard(source, true /* isConstEquation*/, policyCall == Equation::PCSourceXValue);
   // const_cast<thisType&>(source).updateLocalState();
   bool hasReal = doesComputeReal() && source.doesComputeReal();
   bool hasInftyExponent = false;
   if (!hasReal)
      mergeComputeReal(source);
   auto& symbolsManager = thisType::symbolsManager();
   if (doesComputeError() && source.doesComputeError()) {
      if (hasTopReal() || source.hasTopReal())
         mergeTopError();
      else if (hasReal) {
         if (eRealDomain.getCentral().isInftyExponent() || source.eRealDomain.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eRealDomain, source.eRealDomain, &BuiltReal::divAssignDouble, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else if (source.eRealDomain.getCentral().isZero() && source.eRealDomain.isEmpty()
               && source.eError.getCentral().isZero() && source.eError.isEmpty()) {
            Equation error(eRealDomain);
            error.plusAssign(eError, Equation::PCSourceRValue, symbolsManager);
            BuiltReal min, max;
            error.retrieveBound(min, max, false /* hasExternalCoefficient */);
            if (source.eRealDomain.getCentral().isNegative()
                  != source.eError.getCentral().isNegative())
               mergeTopError();
            else if (min.isPositive() || max.isNegative()) {
               if (min.isZero() && max.isZero() && min.isNegative() == max.isNegative())
                  eError.clear();
               else if (!min.isZero())
                  eError.clear();
               else if (!max.isZero())
                  eError.clear();
               else
                  mergeTopError();
            }
            else
               mergeTopError();
         }
         else {
            // (x+e)/(y+e') = x/y + (e*y-x*e')/y*(y+e')
            Equation error(source.eError);
            error.multAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager);
            eError.multAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager);
            eError.minusAssign(error, Equation::PCSourceXValue, symbolsManager);
            if (!eError.divAssign(source.eRealDomain, Equation::PCSourceRValue, symbolsManager))
               mergeTopError();
            else {
               Equation divide(source.eRealDomain);
               divide.plusAssign(source.eError, policyCall, symbolsManager);
               if (!eError.divAssign(divide, Equation::PCSourceXValue, symbolsManager))
                  mergeTopError();
            };
         };
      }
      else if (source.doesComputeReal()) {
         Equation error(source.eRealDomain);
         error.plusAssign(source.eError, policyCall, symbolsManager);
         if (eError.getCentral().isInftyExponent() || error.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eError, error, &BuiltReal::divAssignDouble, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else if (!eError.divAssign(error, Equation::PCSourceXValue, symbolsManager))
            mergeTopError();
      }
      else {
         if (eError.getCentral().isInftyExponent() || source.eError.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eError, source.eError, &BuiltReal::multAssignDouble, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else if (source.eError.getCentral().isZero() && source.eError.isEmpty()) {
            BuiltReal min, max;
            eError.retrieveBound(min, max, false /* hasExternalCoefficient */);
            if (min.isPositive() || max.isNegative()) {
               if (min.isZero() && max.isZero() && min.isNegative() == max.isNegative()) {
                  eError.clear();
                  eError.getSCentral().setSNaN();
               }
               else if (!min.isZero()) {
                  eError.clear();
                  if (source.eError.getCentral().isPositive())
                     eError.getSCentral().setPlusInfty();
                  else
                     eError.getSCentral().setMinusInfty();
               }
               else if (!max.isZero()) {
                  eError.clear();
                  if (source.eError.getCentral().isPositive())
                     eError.getSCentral().setMinusInfty();
                  else
                     eError.getSCentral().setPlusInfty();
               }
               else
                  mergeTopError();
            }
            else
               mergeTopError();
         }
         else if (!eError.divAssign(source.eError, policyCall, symbolsManager))
            mergeTopError();
      };
   }
   else
      mergeComputeError(source);
   if (hasReal) {
      if (eRealDomain.getCentral().isInftyExponent() || source.eRealDomain.getCentral().isInftyExponent()) {
         if (!hasInftyExponent)
            performInftyNaNComputation(eRealDomain, source.eRealDomain, &BuiltReal::divAssignDouble, TypeBaseFloatAffine::nearestParams());
      }
      else if (source.eRealDomain.getCentral().isZero() && source.eRealDomain.isEmpty()) {
         BuiltReal min, max;
         eRealDomain.retrieveBound(min, max, false /* hasExternalCoefficient */);
         if (min.isPositive() || max.isNegative()) {
            if (min.isZero() && max.isZero() && min.isNegative() == max.isNegative()) {
               eRealDomain.clear();
               eRealDomain.getSCentral().setSNaN();
               eRealDomain.getSCentral().setNegative(min.isNegative() != source.eRealDomain.getCentral().isNegative());
            }
            else if (!min.isZero()) {
               eRealDomain.clear();
               if (source.eRealDomain.getCentral().isPositive())
                  eRealDomain.getSCentral().setPlusInfty();
               else
                  eRealDomain.getSCentral().setMinusInfty();
            }
            else if (!max.isZero()) {
               eRealDomain.clear();
               if (source.eRealDomain.getCentral().isPositive())
                  eRealDomain.getSCentral().setMinusInfty();
               else
                  eRealDomain.getSCentral().setPlusInfty();
            }
            else
               mergeTopReal();
         }
         else
            mergeTopReal();
      }
      else if (!eRealDomain.divAssign(source.eRealDomain, policyCall, symbolsManager))
         mergeTopReal();
   };
   return *this;
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::inverseAssign() {
   updateLocalState();
   bool hasReal = doesComputeReal();
   auto& symbolsManager = thisType::symbolsManager();
   bool hasInftyExponent = false;
   if (doesComputeError()) {
      if (hasReal) {
         if (eRealDomain.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eRealDomain, &BuiltReal::inverseAssign, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else if (eRealDomain.getCentral().isZero() && eRealDomain.isEmpty()
               && eError.getCentral().isZero() && eError.isEmpty()) {
            if (eRealDomain.getCentral().isNegative()
                  != eError.getCentral().isNegative())
               mergeTopError();
            else
               eError.clear();
         }
         else {
            // 1/(x+e) = 1/x - e/x*(x+e)
            eError.oppositeAssign();
            Equation divide(eRealDomain);
            divide.minusAssign(eError, Equation::PCSourceRValue, symbolsManager);
            if (!eError.divAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager))
               mergeTopError();
            else if (!eError.divAssign(divide, Equation::PCSourceXValue, symbolsManager))
               mergeTopError();
         };
      }
      else if (hasNoReal()) {
         if (eError.getCentral().isInftyExponent()) {
            performInftyNaNComputation(eError, &BuiltReal::inverseAssign, TypeBaseFloatAffine::nearestParams());
            hasInftyExponent = true;
         }
         else if (eError.getCentral().isZero() && eError.isEmpty()) {
            eError.clear();
            if (eError.getCentral().isPositive())
               eError.getSCentral().setPlusInfty();
            else
               eError.getSCentral().setMinusInfty();
         }
         else if (!eError.inverseAssign(symbolsManager))
            mergeTopError();
      }
      else
         mergeTopError();
   };
   if (hasReal) {
      if (eRealDomain.getCentral().isInftyExponent()) {
         if (!hasInftyExponent)
            performInftyNaNComputation(eRealDomain, &BuiltReal::inverseAssign, TypeBaseFloatAffine::nearestParams());
      }
      else if (eRealDomain.getCentral().isZero() && eRealDomain.isEmpty()) {
         eRealDomain.clear();
         if (eRealDomain.getCentral().isPositive())
            eRealDomain.getSCentral().setPlusInfty();
         else
            eRealDomain.getSCentral().setMinusInfty();
      }
      else if (!eRealDomain.inverseAssign(symbolsManager))
         mergeTopReal();
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::sqrtAssign() {
   updateLocalState();
   bool hasReal = false;
   bool hasError = false;
   if ((hasError = doesComputeError()) != false) {
      if ((hasReal = doesComputeReal()) == false) {
         if (eError.getCentral().isInftyExponent())
            performInftyNaNComputationWithError(eError, &BuiltReal::sqrtAssign, TypeBaseFloatAffine::nearestParams());
         else
            eError.sqrtAssign(symbolsManager());
      };
   }
   if (hasReal || doesComputeReal()) {
      if (eRealDomain.getCentral().isInftyExponent()) {
         performInftyNaNComputationWithError(eRealDomain, &BuiltReal::sqrtAssign, TypeBaseFloatAffine::nearestParams());
         if (hasError) {
            if (!eError.getCentral().isZero() || !eError.isEmpty())
               mergeTopError();
         };
         return;
      };

      BuiltReal sqrtMin, sqrtMax;
      if (hasError) {
         auto& minParams = TypeBaseFloatAffine::minParams();
         sqrtMin = eRealDomain.getSCentral();
         sqrtMin.plusAssign(eError.getSCentral(), minParams);
         minParams.clear();
         sqrtMax = sqrtMin;
         {  typename Equation::Cursor cursor(eRealDomain), errorCursor(eError);
            bool wasOnSymbol = true;
            if (cursor.setToFirst()) {
               auto& maxParams = TypeBaseFloatAffine::maxParams();
               do {
                  const Symbol& symbol = cursor.elementAt();
                  if (wasOnSymbol)
                     errorCursor.setToNext();
                  ComparisonResult compareSymbol = errorCursor.isValid()
                     ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  while (compareSymbol == CRLess) {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        sqrtMin.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                        sqrtMax.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        sqrtMin.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                        sqrtMax.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                     compareSymbol = errorCursor.setToNext()
                        ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  };
                  
                  AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
                  const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) cursor.globalElementAt()).getValue();
                  if (compareSymbol == CRGreater) {
                     wasOnSymbol = false;
                     if (coefficientValue.isPositive()) {
                        sqrtMin.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                        sqrtMax.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        sqrtMin.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                        sqrtMax.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                  }
                  else { // compareSymbol == CREqual
                     wasOnSymbol = true;
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     BuiltReal errorValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     errorValue.opposite();
                     if (errorValue >= coefficientValue) {
                        errorValue.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        errorValue.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                     if (errorValue.isPositive()) {
                        sqrtMin.minusAssign(errorValue, minParams);
                        minParams.clear();
                        sqrtMax.plusAssign(errorValue, minParams);
                        minParams.clear();
                     }
                     else {
                        sqrtMin.plusAssign(errorValue, minParams);
                        minParams.clear();
                        sqrtMax.minusAssign(errorValue, minParams);
                        minParams.clear();
                     };
                  };
               } while (cursor.setToNext());
               if (wasOnSymbol)
                  errorCursor.setToNext();
               if (errorCursor.isValid()) {
                  do {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        sqrtMin.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                        sqrtMax.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        sqrtMin.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                        sqrtMax.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                  } while (errorCursor.setToNext());
               };
            };
         };
         BuiltReal tmpMin, tmpMax;
         if (sqrtMin.isNegative())
            sqrtMin.setZero();
         else {
            sqrtMin.sqrtAssign(tmpMin, tmpMax, minParams);
            minParams.clear();
         };
         if (sqrtMax.isNegative())
            sqrtMax.setZero();
         else {
            sqrtMax.sqrtAssign(tmpMin, tmpMax, minParams);
            minParams.clear();
         };
      };
      auto& symbolsManager = thisType::symbolsManager();
      eRealDomain.sqrtAssign(symbolsManager);
      if (hasError) {
         if (eError.getCentral().isInftyExponent()) {
            performInftyNaNComputationWithError(eError, &BuiltReal::sqrtAssign, TypeBaseFloatAffine::nearestParams());
            return;
         };
         // sqrt(x+e) = sqrt(x) + e/(2*sqrt(x)) + newCoeff
         eError.divAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager);
         eError.divAssign(BuiltReal(2U), symbolsManager);

         BuiltReal computeSqrtMin(eRealDomain.getSCentral());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         auto& minParams = TypeBaseFloatAffine::minParams();
         computeSqrtMin.plusAssign(eError.getSCentral(), maxParams);
         maxParams.clear();
         BuiltReal computeSqrtMax = computeSqrtMin;
         if (computeSqrtMin.isNegative())
            computeSqrtMin.setZero();
         {  typename Equation::Cursor cursor(eRealDomain), errorCursor(eError);
            bool wasOnSymbol = true;
            if (cursor.setToFirst()) {
               do {
                  const Symbol& symbol = cursor.elementAt();
                  if (wasOnSymbol)
                     errorCursor.setToNext();
                  ComparisonResult compareSymbol = errorCursor.isValid()
                     ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  while (compareSymbol == CRLess) {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        computeSqrtMin.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeSqrtMin.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                     compareSymbol = errorCursor.setToNext()
                        ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  };
                  
                  AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
                  const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) cursor.globalElementAt()).getValue();
                  if (compareSymbol == CRGreater) {
                     if (coefficientValue.isPositive()) {
                        computeSqrtMin.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeSqrtMin.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                  }
                  else { // compareSymbol == CREqual
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     BuiltReal errorValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     errorValue.opposite();
                     if (errorValue >= coefficientValue) {
                        errorValue.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        errorValue.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                     if (errorValue.isPositive()) {
                        computeSqrtMin.minusAssign(errorValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.plusAssign(errorValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeSqrtMin.plusAssign(errorValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.minusAssign(errorValue, maxParams);
                        maxParams.clear();
                     };
                  };
               } while (cursor.setToNext());
               if (errorCursor.isValid()) {
                  do {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        computeSqrtMin.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeSqrtMin.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeSqrtMax.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                  } while (errorCursor.setToNext());
               };
            };
         };
         sqrtMin.minusAssign(computeSqrtMin, minParams);
         minParams.clear();
         sqrtMax.minusAssign(computeSqrtMax, minParams);
         minParams.clear();
         if (sqrtMax < sqrtMin)
            sqrtMin = sqrtMax;
         sqrtMin.divAssign(2U, minParams);
         minParams.clear();
         if (!sqrtMin.isZero()) {
            Equation additionalError;
            additionalError.setCentral(sqrtMin);
            additionalError.addCoefficient(sqrtMin, *symbolsManager.createNoiseSymbol());
            eError.plusAssign(additionalError, Equation::PCSourceXValue, symbolsManager);
         };
      };
   };
}

static const double PI = 3.141592653589793238;

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::sinAssign() {
   updateLocalState();
   if (doesComputeReal()) {
      BuiltReal minReal, maxReal;
      eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);

      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minReal.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minReal.getBasicExponent()[index];
      conversion.setNegative(minReal.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
         minBuilt, maxBuilt;
      minBuilt.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxReal.getBasicExponent()[index];
      conversion.setNegative(maxReal.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      maxBuilt.setFloat(conversion, maxParams);
      maxParams.clear();

      double min=0, max=0;
      DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      int kmin = 0, kmax = 0;
      bool isTop = false;
      if (min < -PI/2.0) {
         if (min < -PI * 1000.0)
            isTop = true;
         else {
            kmin = (min + PI/2) / PI;
            min -= PI * kmin;
            if (min < -PI/2) {
               --kmin;
               min += PI;
            }
            else if (min > PI/2) {
               ++kmin;
               min -= PI;
            };
         };
      }
      else if (min > PI/2.0) {
         if (min > PI * 1000.0)
            isTop = true;
         else {
            kmin = (min + PI/2) / PI;
            min -= PI * kmin;
            if (min < -PI/2) {
               --kmin;
               min += PI;
            }
            else if (min > PI/2) {
               ++kmin;
               min -= PI;
            };
         };
      };
      if (max < -PI/2.0) {
         if (max < -PI * 1000.0)
            isTop = true;
         else {
            kmax = (max + PI/2) / PI;
            max -= PI * kmax;
            if (max < -PI/2) {
               --kmax;
               max += PI;
            }
            else if (max > PI/2) {
               ++kmax;
               max -= PI;
            };
         };
      }
      else if (max > PI/2.0) {
         if (max > PI * 1000.0)
            isTop = true;
         else {
            kmax = (max + PI/2) / PI;
            max -= PI * kmax;
            if (max < -PI/2) {
               --kmax;
               max += PI;
            }
            else if (max > PI/2) {
               ++kmax;
               max -= PI;
            };
         };
      };
      AssumeCondition(kmin <= kmax)
      if (!isTop) {
         if (kmin == kmax) {
            if (kmin % 2 == 0) {
               min = ::sin(min);
               max = ::sin(max);
            }
            else {
               double temp = -::sin(min);
               min = -::sin(max);
               max = temp;
            }
         }
         else if (kmin == kmax - 1) {
            min = ::sin(min);
            max = ::sin(max);
            if (kmin % 2 == 0) {
               if (-max < min)
                  min = -max;
               max = 1.0;
            }
            else {
               if (-min > max)
                  max = -min;
               min = -1.0;
            };
         }
         else {
            min = -1.0;
            max = +1.0;
         };
      }
      else {
         min = -1.0;
         max = +1.0;
      };
      AssumeCondition(min <= max)
      DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

      conversion.setSizeMantissa(52).setSizeExponent(11);
      sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
      conversion.setNegative(minBuilt.isNegative());
      minReal.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
      conversion.setNegative(maxBuilt.isNegative());
      maxReal.setFloat(conversion, maxParams);
      maxParams.clear();
      eRealDomain.setInterval(minReal, maxReal, symbolsManager());
   }
   if (doesComputeError()) {
      if (doesComputeReal()) {
         Equation coeff;
         BuiltReal one(0x1), minusOne(0x1);
         minusOne.opposite();
         coeff.setInterval(minusOne, one, symbolsManager());
         eError.multAssign(coeff, Equation::PCSourceXValue, symbolsManager());
      }
      else {
         BuiltReal minError, maxError;
         eError.retrieveBound(minError, maxError, false /* hasExternalCoefficient */);

         typename BuiltReal::FloatConversion conversion;
         conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
         int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minError.getMantissa()[index];
         int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minError.getBasicExponent()[index];
         conversion.setNegative(minError.isNegative());
         auto& minParams = TypeBaseFloatAffine::minParams();
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
            minBuilt, maxBuilt;
         minBuilt.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxError.getBasicExponent()[index];
         conversion.setNegative(maxError.isNegative());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         maxBuilt.setFloat(conversion, maxParams);
         maxParams.clear();

         double min=0, max=0;
         DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         int kmin = 0, kmax = 0;
         bool isTop = false;
         if (min < -PI/2.0) {
            if (min < -PI * 1000.0)
               isTop = true;
            else {
               kmin = (min + PI/2) / PI;
               min -= PI * kmin;
               if (min < -PI/2) {
                  --kmin;
                  min += PI;
               }
               else if (min > PI/2) {
                  ++kmin;
                  min -= PI;
               };
            };
         }
         else if (min > PI/2.0) {
            if (min > PI * 1000.0)
               isTop = true;
            else {
               kmin = (min + PI/2) / PI;
               min -= PI * kmin;
               if (min < -PI/2) {
                  --kmin;
                  min += PI;
               }
               else if (min > PI/2) {
                  ++kmin;
                  min -= PI;
               };
            };
         };
         if (max < -PI/2.0) {
            if (max < -PI * 1000.0)
               isTop = true;
            else {
               kmax = (max + PI/2) / PI;
               max -= PI * kmax;
               if (max < -PI/2) {
                  --kmax;
                  max += PI;
               }
               else if (max > PI/2) {
                  ++kmax;
                  max -= PI;
               };
            };
         }
         else if (max > PI/2.0) {
            if (max > PI * 1000.0)
               isTop = true;
            else {
               kmax = (max + PI/2) / PI;
               max -= PI * kmax;
               if (max < -PI/2) {
                  --kmax;
                  max += PI;
               }
               else if (max > PI/2) {
                  ++kmax;
                  max -= PI;
               };
            };
         };
         AssumeCondition(kmin <= kmax)
         if (!isTop) {
            if (kmin == kmax) {
               if (kmin % 2 == 0) {
                  min = ::sin(min);
                  max = ::sin(max);
               }
               else {
                  double temp = -::sin(min);
                  min = -::sin(max);
                  max = temp;
               }
            }
            else if (kmin == kmax - 1) {
               min = ::sin(min);
               max = ::sin(max);
               if (kmin % 2 == 0) {
                  if (-max < min)
                     min = -max;
                  max = 1.0;
               }
               else {
                  if (-min > max)
                     max = -min;
                  min = -1.0;
               };
            }
            else {
               min = -1.0;
               max = +1.0;
            };
         }
         else {
            min = -1.0;
            max = +1.0;
         };
         AssumeCondition(min <= max)
         DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

         conversion.setSizeMantissa(52).setSizeExponent(11);
         sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
         conversion.setNegative(minBuilt.isNegative());
         minError.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
         conversion.setNegative(maxBuilt.isNegative());
         maxError.setFloat(conversion, maxParams);
         maxParams.clear();
         eError.setInterval(minError, maxError, symbolsManager());
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::cosAssign() {
   updateLocalState();
   if (doesComputeReal()) {
      BuiltReal minReal, maxReal;
      eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);

      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minReal.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minReal.getBasicExponent()[index];
      conversion.setNegative(minReal.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
         minBuilt, maxBuilt;
      minBuilt.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxReal.getBasicExponent()[index];
      conversion.setNegative(maxReal.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      maxBuilt.setFloat(conversion, maxParams);
      maxParams.clear();

      double min=0, max=0;
      DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      int kmin = 0, kmax = 0;
      bool isTop = false;
      if (min < -PI/2) {
         if (min < -PI * 1000.0)
            isTop = true;
         else {
            kmin = (min / PI + 0.5);
            min -= PI * kmin;
            if (min < -PI/2) {
               --kmin;
               min += PI;
            }
            else if (min > PI/2) {
               ++kmin;
               min -= PI;
            };
         };
      }
      else if (min > PI/2) {
         if (min > PI * 1000.0)
            isTop = true;
         else {
            kmin = (min / PI + 0.5);
            min -= PI * kmin;
            if (min < -PI/2) {
               --kmin;
               min += PI;
            }
            else if (min > PI/2) {
               ++kmin;
               min -= PI;
            };
         };
      };
      if (max < -PI/2) {
         if (max < -PI * 1000.0)
            isTop = true;
         else {
            kmax = (max / PI + 0.5);
            max -= PI * kmax;
            if (max < -PI/2) {
               --kmax;
               max += PI;
            }
            else if (max > PI/2) {
               ++kmax;
               max -= PI;
            };
         };
      }
      else if (max > PI/2) {
         if (max > PI * 1000.0)
            isTop = true;
         else {
            kmax = (max / PI + 0.5);
            max -= PI * kmax;
            if (max < -PI/2) {
               --kmax;
               max += PI;
            }
            else if (max > PI/2) {
               ++kmax;
               max -= PI;
            };
         };
      };
      AssumeCondition(kmin <= kmax)
      if (!isTop) {
         if (kmin == kmax) { // -PI/2 <= min <= max <= PI/2
            if (min >= 0) {
               double temp = ::cos(max);
               max = ::cos(min);
               min = temp;
               // 0 <= min <= max <= 1
            }
            else if (max <= 0) {
               min = ::cos(min);
               max = ::cos(max);
               // 0 <= min <= max <= 1
            }
            else {
               min = ::cos(min);
               max = ::cos(max);
               if (min > max)
                  min = max;
               max = +1.0;
            };
            if (kmin % 2 != 0) {
               double temp = -min;
               min = -max;
               max = temp;
            }
         }
         else if (kmin == kmax - 1) {
            bool isMinNegative = min < 0;
            bool isMaxPositive = max > 0;
            double temp = -::cos(max);
            max = ::cos(min);
            min = temp;
            if (isMinNegative)
               max = +1.0;
            if (isMaxPositive)
               min = -1.0;
         }
         else {
            min = -1.0;
            max = +1.0;
         }
      }
      else {
         min = -1.0;
         max = +1.0;
      };
      AssumeCondition(min <= max)
      DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

      conversion.setSizeMantissa(52).setSizeExponent(11);
      sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
      conversion.setNegative(minBuilt.isNegative());
      minReal.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
      conversion.setNegative(maxBuilt.isNegative());
      maxReal.setFloat(conversion, maxParams);
      maxParams.clear();
      eRealDomain.setInterval(minReal, maxReal, symbolsManager());
   }
   if (doesComputeError()) {
      if (doesComputeReal()) {
         Equation coeff;
         BuiltReal one(0x1), minusOne(0x1);
         minusOne.opposite();
         coeff.setInterval(minusOne, one, symbolsManager());
         eError.multAssign(coeff, Equation::PCSourceXValue, symbolsManager());
      }
      else {
         BuiltReal minError, maxError;
         eError.retrieveBound(minError, maxError, false /* hasExternalCoefficient */);

         typename BuiltReal::FloatConversion conversion;
         conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
         int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minError.getMantissa()[index];
         int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minError.getBasicExponent()[index];
         conversion.setNegative(minError.isNegative());
         auto& minParams = TypeBaseFloatAffine::minParams();
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
            minBuilt, maxBuilt;
         minBuilt.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxError.getBasicExponent()[index];
         conversion.setNegative(maxError.isNegative());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         maxBuilt.setFloat(conversion, maxParams);
         maxParams.clear();

         double min=0, max=0;
         DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         int kmin = 0, kmax = 0;
         bool isTop = false;
         if (min < -PI/2) {
            if (min < -PI * 1000.0)
               isTop = true;
            else {
               kmin = (min / PI + 0.5);
               min -= PI * kmin;
               if (min < -PI/2) {
                  --kmin;
                  min += PI;
               }
               else if (min > PI/2) {
                  ++kmin;
                  min -= PI;
               };
            };
         }
         else if (min > PI/2) {
            if (min > PI * 1000.0)
               isTop = true;
            else {
               kmin = (min / PI + 0.5);
               min -= PI * kmin;
               if (min < -PI/2) {
                  --kmin;
                  min += PI;
               }
               else if (min > PI/2) {
                  ++kmin;
                  min -= PI;
               };
            };
         };
         if (max < -PI/2) {
            if (max < -PI * 1000.0)
               isTop = true;
            else {
               kmax = (max / PI + 0.5);
               max -= PI * kmax;
               if (max < -PI/2) {
                  --kmax;
                  max += PI;
               }
               else if (max > PI/2) {
                  ++kmax;
                  max -= PI;
               };
            };
         }
         else if (max > PI/2) {
            if (max > PI * 1000.0)
               isTop = true;
            else {
               kmax = (max / PI + 0.5);
               max -= PI * kmax;
               if (max < -PI/2) {
                  --kmax;
                  max += PI;
               }
               else if (max > PI/2) {
                  ++kmax;
                  max -= PI;
               };
            };
         };
         AssumeCondition(kmin <= kmax)
         if (!isTop) {
            if (kmin == kmax) {
               if (min >= 0) {
                  double temp = ::cos(max);
                  max = ::cos(min);
                  min = temp;
                  // 0 <= min <= max <= 1
               }
               else if (max <= 0) {
                  min = ::cos(min);
                  max = ::cos(max);
                  // 0 <= min <= max <= 1
               }
               else {
                  min = ::cos(min);
                  max = ::cos(max);
                  if (min > max)
                     min = max;
                  max = +1.0;
               };
               if (kmin % 2 != 0) {
                  double temp = -min;
                  min = -max;
                  max = temp;
               }
            }
            else if (kmin == kmax - 1) {
               bool isMinNegative = min < 0;
               bool isMaxPositive = max > 0;
               double temp = -::cos(max);
               max = ::cos(min);
               min = temp;
               if (isMinNegative)
                  max = +1.0;
               if (isMaxPositive)
                  min = -1.0;
            }
            else {
               min = -1.0;
               max = +1.0;
            }
         }
         else {
            min = -1.0;
            max = +1.0;
         };
         AssumeCondition(min <= max)
         DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

         conversion.setSizeMantissa(52).setSizeExponent(11);
         sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
         conversion.setNegative(minBuilt.isNegative());
         minError.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
         conversion.setNegative(maxBuilt.isNegative());
         maxError.setFloat(conversion, maxParams);
         maxParams.clear();
         eError.setInterval(minError, maxError, symbolsManager());
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::asinAssign() {
   updateLocalState();
   if (doesComputeReal()) {
      BuiltReal minReal, maxReal;
      eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);

      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minReal.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minReal.getBasicExponent()[index];
      conversion.setNegative(minReal.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
         minBuilt, maxBuilt;
      minBuilt.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxReal.getBasicExponent()[index];
      conversion.setNegative(maxReal.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      maxBuilt.setFloat(conversion, maxParams);
      maxParams.clear();

      double min=0, max=0;
      DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      if (min <= -1.0)
         min = -PI/2;
      else if (min >= 1.0)
         min = PI/2;
      else
         min = ::asin(min);
      if (max <= -1.0)
         max = -PI/2;
      else if (max >= 1.0)
         max = PI/2;
      else
         max = ::asin(max);
      AssumeCondition(min <= max)
      DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

      conversion.setSizeMantissa(52).setSizeExponent(11);
      sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
      conversion.setNegative(minBuilt.isNegative());
      minReal.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
      conversion.setNegative(maxBuilt.isNegative());
      maxReal.setFloat(conversion, maxParams);
      maxParams.clear();
      eRealDomain.setInterval(minReal, maxReal, symbolsManager());
   }
   if (doesComputeError()) {
      if (doesComputeReal()) {
         BuiltReal minReal, maxReal;
         eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);
         if (minReal < BuiltReal(0x1).opposite())
            minReal = BuiltReal(0x1).opposite();
         if (maxReal > BuiltReal(0x1))
            maxReal = BuiltReal(0x1);
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         minReal.multAssign(minReal, maxParams);
         maxParams.clear();
         maxReal.multAssign(maxReal, maxParams);
         maxParams.clear();
         if (minReal > maxReal)
            maxReal = minReal;
         auto& minParams = TypeBaseFloatAffine::minParams();
         maxReal.minusAssign(BuiltReal(0x1), minParams);
         maxReal.opposite();
         BuiltReal derived(0x1);
         derived.divAssign(maxReal, maxParams);
         maxParams.clear();
         BuiltReal minusDerived(derived);
         minusDerived.opposite();
         Equation coeff;
         coeff.setInterval(minusDerived, derived, symbolsManager());
         eError.multAssign(coeff, Equation::PCSourceXValue, symbolsManager());
      }
      else {
         BuiltReal minError, maxError;
         eError.retrieveBound(minError, maxError, false /* hasExternalCoefficient */);

         typename BuiltReal::FloatConversion conversion;
         conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
         int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minError.getMantissa()[index];
         int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minError.getBasicExponent()[index];
         conversion.setNegative(minError.isNegative());
         auto& minParams = TypeBaseFloatAffine::minParams();
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
            minBuilt, maxBuilt;
         minBuilt.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxError.getBasicExponent()[index];
         conversion.setNegative(maxError.isNegative());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         maxBuilt.setFloat(conversion, maxParams);
         maxParams.clear();

         double min=0, max=0;
         DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         if (min <= -1.0)
            min = -PI/2;
         else if (min >= 1.0)
            min = PI/2;
         else
            min = ::asin(min);
         if (max <= -1.0)
            max = -PI/2;
         else if (max >= 1.0)
            max = PI/2;
         else
            max = ::asin(max);
         AssumeCondition(min <= max)
         DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

         conversion.setSizeMantissa(52).setSizeExponent(11);
         sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
         conversion.setNegative(minBuilt.isNegative());
         minError.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
         conversion.setNegative(maxBuilt.isNegative());
         maxError.setFloat(conversion, maxParams);
         maxParams.clear();
         eError.setInterval(minError, maxError, symbolsManager());
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::acosAssign() {
   updateLocalState();
   if (doesComputeReal()) {
      BuiltReal minReal, maxReal;
      eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);

      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minReal.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minReal.getBasicExponent()[index];
      conversion.setNegative(minReal.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
         minBuilt, maxBuilt;
      minBuilt.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxReal.getBasicExponent()[index];
      conversion.setNegative(maxReal.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      maxBuilt.setFloat(conversion, maxParams);
      maxParams.clear();

      double min=0, max=0;
      DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      double temp;
      if (min <= -1.0)
         temp = PI;
      else if (min >= 1.0)
         temp = 0;
      else
         temp = ::acos(min);
      if (max <= -1.0)
         min = PI;
      else if (max >= 1.0)
         min = 0;
      else
         min = ::acos(max);
      max = temp;
      AssumeCondition(min <= max)
      DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

      conversion.setSizeMantissa(52).setSizeExponent(11);
      sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
      conversion.setNegative(minBuilt.isNegative());
      minReal.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
      conversion.setNegative(maxBuilt.isNegative());
      maxReal.setFloat(conversion, maxParams);
      maxParams.clear();
      eRealDomain.setInterval(minReal, maxReal, symbolsManager());
   }
   if (doesComputeError()) {
      if (doesComputeReal()) {
         BuiltReal minReal, maxReal;
         eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);
         if (minReal < BuiltReal(0x1).opposite())
            minReal = BuiltReal(0x1).opposite();
         if (maxReal > BuiltReal(0x1))
            maxReal = BuiltReal(0x1);
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         minReal.multAssign(minReal, maxParams);
         maxParams.clear();
         maxReal.multAssign(maxReal, maxParams);
         maxParams.clear();
         if (minReal > maxReal)
            maxReal = minReal;
         auto& minParams = TypeBaseFloatAffine::minParams();
         maxReal.minusAssign(BuiltReal(0x1), minParams);
         maxReal.opposite();
         BuiltReal derived(0x1);
         derived.divAssign(maxReal, maxParams);
         maxParams.clear();
         BuiltReal minusDerived(derived);
         minusDerived.opposite();
         Equation coeff;
         coeff.setInterval(minusDerived, derived, symbolsManager());
         eError.multAssign(coeff, Equation::PCSourceXValue, symbolsManager());
      }
      else {
         BuiltReal minError, maxError;
         eError.retrieveBound(minError, maxError, false /* hasExternalCoefficient */);

         typename BuiltReal::FloatConversion conversion;
         conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
         int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minError.getMantissa()[index];
         int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minError.getBasicExponent()[index];
         conversion.setNegative(minError.isNegative());
         auto& minParams = TypeBaseFloatAffine::minParams();
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
            minBuilt, maxBuilt;
         minBuilt.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxError.getBasicExponent()[index];
         conversion.setNegative(maxError.isNegative());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         maxBuilt.setFloat(conversion, maxParams);
         maxParams.clear();

         double min=0, max=0;
         DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         double temp;
         if (min <= -1.0)
            temp = PI;
         else if (min >= 1.0)
            temp = 0;
         else
            temp = ::acos(min);
         if (max <= -1.0)
            min = PI;
         else if (max >= 1.0)
            min = 0;
         else
            min = ::acos(max);
         max = temp;
         AssumeCondition(min <= max)
         DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

         conversion.setSizeMantissa(52).setSizeExponent(11);
         sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
         conversion.setNegative(minBuilt.isNegative());
         minError.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
         conversion.setNegative(maxBuilt.isNegative());
         maxError.setFloat(conversion, maxParams);
         maxParams.clear();
         eError.setInterval(minError, maxError, symbolsManager());
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::atanAssign() {
   updateLocalState();
   if (doesComputeReal()) {
      BuiltReal minReal, maxReal;
      eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);

      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minReal.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minReal.getBasicExponent()[index];
      conversion.setNegative(minReal.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
         minBuilt, maxBuilt;
      minBuilt.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxReal.getBasicExponent()[index];
      conversion.setNegative(maxReal.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      maxBuilt.setFloat(conversion, maxParams);
      maxParams.clear();

      double min=0, max=0;
      DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      min = ::atan(min);
      max = ::atan(max);
      AssumeCondition(min <= max)
      DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

      conversion.setSizeMantissa(52).setSizeExponent(11);
      sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
      conversion.setNegative(minBuilt.isNegative());
      minReal.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
      conversion.setNegative(maxBuilt.isNegative());
      maxReal.setFloat(conversion, maxParams);
      maxParams.clear();
      eRealDomain.setInterval(minReal, maxReal, symbolsManager());
   }
   if (doesComputeError()) {
      if (doesComputeReal()) {
         BuiltReal one(0x1), minusOne(0x1);
         minusOne.opposite();
         Equation coeff;
         coeff.setInterval(minusOne, one, symbolsManager());
         eError.multAssign(coeff, Equation::PCSourceXValue, symbolsManager());
      }
      else {
         BuiltReal minError, maxError;
         eError.retrieveBound(minError, maxError, false /* hasExternalCoefficient */);

         typename BuiltReal::FloatConversion conversion;
         conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
         int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minError.getMantissa()[index];
         int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minError.getBasicExponent()[index];
         conversion.setNegative(minError.isNegative());
         auto& minParams = TypeBaseFloatAffine::minParams();
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
            minBuilt, maxBuilt;
         minBuilt.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxError.getBasicExponent()[index];
         conversion.setNegative(maxError.isNegative());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         maxBuilt.setFloat(conversion, maxParams);
         maxParams.clear();

         double min=0, max=0;
         DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         min = ::atan(min);
         max = ::atan(max);
         AssumeCondition(min <= max)
         DAffine::DefineFillContent(minBuilt, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineFillContent(maxBuilt, max, typename TypeBaseFloatAffine::FloatDigitsHelper());

         conversion.setSizeMantissa(52).setSizeExponent(11);
         sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
         conversion.setNegative(minBuilt.isNegative());
         minError.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
         conversion.setNegative(maxBuilt.isNegative());
         maxError.setFloat(conversion, maxParams);
         maxParams.clear();
         eError.setInterval(minError, maxError, symbolsManager());
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::expAssign() {
   updateLocalState();
   bool hasError = false;
   auto& symbolsManager = thisType::symbolsManager();
   if ((hasError = doesComputeError()) != false)
      eError.expAssign(symbolsManager);
   if (doesComputeReal()) {
      eRealDomain.expAssign(symbolsManager);
      if (hasError) {
         // exp(x+e) = exp(x) + exp(x)*(exp(e)-1)
         Equation one;
         {  BuiltReal tmp;
            tmp.setOne();
            one.setCentral(tmp);
         };
         eError.minusAssign(one, Equation::PCSourceXValue, symbolsManager);
         eError.multAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager);
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::logAssign() {
   updateLocalState();
   bool hasReal = false;
   bool hasError = false;
   if ((hasError = doesComputeError()) != false) {
      if ((hasReal = doesComputeReal()) == false) {
         if (!eError.logAssign(symbolsManager()))
            mergeTopError();
      }
   }
   if (hasReal || doesComputeReal()) {
      BuiltReal logMin, logMax;
      if (hasError) {
         logMin = eRealDomain.getSCentral();
         auto& minParams = TypeBaseFloatAffine::minParams();
         logMin.plusAssign(eError.getSCentral(), minParams);
         minParams.clear();
         logMax = logMin;
         {  typename Equation::Cursor cursor(eRealDomain), errorCursor(eError);
            bool wasOnSymbol = true;
            if (cursor.setToFirst()) {
               do {
                  const Symbol& symbol = cursor.elementAt();
                  if (wasOnSymbol)
                     errorCursor.setToNext();
                  ComparisonResult compareSymbol = errorCursor.isValid()
                     ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  while (compareSymbol == CRLess) {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        logMin.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                        logMax.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        logMin.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                        logMax.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                     compareSymbol = errorCursor.setToNext()
                        ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  };
                  
                  AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
                  const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) cursor.globalElementAt()).getValue();
                  if (compareSymbol == CRGreater) {
                     wasOnSymbol = false;
                     if (coefficientValue.isPositive()) {
                        logMin.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                        logMax.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        logMin.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                        logMax.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                  }
                  else { // compareSymbol == CREqual
                     wasOnSymbol = true;
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     BuiltReal errorValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     errorValue.opposite();
                     if (errorValue >= coefficientValue) {
                        auto& maxParams = TypeBaseFloatAffine::maxParams();
                        errorValue.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        errorValue.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                     if (errorValue.isPositive()) {
                        logMin.minusAssign(errorValue, minParams);
                        minParams.clear();
                        logMax.plusAssign(errorValue, minParams);
                        minParams.clear();
                     }
                     else {
                        logMin.plusAssign(errorValue, minParams);
                        minParams.clear();
                        logMax.minusAssign(errorValue, minParams);
                        minParams.clear();
                     };
                  };
               } while (cursor.setToNext());
               if (wasOnSymbol)
                  errorCursor.setToNext();
               if (errorCursor.isValid()) {
                  do {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        logMin.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                        logMax.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        logMin.plusAssign(coefficientValue, minParams);
                        minParams.clear();
                        logMax.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     };
                  } while (errorCursor.setToNext());
               };
            };
         };
         BuiltReal tmpMin, tmpMax;
         if (logMin.isNegative() || logMin.isZero()) {
            mergeTopReal();
            return;
         };
         logMin.logAssign(tmpMin, tmpMax, minParams);
         minParams.clear();
         logMax.logAssign(tmpMin, tmpMax, minParams);
         minParams.clear();

         // log(x+e) = log(x) + e/x + newCoeff
         eError.divAssign(eRealDomain, Equation::PCSourceRValue, symbolsManager());
      };
      if (!eRealDomain.logAssign(symbolsManager())) {
         mergeTopReal();
         return;
      };
      if (hasError) {
         BuiltReal computeLogMin(eRealDomain.getSCentral());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         auto& minParams = TypeBaseFloatAffine::minParams();
         computeLogMin.plusAssign(eError.getSCentral(), maxParams);
         maxParams.clear();
         BuiltReal computeLogMax = computeLogMin;
         {  typename Equation::Cursor cursor(eRealDomain), errorCursor(eError);
            bool wasOnSymbol = true;
            if (cursor.setToFirst()) {
               do {
                  const Symbol& symbol = cursor.elementAt();
                  if (wasOnSymbol)
                     errorCursor.setToNext();
                  ComparisonResult compareSymbol = errorCursor.isValid()
                     ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  while (compareSymbol == CRLess) {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        computeLogMin.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeLogMax.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeLogMin.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeLogMax.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                     compareSymbol = errorCursor.setToNext()
                        ? errorCursor.elementAt().compare(symbol) : CRGreater;
                  };
                  
                  AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
                  const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) cursor.globalElementAt()).getValue();
                  if (compareSymbol == CRGreater) {
                     if (coefficientValue.isPositive()) {
                        computeLogMin.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeLogMax.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeLogMin.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeLogMax.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                  }
                  else { // compareSymbol == CREqual
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     BuiltReal errorValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     errorValue.opposite();
                     if (errorValue >= coefficientValue) {
                        errorValue.minusAssign(coefficientValue, minParams);
                        minParams.clear();
                     }
                     else {
                        errorValue.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                     if (errorValue.isPositive()) {
                        computeLogMin.minusAssign(errorValue, maxParams);
                        maxParams.clear();
                        computeLogMax.plusAssign(errorValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeLogMin.plusAssign(errorValue, maxParams);
                        maxParams.clear();
                        computeLogMax.minusAssign(errorValue, maxParams);
                        maxParams.clear();
                     };
                  };
               } while (cursor.setToNext());
               if (errorCursor.isValid()) {
                  do {
                     AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&errorCursor.globalElementAt()))
                     const BuiltReal& coefficientValue = ((const typename Equation::Coefficient&) errorCursor.globalElementAt()).getValue();
                     if (coefficientValue.isPositive()) {
                        computeLogMin.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeLogMax.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     }
                     else {
                        computeLogMin.plusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                        computeLogMax.minusAssign(coefficientValue, maxParams);
                        maxParams.clear();
                     };
                  } while (errorCursor.setToNext());
               };
            };
         };
         logMin.minusAssign(computeLogMin, minParams);
         minParams.clear();
         logMax.minusAssign(computeLogMax, minParams);
         minParams.clear();
         if (logMax < logMin)
            logMin = logMax;
         logMin.divAssign(2U, minParams);
         minParams.clear();
         if (!logMin.isZero()) {
            Equation additionalError;
            additionalError.setCentral(logMin);
            auto& symbolsManager = thisType::symbolsManager();
            additionalError.addCoefficient(logMin, *symbolsManager.createNoiseSymbol());
            eError.plusAssign(additionalError, Equation::PCSourceXValue, symbolsManager);
         };
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::powAssign(
      const thisType& value, typename Equation::PolicyCall policyCall) {
   updateLocalState();
   if (doesComputeError()) {
      if (!doesComputeReal()) {
         BuiltReal minThis, maxThis, minValue, maxValue;
         eRealDomain.retrieveBound(minThis, maxThis, false /* hasExternalCoefficient */);
         value.eRealDomain.retrieveBound(minValue, maxValue, false /* hasExternalCoefficient */);
         if (minThis.isZero() && !minValue.isZero() && minValue.isPositive()) {
            if (!maxThis.isZero()) {
               BuiltReal tmpMin, tmpMax;
               maxThis.logAssign(tmpMin, tmpMax, inherited::maxParams());
               inherited::maxParams().clear();
               maxThis.multAssign(maxValue, inherited::maxParams());
               inherited::maxParams().clear();
               maxThis.expAssign(tmpMin, tmpMax, inherited::maxParams());
               eError.setInterval(minThis, maxThis, symbolsManager());
            };
            return;
         };
      }
      else {
         BuiltReal minThisReal, maxThisReal, minValueReal, maxValueReal;
         BuiltReal minThisImplementation, maxThisImplementation, minValueImplementation, maxValueImplementation;
         Equation implementation(eRealDomain), valueImplementation(value.eRealDomain);
         implementation.plusAssign(eError, Equation::PCSourceRValue, symbolsManager(), false /* hasExternalCoefficient */);
         implementation.retrieveBound(minThisImplementation, maxThisImplementation, false /* hasExternalCoefficient */);
         valueImplementation.retrieveBound(minValueImplementation, maxValueImplementation, false /* hasExternalCoefficient */);
         if ((minThisReal.isZero() && !minValueReal.isZero() && minValueReal.isPositive())
              || (minThisImplementation.isZero() && !minValueImplementation.isZero() && minValueImplementation.isPositive())) {
            if (!maxThisReal.isZero()) {
               BuiltReal tmpMin, tmpMax;
               maxThisReal.logAssign(tmpMin, tmpMax, inherited::maxParams());
               inherited::maxParams().clear();
               maxThisReal.multAssign(maxValueReal, inherited::maxParams());
               inherited::maxParams().clear();
               maxThisReal.expAssign(tmpMin, tmpMax, inherited::maxParams());
               eRealDomain.setInterval(minThisReal, maxThisReal, symbolsManager());
            };
            if (!maxThisImplementation.isZero()) {
               BuiltReal tmpMin, tmpMax;
               maxThisImplementation.logAssign(tmpMin, tmpMax, inherited::maxParams());
               inherited::maxParams().clear();
               maxThisImplementation.multAssign(maxValueImplementation, inherited::maxParams());
               inherited::maxParams().clear();
               maxThisImplementation.expAssign(tmpMin, tmpMax, inherited::maxParams());
               maxThisReal.opposite();
               eError.setInterval(maxThisReal, maxThisImplementation, symbolsManager());
            };
            return;
         };
      }
   }
   else if (doesComputeReal()) {
      BuiltReal minThis, maxThis, minValue, maxValue;
      eRealDomain.retrieveBound(minThis, maxThis, false /* hasExternalCoefficient */);
      value.eRealDomain.retrieveBound(minValue, maxValue, false /* hasExternalCoefficient */);
      if (minThis.isZero() && !minValue.isZero() && minValue.isPositive()) {
         if (!maxThis.isZero()) {
            BuiltReal tmpMin, tmpMax;
            maxThis.logAssign(tmpMin, tmpMax, inherited::maxParams());
            inherited::maxParams().clear();
            maxThis.multAssign(maxValue, inherited::maxParams());
            inherited::maxParams().clear();
            maxThis.expAssign(tmpMin, tmpMax, inherited::maxParams());
            eRealDomain.setInterval(minThis, maxThis, symbolsManager());
         };
         return;
      };
   };
   logAssign();
   multAssign(value, policyCall);
   expAssign();
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineBaseFloatZonotope DefineEquationTemplateParameters(URealBitsNumber)::atan2Assign(
      const thisType& source, typename Equation::PolicyCall policyCall) {
   updateLocalState();
   GuardStateZonotope sourceGuard(source, true /* isConstEquation*/, policyCall == Equation::PCSourceXValue);
   // const_cast<thisType&>(source).updateLocalState();
   thisType thisCopy;
   if (doesComputeReal()) {
      if (doesComputeError())
         thisCopy = *this;
      BuiltReal minReal, maxReal, minSourceReal, maxSourceReal;
      eRealDomain.retrieveBound(minReal, maxReal, false /* hasExternalCoefficient */);
      source.eRealDomain.retrieveBound(minSourceReal, maxSourceReal, false /* hasExternalCoefficient */);

      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minReal.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minReal.getBasicExponent()[index];
      conversion.setNegative(minReal.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
         minBuilt, maxBuilt, minSourceBuilt, maxSourceBuilt;
      minBuilt.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxReal.getBasicExponent()[index];
      conversion.setNegative(maxReal.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      maxBuilt.setFloat(conversion, maxParams);
      maxParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minSourceReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minSourceReal.getBasicExponent()[index];
      conversion.setNegative(minSourceReal.isNegative());
      minSourceBuilt.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxSourceReal.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxSourceReal.getBasicExponent()[index];
      conversion.setNegative(maxSourceReal.isNegative());
      maxSourceBuilt.setFloat(conversion, maxParams);
      maxParams.clear();

      double min=0, max=0, minSource=0, maxSource=0;
      DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(minSource, minSourceBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineSetContent(maxSource, maxSourceBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
      // [TODO] not correct specification
      double newmax, newmin;
      newmax = newmin = ::atan2(min, minSource);
      double temp = ::atan2(max, minSource);
      if (temp < newmin)
         newmin = temp;
      if (temp > newmax)
         newmax = temp;
      temp = ::atan2(min, maxSource);
      if (temp < newmin)
         newmin = temp;
      if (temp > newmax)
         newmax = temp;
      temp = ::atan2(max, maxSource);
      if (temp < newmin)
         newmin = temp;
      if (temp > newmax)
         newmax = temp;
      // AssumeCondition(min <= max)
      DAffine::DefineFillContent(minBuilt, newmin, typename TypeBaseFloatAffine::FloatDigitsHelper());
      DAffine::DefineFillContent(maxBuilt, newmax, typename TypeBaseFloatAffine::FloatDigitsHelper());

      conversion.setSizeMantissa(52).setSizeExponent(11);
      sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = minBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
      conversion.setNegative(minBuilt.isNegative());
      minReal.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
      conversion.setNegative(maxBuilt.isNegative());
      maxReal.setFloat(conversion, maxParams);
      maxParams.clear();
      eRealDomain.setInterval(minReal, maxReal, symbolsManager());
   }
   if (doesComputeError()) {
      if (doesComputeReal()) {
         BuiltReal one(0x1), minusOne(0x1);
         minusOne.opposite();
         Equation coeff;
         thisType approxResult(source);
         approxResult.divAssign(thisCopy, Equation::PCSourceRValue);
         coeff.setInterval(minusOne, one, symbolsManager());
         approxResult.eError.multAssign(coeff, Equation::PCSourceXValue, symbolsManager());
         eError.swap(approxResult.eError);
      }
      else {
         BuiltReal minError, maxError, minSourceError, maxSourceError;
         eError.retrieveBound(minError, maxError, false /* hasExternalCoefficient */);
         source.eError.retrieveBound(minSourceError, maxSourceError, false /* hasExternalCoefficient */);

         typename BuiltReal::FloatConversion conversion;
         conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
         int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minError.getMantissa()[index];
         int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minError.getBasicExponent()[index];
         conversion.setNegative(minError.isNegative());
         auto& minParams = TypeBaseFloatAffine::minParams();
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, 52, 11) >
            minBuilt, maxBuilt, minSourceBuilt, maxSourceBuilt;
         minBuilt.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxError.getBasicExponent()[index];
         conversion.setNegative(maxError.isNegative());
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         maxBuilt.setFloat(conversion, maxParams);
         maxParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minSourceError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minSourceError.getBasicExponent()[index];
         conversion.setNegative(minSourceError.isNegative());
         minSourceBuilt.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxSourceError.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxSourceError.getBasicExponent()[index];
         conversion.setNegative(maxSourceError.isNegative());
         maxSourceBuilt.setFloat(conversion, maxParams);
         maxParams.clear();

         double min=0, max=0, minSource=0, maxSource=0;
         DAffine::DefineSetContent(min, minBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(max, maxBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(minSource, minSourceBuilt /*, false isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineSetContent(maxSource, maxSourceBuilt /*, true isUpper */, typename TypeBaseFloatAffine::FloatDigitsHelper());
         // [TODO] not correct specification
         double newmax, newmin;
         newmax = newmin = ::atan2(min, minSource);
         double temp = ::atan2(max, minSource);
         if (temp < newmin)
            newmin = temp;
         if (temp > newmax)
            newmax = temp;
         temp = ::atan2(min, maxSource);
         if (temp < newmin)
            newmin = temp;
         if (temp > newmax)
            newmax = temp;
         temp = ::atan2(max, maxSource);
         if (temp < newmin)
            newmin = temp;
         if (temp > newmax)
            newmax = temp;
         // AssumeCondition(min <= max)
         DAffine::DefineFillContent(minBuilt, newmin, typename TypeBaseFloatAffine::FloatDigitsHelper());
         DAffine::DefineFillContent(maxBuilt, newmax, typename TypeBaseFloatAffine::FloatDigitsHelper());

         conversion.setSizeMantissa(52).setSizeExponent(11);
         sizeMantissa = (52 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         sizeExponent = (11 + DefineSizeofBaseTypeInBits - 1)/DefineSizeofBaseTypeInBits;
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = minBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = minBuilt.getBasicExponent()[index];
         conversion.setNegative(minBuilt.isNegative());
         minError.setFloat(conversion, minParams);
         minParams.clear();
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = maxBuilt.getMantissa()[index];
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = maxBuilt.getBasicExponent()[index];
         conversion.setNegative(maxBuilt.isNegative());
         maxError.setFloat(conversion, maxParams);
         maxParams.clear();
         eError.setInterval(minError, maxError, symbolsManager());
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
class TSimplificationRules DefineEquationTemplateParameters(URealBitsNumber)
   ::EquationCoefficientKey {
  public:
   EquationCoefficientKey(const COL::VirtualMultiSortedCollection& support) {}
   typedef BuiltReal KeyType;
   typedef BuiltReal ControlKeyType;
   static KeyType key(const typename Equation::Coefficient& coefficient)
      {  BuiltReal result = coefficient.getValue();
         if (result.isNegative())
            result.opposite();
         return result;
      }
   static ComparisonResult compare(const ControlKeyType& first, const ControlKeyType& second)
      {  return first.compare(second); }
};

DefineEquationTemplateHeader(URealBitsNumber)
void
TSimplificationRules DefineEquationTemplateParameters(URealBitsNumber)
      ::simplifyMinMax(Equation& equation, int minSymbols, int maxSymbols) const {
   if (equation.count() > maxSymbols) {
      COL::TMultiArray<typename Equation::Coefficient, EquationCoefficientKey, HandlerCopyCast<typename Equation::Coefficient> >
         simplifiedEquation;
      int simplifiedSize = equation.count() - minSymbols + 1;
      // simplifiedEquation.bookPlaces(simplifiedSize);
      typename Equation::Cursor cursor(equation);
      while (simplifiedEquation.count() < simplifiedSize) {
         cursor.setToNext();
         simplifiedEquation.add((typename Equation::Coefficient*) &cursor.globalElementSAt());
      };
      BuiltReal limitCoefficientValue = EquationCoefficientKey::key(simplifiedEquation.getLast());
      while (cursor.setToNext()) {
         auto& coefficient = (typename Equation::Coefficient&) cursor.globalElementSAt();
         BuiltReal coefficientValue = EquationCoefficientKey::key(coefficient);
         if (coefficientValue < limitCoefficientValue) {
            simplifiedEquation.extractLast();
            simplifiedEquation.add(&coefficient);
            limitCoefficientValue = EquationCoefficientKey::key(simplifiedEquation.getLast());
         };
      };
      Equation definitionEquation;
      while (!simplifiedEquation.isEmpty()) {
         typename Equation::Coefficient& coefficient = simplifiedEquation.getSLast();
         simplifiedEquation.extractLast();
         typename Equation::Cursor targetCursor(definitionEquation);
         if (targetCursor.setToLast()) {
            while (targetCursor.elementAt() > static_cast<const Symbol&>
                  (coefficient.operator*()) && targetCursor.setToPrevious()) {}
            targetCursor.setToNext();
         };
         cursor.setToGlobalElement(coefficient);
         definitionEquation.absorbGlobalElementBefore(equation.extractAt(cursor), targetCursor);
      };
      BuiltReal min, max;
      definitionEquation.retrieveBound(min, max, false /* hasExternalCoefficient */);
      BuiltReal highLevelError;
      auto& manager = equation.symbolsManager();
      definitionEquation.divAssign(max, manager, highLevelError, false /* hasExternalCoefficient */);
      Symbol* definedSymbol = equation.symbolsManager()
            .createDefinedSymbol(typename Equation::TemplateTraits(), definitionEquation);
      max.plusAssign(highLevelError, equation.maxParams());
      equation.maxParams().clear();

      if (cursor.setToLast()) {
         while (cursor.elementAt() > *definedSymbol && cursor.setToPrevious()) {}
         cursor.setToNext();
      };
      auto* coeff = (typename Equation::Coefficient*)
            equation.addElementBefore(*definedSymbol, cursor);
      coeff->setValue(max);

      definitionEquation.notifyUpdate([this, &definitionEquation, &equation, &definedSymbol, &max, &manager]
            (Equation& source)
         {  if (!source.isDefinition() && equation.getConditionSameBranch()(source))
               source.simplifyWith(definitionEquation, *definedSymbol, max, manager, false /* hasExternalCoefficient */);
         });
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
TSimplificationRules DefineEquationTemplateParameters(URealBitsNumber)
      ::simplifySymbols(Equation& equation) const {
   typename Equation::Cursor cursor(equation);
   typename Equation::Coefficient* firstSingle = nullptr;
   while (cursor.setToNext()) {
      if (cursor.elementAt().isSingleReferenced()) {
         auto& maxParams = equation.maxParams();
         auto& minParams = equation.minParams();
         if (firstSingle == nullptr)
            firstSingle = &(typename Equation::Coefficient&) cursor.globalElementSAt();
         else {
            auto& source = (typename Equation::Coefficient&) cursor.globalElementSAt();
            auto& params = !firstSingle->getValue().isNegative() ? maxParams : minParams;
            if (firstSingle->getValue().isNegative() == source.getValue().isNegative())
               firstSingle->getSValue().plusAssign(source.getValue(), params);
            else
               firstSingle->getSValue().minusAssign(source.getValue(), params);
            params.clear();
            typename Equation::Cursor removeCursor(cursor);
            cursor.setToPrevious();
            equation.removeAt(removeCursor);
         };
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
TSimplificationRules DefineEquationTemplateParameters(URealBitsNumber)
      ::simplifyNegligeable(Equation& equation) const {
   if (equation.getLimitStartSymbolAbsorption()) {
      BuiltReal referenceForAbsorption;
      equation.computeReferenceForAbsorption(referenceForAbsorption);
      BuiltReal minReferenceForAbsorption(referenceForAbsorption);
      minReferenceForAbsorption.opposite();
      auto& maxParams = equation.maxParams();
      auto& minParams = equation.minParams();
      typename Equation::Cursor cursor(equation);
      typename Equation::Coefficient* firstNegligeable = nullptr;
      while (cursor.setToNext()) {
         auto& coefficient = (typename Equation::Coefficient&) cursor.globalElementSAt();
         if (!coefficient.getValue().isNegative()
               ? (coefficient.getValue() < referenceForAbsorption)
               : (coefficient.getValue() > minReferenceForAbsorption)) {
            if (firstNegligeable == nullptr)
               firstNegligeable = &(typename Equation::Coefficient&) cursor.globalElementSAt();
            else {
               const auto& source = (const typename Equation::Coefficient&) cursor.globalElementSAt();
               auto& params = !firstNegligeable->getValue().isNegative() ? maxParams : minParams;
               if (firstNegligeable->getValue().isNegative() == source.getValue().isNegative())
                  firstNegligeable->getSValue().plusAssign(source.getValue(), params);
               else
                  firstNegligeable->getSValue().minusAssign(source.getValue(), params);
               params.clear();
               typename Equation::Cursor removeCursor(cursor);
               cursor.setToPrevious();
               equation.removeAt(removeCursor);
            };
         };
      };
      if (firstNegligeable) {
         cursor.setToGlobalElement(*firstNegligeable);
         BuiltReal newValue = firstNegligeable->getValue();
         equation.removeAt(cursor);
         Symbol* newSymbol = equation.symbolsManager().createNoiseSymbol();
         if (cursor.setToLast())
            while (cursor.elementAt() > *newSymbol && cursor.setToPrevious());
         auto* coeff = (typename Equation::Coefficient*) equation.addElementAfter(*newSymbol, cursor);
         coeff->setValue(newValue);
      };
   };
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::computeRelativeError() {
   Equation relativeError(getError());
   if (relativeError.divAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager())) {
      BuiltReal min, max;
      relativeError.retrieveBound(min, max, false /* hasExternalCoefficient */);
      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = min.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = min.getBasicExponent()[index];
      conversion.setNegative(min.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      bfMinRelativeError.setFloat(conversion, minParams);
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = max.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = max.getBasicExponent()[index];
      conversion.setNegative(max.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      bfMaxRelativeError.setFloat(conversion, maxParams);
      maxParams.clear();
   }
   else {
      bfMinRelativeError.setMinusInfty();
      bfMaxRelativeError.setPlusInfty();
   };
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::computeImplementation() {
   Equation implementation(getRealDomain());
   implementation.plusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
   BuiltReal extendedMin, extendedMax;
   implementation.retrieveBound(extendedMin, extendedMax, false /* hasExternalCoefficient */);
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
   int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = extendedMin.getMantissa()[index];
   int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = extendedMin.getBasicExponent()[index];
   conversion.setNegative(extendedMin.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   bfMin.setFloat(conversion, maxParams);
   maxParams.clear();
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = extendedMax.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = extendedMax.getBasicExponent()[index];
   conversion.setNegative(extendedMax.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   bfMax.setFloat(conversion, minParams);
   minParams.clear();
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::computeError() {
   BuiltReal min, max;
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
   int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMin.getMantissa()[index];
   int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMin.getBasicExponent()[index];
   conversion.setNegative(bfMin.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   min.setFloat(conversion, minParams);
   minParams.clear();
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMax.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMax.getBasicExponent()[index];
   conversion.setNegative(bfMax.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   max.setFloat(conversion, maxParams);
   maxParams.clear();

   getSError().clear(&symbolsManager());
   if (max == min)
      getSError().setCentral(max);
   else
      getSError().setInterval(min, max, symbolsManager());
   getSError().minusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::restrictImplementationFromRealAndError() {
   if (inherited::hasTopReal() || inherited::hasTopError())
      return true;
   Equation implementation(getError());
   implementation.plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
   BuiltReal extendedMin, extendedMax;
   implementation.retrieveBound(extendedMin, extendedMax, false /* hasExternalCoefficient */);
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
   int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = extendedMin.getMantissa()[index];
   int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = extendedMin.getBasicExponent()[index];
   conversion.setNegative(extendedMin.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   BuiltDouble min(conversion, maxParams);
   maxParams.clear();
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = extendedMax.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = extendedMax.getBasicExponent()[index];
   conversion.setNegative(extendedMax.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   BuiltDouble max(conversion, minParams);
   minParams.clear();
   bool hasChanged = false;
   if (min.isGreaterValue(bfMin)) {
      bfMin = min;
      hasChanged = true;
   }
   if (max.isLessValue(bfMax)) {
      bfMax = max;
      hasChanged = true;
   };
   bool result = true;
   if (hasChanged)
      result = bfMin.isLessOrEqualValue(bfMax);
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::restrictRealFromErrorAndImplementation() {
   if (inherited::hasTopError())
      return;
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
   int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMin.getMantissa()[index];
   int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMin.getBasicExponent()[index];
   conversion.setNegative(bfMin.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   BuiltReal min(conversion, minParams);
   minParams.clear();
   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMin((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMin->getSDefinition().setCentral(min);
   constraintMin->getSDefinition().minusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
   constraintMin->getSDefinition().minusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
   bool doesConstraint = false;
   BuiltReal normalization = constraintMin->getDefinition().getNormalization(true, &doesConstraint);
   if (doesConstraint && getSRealDomain().simplifyWith(constraintMin->getDefinition(),
         *constraintMin, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMin.extractElement());

   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMax.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMax.getBasicExponent()[index];
   conversion.setNegative(bfMax.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   BuiltReal max(conversion, maxParams);
   maxParams.clear();

   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMax((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMax->getSDefinition().setCentral(max);
   constraintMax->getSDefinition().minusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
   constraintMax->getSDefinition().minusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
   doesConstraint = false;
   normalization = constraintMax->getDefinition().getNormalization(false, &doesConstraint);
   if (doesConstraint && getSRealDomain().simplifyWith(constraintMax->getDefinition(),
         *constraintMax, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMax.extractElement());
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::restrictRelativeErrorFromRealAndError() {
   if (inherited::hasTopReal() || inherited::hasTopError())
      return;
   Equation relativeError(getError());
   if (relativeError.divAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager())) {
      BuiltReal min, max;
      relativeError.retrieveBound(min, max, false /* hasExternalCoefficient */);
      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(BuiltReal::BitSizeMantissa).setSizeExponent(BuiltReal::BitSizeExponent);
      int sizeMantissa = (BuiltReal::BitSizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = min.getMantissa()[index];
      int sizeExponent = (BuiltReal::BitSizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = min.getBasicExponent()[index];
      conversion.setNegative(min.isNegative());
      auto& minParams = TypeBaseFloatAffine::minParams();
      BuiltDouble relative(conversion, minParams);
      minParams.clear();
      if (bfMinRelativeError < relative)
         bfMinRelativeError = relative;
      minParams.clear();
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = max.getMantissa()[index];
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = max.getBasicExponent()[index];
      conversion.setNegative(max.isNegative());
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      relative.setFloat(conversion, maxParams);
      maxParams.clear();
      if (bfMaxRelativeError > relative)
         bfMaxRelativeError = relative;
   };
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::restrictErrorFromRealAndImplementation() {
   if (inherited::hasTopReal())
      return;
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
   int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMin.getMantissa()[index];
   int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMin.getBasicExponent()[index];
   conversion.setNegative(bfMin.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   BuiltReal min(conversion, minParams);
   minParams.clear();
   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMin((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMin->getSDefinition().setCentral(min);
   constraintMin->getSDefinition().minusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
   constraintMin->getSDefinition().minusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
   bool doesConstraint = false;
   BuiltReal normalization = constraintMin->getDefinition().getNormalization(true, &doesConstraint);
   if (doesConstraint && getSError().simplifyWith(constraintMin->getDefinition(),
         *constraintMin, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMin.extractElement());

   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMax.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMax.getBasicExponent()[index];
   conversion.setNegative(bfMax.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   BuiltReal max(conversion, maxParams);
   maxParams.clear();

   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMax((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMax->getSDefinition().setCentral(max);
   constraintMax->getSDefinition().minusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
   constraintMax->getSDefinition().minusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
   doesConstraint = false;
   normalization = constraintMax->getDefinition().getNormalization(false, &doesConstraint);
   if (doesConstraint && getSError().simplifyWith(constraintMax->getDefinition(),
         *constraintMax, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMax.extractElement());
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::restrictRealFromErrorAndRelativeError() {
   if (bfMinRelativeError.isNegative() && bfMaxRelativeError.isPositive())
      return;
   if (bfMinRelativeError.isInfty() || bfMaxRelativeError.isInfty())
      return;
   if (inherited::hasTopError())
      return;
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
   int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMinRelativeError.getMantissa()[index];
   int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMinRelativeError.getBasicExponent()[index];
   conversion.setNegative(bfMinRelativeError.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   BuiltReal minRelativeError(conversion, minParams);
   minParams.clear();
   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMin((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMin->getSDefinition() = getError();
   constraintMin->getSDefinition().divAssign(minRelativeError, symbolsManager());
   constraintMin->getSDefinition().minusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
   bool doesConstraint = false;
   BuiltReal normalization = constraintMin->getDefinition().getNormalization(minRelativeError.isNegative(),
         &doesConstraint);
   if (doesConstraint && getSRealDomain().simplifyWith(constraintMin->getDefinition(),
         *constraintMin, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMin.extractElement());

   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMaxRelativeError.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMaxRelativeError.getBasicExponent()[index];
   conversion.setNegative(bfMaxRelativeError.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   BuiltReal maxRelativeError(conversion, maxParams);
   maxParams.clear();
   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMax((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMin->getSDefinition() = getError();
   constraintMin->getSDefinition().divAssign(maxRelativeError, symbolsManager());
   constraintMax->getSDefinition().minusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
   doesConstraint = false;
   normalization = constraintMax->getDefinition().getNormalization(!minRelativeError.isNegative(),
         &doesConstraint);
   if (doesConstraint && getSRealDomain().simplifyWith(constraintMax->getDefinition(),
         *constraintMax, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMax.extractElement());
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::restrictErrorFromRealAndRelativeError() {
   if (bfMinRelativeError.isInfty() || bfMaxRelativeError.isInfty())
      return;
   if (inherited::hasTopReal())
      return;
   bool isNegativeDomain = false;
   {  BuiltReal min, max;
      getRealDomain().retrieveBound(min, max, false /* hasExternalCoefficient */);
      if (min.isNegative() && max.isPositive())
         return;
      isNegativeDomain = max.isNegative();
   }
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
   int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMinRelativeError.getMantissa()[index];
   int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMinRelativeError.getBasicExponent()[index];
   conversion.setNegative(bfMinRelativeError.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   BuiltReal minRelativeError(conversion, minParams);
   minParams.clear();
   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMin((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMin->getSDefinition() = getRealDomain();
   constraintMin->getSDefinition().multAssign(minRelativeError, symbolsManager());
   constraintMin->getSDefinition().minusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
   bool doesConstraint = false;
   BuiltReal normalization = constraintMin->getDefinition().getNormalization(!isNegativeDomain,
         &doesConstraint);
   if (doesConstraint && getSError().simplifyWith(constraintMin->getDefinition(),
         *constraintMin, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMin.extractElement());

   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMaxRelativeError.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMaxRelativeError.getBasicExponent()[index];
   conversion.setNegative(bfMaxRelativeError.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   BuiltReal maxRelativeError(conversion, maxParams);
   maxParams.clear();
   PNT::AutoPointer<DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) >
      constraintMax((DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber)*)
         symbolsManager().createUnrecordedDefinedSymbol(typename inherited::TemplateTraits()), PNT::Pointer::Init());
   constraintMax->getSDefinition() = getRealDomain();
   constraintMax->getSDefinition().multAssign(maxRelativeError, symbolsManager());
   constraintMax->getSDefinition().minusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
   doesConstraint = false;
   normalization = constraintMax->getDefinition().getNormalization(isNegativeDomain,
         &doesConstraint);
   if (doesConstraint && getSError().simplifyWith(constraintMax->getDefinition(),
         *constraintMax, normalization, symbolsManager()))
      symbolsManager().recordDefinedSymbol(typename inherited::TemplateTraits(),
            constraintMax.extractElement());
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::addSemiUlpToError(bool isBeforeValidImplementation) {
   if (!isBeforeValidImplementation && bfMin.compareValue(bfMax) == CREqual) {
      if (inherited::doesComputeError()) {
         BuiltReal implementation;
         typename BuiltReal::FloatConversion conversion;
         conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
         int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
         for (int index = 0; index < sizeMantissa; ++index)
            conversion.mantissa()[index] = bfMin.getMantissa()[index];
         int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
         for (int index = 0; index < sizeExponent; ++index)
            conversion.exponent()[index] = bfMin.getBasicExponent()[index];
         conversion.setNegative(bfMin.isNegative());
         auto& nearestParams = TypeBaseFloatAffine::nearestParams();
         implementation.setFloat(conversion, nearestParams);
         nearestParams.clear();

         if (inherited::doesComputeReal()) {
            getSError() = getSRealDomain();
            getSError().oppositeAssign();
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            getSError().getSCentral().plusAssign(implementation, nearestParams);
            BuiltReal highLevelError;
            getSError().adjustComputation(getSError().getSCentral(), highLevelError);
            getSError().addHighLevel(highLevelError, symbolsManager(), false /* hasExternalCoefficient */);
         }
         else {
            getSError().clear(&symbolsManager());
            getSError().getSCentral() = implementation;
         };
      }
      return;
   }

   BuiltReal maxError;
   BuiltReal min, max;
   if (inherited::doesComputeReal()) {
      if (inherited::doesComputeError()) {
         Equation implementation(getRealDomain());
         implementation.plusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
         implementation.retrieveBound(min, max, false /* hasExternalCoefficient */);
      }
      else
         getRealDomain().retrieveBound(min, max, false /* hasExternalCoefficient */);
   }
   else
      getError().retrieveBound(min, max, false /* hasExternalCoefficient */);

   if (min.getBasicExponent() > max.getBasicExponent())
      max = min;
   if (!max.isInftyExponent()) {
      maxError.setBasicExponent(max.getBasicExponent());
      if (maxError.getSBasicExponent().minusAssign(USizeMantissa+1).hasCarry()) {
         int shift = maxError.getSBasicExponent().neg()[0]+1;
         maxError.getSMantissa() = 1U;
         if (USizeMantissa-shift > 0)
            maxError.getSMantissa() <<= (USizeMantissa-shift);
         maxError.getSBasicExponent() = 0;
      };
      BuiltReal minError(maxError);
      minError.opposite();

      Equation additionalError;
      additionalError.setInterval(minError, maxError, symbolsManager());
      getSError().plusAssign(additionalError, Equation::PCSourceXValue, symbolsManager());
   };
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::addSemiUlp(BuiltReal& real) const {
   if (real.isInftyExponent())
      return;
   BuiltReal semiUlp;
   semiUlp.setBasicExponent(real.getBasicExponent());
   if (semiUlp.getSBasicExponent().minusAssign(USizeMantissa+1).hasCarry()) {
      int shift = semiUlp.getSBasicExponent().neg()[0]+1;
      semiUlp.getSMantissa() = 1U;
      if (USizeMantissa-shift > 0)
         semiUlp.getSMantissa() <<= (USizeMantissa-shift);
      semiUlp.getSBasicExponent() = 0;
   };
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   real.plusAssign(semiUlp, maxParams);
   maxParams.clear();
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::subSemiUlp(BuiltReal& real) const {
   if (real.isInftyExponent())
      return;
   BuiltReal semiUlp;
   semiUlp.setBasicExponent(real.getBasicExponent());
   if (semiUlp.getSBasicExponent().minusAssign(USizeMantissa+1).hasCarry()) {
      int shift = semiUlp.getSBasicExponent().neg()[0]+1;
      semiUlp.getSMantissa() = 1U;
      if (USizeMantissa-shift > 0)
         semiUlp.getSMantissa() <<= (USizeMantissa-shift);
      semiUlp.getSBasicExponent() = 0;
   };
   auto& minParams = TypeBaseFloatAffine::minParams();
   real.minusAssign(semiUlp, minParams);
   minParams.clear();
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::addSemiUlpToRelativeError() {
   BuiltDouble maxRelativeError;
   maxRelativeError.setOne();
   maxRelativeError.getSBasicExponent().minusAssign(USizeMantissa+1);
   auto& minParams = TypeBaseFloatAffine::minParams();
   bfMinRelativeError.minusAssign(maxRelativeError, minParams);
   minParams.clear();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   bfMaxRelativeError.plusAssign(maxRelativeError, maxParams);
   maxParams.clear();
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::initFrom(STG::IOObject::ISBase& in) {
   inherited::updateLocalState();

   BuiltReal real;
   auto& params = inherited::nearestParams();
   real.readDecimal(in, params);
   bool isDownApproximate = params.isDownApproximate(), isUpApproximate = params.isUpApproximate();
   params.clear();

   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(real.bitSizeMantissa()).setSizeExponent(real.bitSizeExponent());
   int sizeMantissa = (real.bitSizeMantissa() + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = real.getMantissa()[index];
   int sizeExponent = (real.bitSizeExponent() + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = real.getBasicExponent()[index];
   conversion.setNegative(real.isNegative());
   bfMin.setFloat(conversion, params);
   bfMax = bfMin;
   DAffine::DefineSetContent(dValue, bfMax, typename TypeBaseFloatAffine::FloatDigitsHelper());

   if (!isDownApproximate && !isUpApproximate)
      inherited::setCentral(real);
   else {
      BuiltReal otherReal = real;
      if (isUpApproximate) {
         otherReal.setToPrevious();
         if (TypeBaseFloatAffine::doesAbsorbHighLevel())
            inherited::setIntervalWithHighLevel(otherReal, real);
         else
            inherited::setInterval(otherReal, real);
      }
      else { // isDownApproximate
         otherReal.setToNext();
         if (TypeBaseFloatAffine::doesAbsorbHighLevel())
            inherited::setIntervalWithHighLevel(real, otherReal);
         else
            inherited::setInterval(real, otherReal);
      };
   };
   computeError();
   computeRelativeError();
   if (!inherited::doesComputeReal()) {
      getSError().plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
      getSRealDomain().clear(&symbolsManager());
   };
   if (!inherited::doesComputeError()) {
      getSError().clear(&symbolsManager());
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::initFrom(TypeImplementation value) {
   inherited::updateLocalState();
   dValue = value;
   DAffine::DefineFillContent(bfMin, value, typename TypeBaseFloatAffine::FloatDigitsHelper());
   DAffine::DefineFillContent(bfMax, value, typename TypeBaseFloatAffine::FloatDigitsHelper());
   if (value != 0 && !bfMin.isInfty()) {
      bool isApproximate;
      int limit = 4*sizeof(unsigned);
#ifdef DefineGeneric
      if (2*limit > DefineSizeofBaseTypeInBits)
         limit = DefineSizeofBaseTypeInBits/2;
#endif
      if (2*limit >= bfMin.bitSizeMantissa())
         limit = (bfMin.bitSizeMantissa()-1)/2;
      if (bfMin.bitSizeMantissa() < (int) (2*DefineSizeofBaseTypeInBits) - limit) {
         if (bfMin.bitSizeMantissa() > (int) DefineSizeofBaseTypeInBits)
            limit += (bfMin.bitSizeMantissa() - DefineSizeofBaseTypeInBits);
#ifndef DefineGeneric
         isApproximate = (bfMin.getMantissa()[0] & ~(~0U << limit)) != 0;
#else
         isApproximate = !BaseStoreTraits::isZeroValue(BaseStoreTraits
               ::getLowPart(bfMin.getMantissa()[0], limit));
#endif
      }
      else
#ifndef DefineGeneric
         isApproximate = bfMin.getMantissa()[0] != 0;
#else
         isApproximate = !BaseStoreTraits::isZeroValue(bfMin.getMantissa()[0]);
#endif

      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = bfMin.getBasicExponent()[index];
      conversion.setNegative(bfMin.isNegative());
      BuiltReal real;
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      real.setFloat(conversion, nearestParams);
      nearestParams.clear();
      if (!isApproximate)
         inherited::setCentral(real);
      else {
         BuiltReal realMax(real), realMin(real);
         int bitIndex = BuiltReal::BitSizeMantissa - USizeMantissa - 1;
         AssumeCondition(bitIndex >= 0)
         typename BuiltReal::Mantissa diffMantissa;
#ifndef DefineGeneric
         diffMantissa[bitIndex/(8*sizeof(unsigned))]
               |= 1U << (bitIndex % (8*sizeof(unsigned)));
#else
         BaseStoreTraits::setTrueBit(diffMantissa[bitIndex/(BaseStoreTraits::sizeBaseInBits())],
               bitIndex % (BaseStoreTraits::sizeBaseInBits()));
#endif
         realMax.getSMantissa().plusAssign(diffMantissa);
         if (realMin.getSMantissa().minusAssign(diffMantissa).hasCarry()) {
            if (realMin.getSBasicExponent().dec().hasCarry())
               realMin.setZero();
         };
         if (TypeBaseFloatAffine::doesAbsorbHighLevel()) {
            if (bfMin.isPositive())
               inherited::setIntervalWithHighLevel(realMin, realMax);
            else
               inherited::setIntervalWithHighLevel(realMax, realMin);
         }
         else {
            if (bfMin.isPositive())
               inherited::setInterval(realMin, realMax);
            else
               inherited::setInterval(realMax, realMin);
         };
         typename BuiltReal::Exponent errorExponent = realMax.getBasicExponent();
         if (errorExponent.minusAssign(USizeMantissa+1).hasCarry()) {
            errorExponent.neg().inc();
            int shift = errorExponent[0];
            diffMantissa <<= (USizeMantissa-1-shift);
            errorExponent = 0U;
         }
         else
            diffMantissa = 0U;
         BuiltReal errorMax;
         errorMax.getSMantissa() = diffMantissa;
         errorMax.getSBasicExponent() = errorExponent;
         BuiltReal errorMin(errorMax);
         errorMin.opposite();
         inherited::setErrorInterval(errorMin, errorMax);
         computeRelativeError();
      };
   };
   if (!inherited::doesComputeReal()) {
      getSError().plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
      getSRealDomain().clear(&symbolsManager());
   };
   if (!inherited::doesComputeError()) {
      getSError().clear(&symbolsManager());
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::initFromAtomic(TypeImplementation value) {
   inherited::updateLocalState();
   dValue = value;
   DAffine::DefineFillContent(bfMin, value, typename TypeBaseFloatAffine::FloatDigitsHelper());
   DAffine::DefineFillContent(bfMax, value, typename TypeBaseFloatAffine::FloatDigitsHelper());
   if (value != 0 && !bfMin.isInfty()) {
      typename BuiltReal::FloatConversion conversion;
      conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         conversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         conversion.exponent()[index] = bfMin.getBasicExponent()[index];
      conversion.setNegative(bfMin.isNegative());
      BuiltReal real;
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      real.setFloat(conversion, nearestParams);
      nearestParams.clear();
      inherited::setCentral(real);
   };
   if (!inherited::doesComputeReal()) {
      getSError().plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
      getSRealDomain().clear(&symbolsManager());
   };
   if (!inherited::doesComputeError()) {
      getSError().clear(&symbolsManager());
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::assumeZonotope(STG::IOObject::ISBase& in) const {
   inherited::assumeZonotope(in);
   in.assume(", i=[");
   BuiltDouble min;
   typename BuiltDouble::ReadParameters defaultParams;
   min.read(in, defaultParams);
   defaultParams.clear();
   if (!(min == bfMin))
      throw STG::EReadError();
   in.assume(',');
   BuiltDouble max;
   max.read(in, defaultParams);
   defaultParams.clear();
   if (!(max == bfMax))
      throw STG::EReadError();
   in.assume("], re=[");
   min.read(in, defaultParams);
   defaultParams.clear();
   if (!(min == bfMinRelativeError))
      throw STG::EReadError();
   in.assume(',');
   max.read(in, defaultParams);
   defaultParams.clear();
   if (!(max == bfMaxRelativeError))
      throw STG::EReadError();
   in.assume("]\n");
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::writeZonotope(STG::IOObject::OSBase& out) const {
   inherited::writeZonotope(out);
   out.writesome(", i=[");
   typename BuiltDouble::WriteParameters defaultParams;
   bfMin.write(out, defaultParams.setDecimal());
   out.put(',');
   bfMax.write(out, defaultParams);
   out.writesome("], re=[");
   bfMinRelativeError.write(out, defaultParams);
   out.put(',');
   bfMaxRelativeError.write(out, defaultParams);
   out.writesome("]\n");
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::assumeInterval(STG::IOObject::ISBase& in) const {
   inherited::assumeInterval(in);
   in.assume(", i=[");
   BuiltDouble min;
   typename BuiltDouble::ReadParameters defaultParams;
   min.read(in, defaultParams);
   defaultParams.clear();
   if (!(min == bfMin))
      throw STG::EReadError();
   in.assume(',');
   BuiltDouble max;
   max.read(in, defaultParams);
   defaultParams.clear();
   if (!(max == bfMax))
      throw STG::EReadError();
   in.assume("], re=[");
   min.read(in, defaultParams);
   defaultParams.clear();
   if (!(min == bfMinRelativeError))
      throw STG::EReadError();
   in.assume(',');
   max.read(in, defaultParams);
   defaultParams.clear();
   if (!(max == bfMaxRelativeError))
      throw STG::EReadError();
   in.assume("]\n");
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::writeInterval(STG::IOObject::OSBase& out) const {
   inherited::writeInterval(out);
   out.writesome(", i=[");
   typename BuiltDouble::WriteParameters defaultParams;
   bfMin.write(out, defaultParams.setDecimal());
   out.put(',');
   bfMax.write(out, defaultParams);
   out.writesome("], re=[");
   bfMinRelativeError.write(out, defaultParams);
   out.put(',');
   bfMaxRelativeError.write(out, defaultParams);
   out.writesome("]\n");
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::retrieveRelativeError(BuiltReal& result) const {
   const BuiltDouble* implementation = nullptr;
   if (bfMinRelativeError.isPositive())
      implementation = &bfMaxRelativeError;
   else if (bfMaxRelativeError.isNegative())
      implementation = &bfMinRelativeError;
   else { // bfMinRelativeError <= 0 <= bfMaxRelativeError
      const_cast<thisType*>(this)->bfMinRelativeError.opposite();
      if (bfMinRelativeError > bfMaxRelativeError)
         implementation = &bfMinRelativeError;
      else
         implementation = &bfMaxRelativeError;
      const_cast<thisType*>(this)->bfMinRelativeError.opposite();
   };

   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(implementation->bitSizeMantissa())
      .setSizeExponent(implementation->bitSizeExponent());
   int sizeMantissa = (implementation->bitSizeMantissa() + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = implementation->getMantissa()[index];
   int sizeExponent = (implementation->bitSizeExponent() + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = implementation->getBasicExponent()[index];
   conversion.setNegative(false);
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   result.setFloat(conversion, nearestParams);
   nearestParams.clear();
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
inline
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::DefineBasicFloatZonotope(TypeImplementation min, TypeImplementation max)
   :  dValue((min + max)/2) {
   inherited::updateLocalState();
   DAffine::DefineFillContent(bfMin, min, typename TypeBaseFloatAffine::FloatDigitsHelper());
   DAffine::DefineFillContent(bfMax, max, typename TypeBaseFloatAffine::FloatDigitsHelper());
   BuiltReal rmin, rmax;
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
   int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMin.getMantissa()[index];
   int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMin.getBasicExponent()[index];
   conversion.setNegative(bfMin.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   rmin.setFloat(conversion, minParams);
   minParams.clear();
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = bfMax.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = bfMax.getBasicExponent()[index];
   conversion.setNegative(bfMax.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   rmax.setFloat(conversion, maxParams);
   maxParams.clear();
   if (inherited::doesComputeReal())
      getSRealDomain().setInputInterval(rmin, rmax, symbolsManager());
   else
      getSError().setInputInterval(rmin, rmax, symbolsManager());
   if (!inherited::doesComputeError()) {
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::setError(TypeImplementation aerrmin, TypeImplementation aerrmax) {
   BuiltDouble errmin, errmax;
   DAffine::DefineFillContent(errmin, aerrmin, typename TypeBaseFloatAffine::FloatDigitsHelper());
   DAffine::DefineFillContent(errmax, aerrmax, typename TypeBaseFloatAffine::FloatDigitsHelper());
   BuiltReal rmin, rmax;
   typename BuiltReal::FloatConversion conversion;
   conversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
   int sizeMantissa = (USizeMantissa + 8*sizeof(unsigned) - 1)/(8*sizeof(unsigned));
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = errmin.getMantissa()[index];
   int sizeExponent = (USizeExponent + 8*sizeof(unsigned) - 1)/(8*sizeof(unsigned));
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = errmin.getBasicExponent()[index];
   conversion.setNegative(errmin.isNegative());
   auto& minParams = TypeBaseFloatAffine::minParams();
   rmin.setFloat(conversion, minParams);
   minParams.clear();
   for (int index = 0; index < sizeMantissa; ++index)
      conversion.mantissa()[index] = errmax.getMantissa()[index];
   for (int index = 0; index < sizeExponent; ++index)
      conversion.exponent()[index] = errmax.getBasicExponent()[index];
   conversion.setNegative(errmax.isNegative());
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   rmax.setFloat(conversion, maxParams);
   maxParams.clear();
   if (inherited::doesComputeError()) {
      getSError().setInterval(rmin, rmax, symbolsManager());
      computeRelativeError();
   }
   else {
      Equation newError;
      newError.setInterval(rmin, rmax, symbolsManager());
      getSError().plusAssign(newError, Equation::PCSourceXValue, symbolsManager());
   };
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
inline
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::DefineBasicFloatZonotope(int value)
   :  dValue(value) {
   inherited::updateLocalState();
   typename BuiltDouble::IntConversion conversion;
   conversion.setSigned();
   conversion.assign(value);
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   bfMin.setInteger(conversion, nearestParams);
   bfMax = bfMin;
   if (nearestParams.isApproximate()) {
      nearestParams.clear();
      typename BuiltReal::IntConversion conversion;
      conversion.setSigned();
      conversion.assign(value);
      BuiltReal value;
      value.setInteger(conversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);

      BuiltReal error;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      error.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      error.minusAssign(value, nearestParams);
      nearestParams.clear();
      getSError().setCentral(error);
      computeRelativeError();
   }
   else {
      BuiltReal value;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      value.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);
   }
   if (!inherited::doesComputeReal()) {
      getSError().plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
      getSRealDomain().clear(&symbolsManager());
   };
   if (!inherited::doesComputeError()) {
      getSError().clear(&symbolsManager());
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
inline
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::DefineBasicFloatZonotope(long int value)
   :  dValue(value) { // [TODO] to improve
   inherited::updateLocalState();
   typename BuiltDouble::IntConversion conversion;
   conversion.setSigned();
   conversion.assign((int) value);
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   bfMin.setInteger(conversion, nearestParams);
   bfMax = bfMin;
   if (nearestParams.isApproximate()) {
      nearestParams.clear();
      typename BuiltReal::IntConversion conversion;
      conversion.setSigned();
      conversion.assign((int) value);
      BuiltReal value;
      value.setInteger(conversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);

      BuiltReal error;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      error.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      error.minusAssign(value, nearestParams);
      nearestParams.clear();
      getSError().setCentral(error);
      computeRelativeError();
   }
   else {
      BuiltReal value;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      value.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);
   }

   if (!inherited::doesComputeReal()) {
      getSError().plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
      getSRealDomain().clear(&symbolsManager());
   };
   if (!inherited::doesComputeError()) {
      getSError().clear(&symbolsManager());
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
inline
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::DefineBasicFloatZonotope(unsigned value)
   :  dValue(value) {
   inherited::updateLocalState();
   typename BuiltDouble::IntConversion conversion;
   conversion.setUnsigned();
   conversion.assign(value);
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   bfMin.setInteger(conversion, nearestParams);
   bfMax = bfMin;
   if (nearestParams.isApproximate()) {
      nearestParams.clear();
      typename BuiltReal::IntConversion conversion;
      conversion.setUnsigned();
      conversion.assign(value);
      BuiltReal value;
      value.setInteger(conversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);

      BuiltReal error;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      error.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      error.minusAssign(value, nearestParams);
      nearestParams.clear();
      getSError().setCentral(error);
      computeRelativeError();
   }
   else {
      BuiltReal value;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      value.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);
   }

   if (!inherited::doesComputeReal()) {
      getSError().plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
      getSRealDomain().clear(&symbolsManager());
   };
   if (!inherited::doesComputeError()) {
      getSError().clear(&symbolsManager());
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
inline
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::DefineBasicFloatZonotope(unsigned long value)
   :  dValue(value) { // [TODO] to improve
   inherited::updateLocalState();
   typename BuiltDouble::IntConversion conversion;
   conversion.setUnsigned();
   conversion.assign((unsigned) value);
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   bfMin.setInteger(conversion, nearestParams);
   bfMax = bfMin;
   if (nearestParams.isApproximate()) {
      nearestParams.clear();
      typename BuiltReal::IntConversion conversion;
      conversion.setUnsigned();
      conversion.assign((unsigned) value);
      BuiltReal value;
      value.setInteger(conversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);

      BuiltReal error;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      error.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      error.minusAssign(value, nearestParams);
      nearestParams.clear();
      getSError().setCentral(error);
      computeRelativeError();
   }
   else {
      BuiltReal value;
      typename BuiltReal::FloatConversion floatConversion;
      floatConversion.setSizeMantissa(USizeMantissa).setSizeExponent(USizeExponent);
      int sizeMantissa = (USizeMantissa + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeMantissa; ++index)
         floatConversion.mantissa()[index] = bfMin.getMantissa()[index];
      int sizeExponent = (USizeExponent + DefineSizeofBaseTypeInBits - 1)/(DefineSizeofBaseTypeInBits);
      for (int index = 0; index < sizeExponent; ++index)
         floatConversion.exponent()[index] = bfMin.getBasicExponent()[index];
      floatConversion.setNegative(bfMin.isNegative());
      value.setFloat(floatConversion, nearestParams);
      nearestParams.clear();
      getSRealDomain().setCentral(value);
   }

   if (!inherited::doesComputeReal()) {
      getSError().plusAssign(getRealDomain(), Equation::PCSourceRValue, symbolsManager());
      getSRealDomain().clear(&symbolsManager());
   };
   if (!inherited::doesComputeError()) {
      getSError().clear(&symbolsManager());
      bfMin.clear();
      bfMax.clear();
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::operator<(const thisType& source) const {
   typename inherited::GuardStateZonotope thisGuard(*this), sourceGuard(source);
   // const_cast<thisType&>(*this).updateLocalState();
   // const_cast<thisType&>(source).updateLocalState();
   bool hasMultiple = false;
   if (!this->doesComputeError() || !source.doesComputeError()) {
      typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
      bool result = inherited::isLessThan(source, hasMultiple, dValue < source.dValue);
      if (hasMultiple) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         const_cast<thisType&>(source).updateLocalState();
         TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
      };
      return result;
   };
   if (!this->doesComputeReal() || !source.doesComputeReal()) {
      if ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))
         return false;
      if (bfMax < source.bfMin)
         return true;
      else if (bfMin >= source.bfMax)
         return false;
   }
   else {
      if (bfMax < source.bfMin) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessThan(source, hasMultiple, dValue < source.dValue,
               true /* bool doesAssumeErrorValue */, true /* errorValue */);
         if (result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
      else if ((bfMin >= source.bfMax)
            || ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessThan(source, hasMultiple, dValue < source.dValue,
               true /* bool doesAssumeErrorValue */, false /* errorValue */);
         if (!result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      };
   };

   // bfMax >= source.bfMin && bfMin < source.bfMax
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   bool result = inherited::isLessThan(source, hasMultiple, dValue < source.dValue);
   if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal) {
      if (result) {
         if (bfMax >= source.bfMax) {
            const_cast<thisType&>(*this).bfMax = source.bfMax;
            const_cast<thisType&>(*this).bfMax.setToPrevious();
         };
         if (source.bfMin <= bfMin) {
            const_cast<thisType&>(source).bfMin = bfMin;
            const_cast<thisType&>(source).bfMin.setToNext();
         };
      }
      else {
         if (bfMax < source.bfMax)
            const_cast<thisType&>(source).bfMax = bfMax;
         if (source.bfMin > bfMin)
            const_cast<thisType&>(*this).bfMin = source.bfMin;                    
      }
   };
   if (hasMultiple) {
      bool isUnstable = mode != inherited::getMode();
      if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal
            && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
      if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
      TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
      const_cast<thisType&>(source).updateLocalState();
      TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
   };
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::operator<=(const thisType& source) const {
   typename inherited::GuardStateZonotope thisGuard(*this), sourceGuard(source);
   // const_cast<thisType&>(*this).updateLocalState();
   // const_cast<thisType&>(source).updateLocalState();
   bool hasMultiple = false;
   if (!this->doesComputeError() || !source.doesComputeError()) {
      typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
      bool result = inherited::isLessOrEqualThan(source, hasMultiple, dValue <= source.dValue);
      if (hasMultiple) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         const_cast<thisType&>(source).updateLocalState();
         TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
      };
      return result;
   };
   if (!this->doesComputeReal() || !source.doesComputeReal()) {
      if ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))
         return false;
      if (bfMax <= source.bfMin)
         return true;
      else if (bfMin > source.bfMax)
         return false;
   }
   else {
      if (bfMax <= source.bfMin) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessOrEqualThan(source, hasMultiple, dValue <= source.dValue,
               true /* bool doesAssumeErrorValue */, true /* errorValue */);
         if (result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
      else if ((bfMin > source.bfMax)
            || ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessOrEqualThan(source, hasMultiple, dValue <= source.dValue,
               true /* bool doesAssumeErrorValue */, false /* errorValue */);
         if (!result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      };
   };

   // bfMax >= source.bfMin && bfMin < source.bfMax
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   bool result = inherited::isLessOrEqualThan(source, hasMultiple, dValue <= source.dValue);
   if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal) {
      if (result) {
         if (bfMax > source.bfMax)
            const_cast<thisType&>(*this).bfMax = source.bfMax;
         if (source.bfMin < bfMin)
            const_cast<thisType&>(source).bfMin = bfMin;
      }
      else {
         if (bfMax <= source.bfMax) {
            const_cast<thisType&>(source).bfMax = bfMax;
            const_cast<thisType&>(source).bfMax.setToPrevious();
         };
         if (source.bfMin >= bfMin) {
            const_cast<thisType&>(*this).bfMin = source.bfMin;                    
            const_cast<thisType&>(*this).bfMin.setToNext();
         };
      }
   };
   if (hasMultiple) {
      bool isUnstable = mode != inherited::getMode();
      if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal
            && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
      if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
      TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
      const_cast<thisType&>(source).updateLocalState();
      TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
   };
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::operator==(const thisType& source) const {
   typename inherited::GuardStateZonotope thisGuard(*this), sourceGuard(source);
   // const_cast<thisType&>(*this).updateLocalState();
   // const_cast<thisType&>(source).updateLocalState();
   bool hasMultipleLess = false, hasMultipleGreater = false;
   if (!this->doesComputeError() || !source.doesComputeError()) {
      typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
      bool result = inherited::isLessOrEqualThan(source, hasMultipleLess, dValue <= source.dValue)
            && inherited::isGreaterOrEqualThan(source, hasMultipleGreater, dValue >= source.dValue);
      if (hasMultipleLess || hasMultipleGreater) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         const_cast<thisType&>(source).updateLocalState();
         TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
      };
      return result;
   };
   if (!this->doesComputeReal() || !source.doesComputeReal()) {
      if ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))
         return false;
      else if (bfMax < source.bfMin)
         return false;
      else if (bfMin > source.bfMax)
         return false;
      else if (bfMin == source.bfMax && bfMax == source.bfMin)
         return true;
   }
   else {
      if ((bfMax < source.bfMin || bfMin > source.bfMax)
           || ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessOrEqualThan(source, hasMultipleLess, dValue <= source.dValue,
               true /* bool doesAssumeErrorValue */, (bfMax < source.bfMin) /* errorValue */)
            && inherited::isGreaterOrEqualThan(source, hasMultipleGreater, dValue >= source.dValue,
               true /* bool doesAssumeErrorValue */, (bfMin > source.bfMax) /* errorValue */);
         if (!result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultipleLess || hasMultipleGreater) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
      else if (bfMin == source.bfMax && bfMax == source.bfMin) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessOrEqualThan(source, hasMultipleLess, dValue <= source.dValue,
               true /* bool doesAssumeErrorValue */, true /* errorValue */)
            && inherited::isGreaterOrEqualThan(source, hasMultipleGreater, dValue >= source.dValue,
               true /* bool doesAssumeErrorValue */, true /* errorValue */);
         if (result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultipleLess || hasMultipleGreater) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
   };
   // bfMax >= source.bfMin && bfMin <= source.bfMax
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   bool result = inherited::isLessOrEqualThan(source, hasMultipleLess, dValue <= source.dValue)
         && inherited::isGreaterOrEqualThan(source, hasMultipleGreater, dValue >= source.dValue);
   if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal) {
      if (result) {
         if (bfMin < source.bfMin)
            const_cast<thisType&>(*this).bfMin = source.bfMin;
         else if (source.bfMin < bfMin)
            const_cast<thisType&>(source).bfMin = bfMin;
         if (bfMax > source.bfMax)
            const_cast<thisType&>(*this).bfMax = source.bfMax;
         else if (source.bfMax > bfMax)
            const_cast<thisType&>(source).bfMax = bfMax;
      };
   };
   if (hasMultipleLess || hasMultipleGreater) {
      bool isUnstable = mode != inherited::getMode();
      if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal
            && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
      if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
      TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
      const_cast<thisType&>(source).updateLocalState();
      TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
   };
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::operator!=(const thisType& source) const {
   typename inherited::GuardStateZonotope thisGuard(*this), sourceGuard(source);
   // const_cast<thisType&>(*this).updateLocalState();
   // const_cast<thisType&>(source).updateLocalState();
   bool hasMultipleLess = false, hasMultipleGreater = false;
   if (!this->doesComputeError() || !source.doesComputeError()) {
      typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
      bool result = inherited::isLessThan(source, hasMultipleLess, dValue < source.dValue)
            || inherited::isGreaterThan(source, hasMultipleGreater, dValue > source.dValue);
      if (hasMultipleLess || hasMultipleGreater) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         const_cast<thisType&>(source).updateLocalState();
         TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
      };
      return result;
   };
   if (!this->doesComputeReal() || !source.doesComputeReal()) {
      if ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))
         return false;
      else if (bfMax < source.bfMin)
         return true;
      else if (bfMin > source.bfMax)
         return true;
      else if (bfMin == source.bfMax && bfMax == source.bfMin)
         return false;
   }
   else {
      if (bfMax < source.bfMin || bfMin > source.bfMax) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessThan(source, hasMultipleLess, dValue < source.dValue,
               true /* bool doesAssumeErrorValue */, (bfMax < source.bfMin) /* errorValue */)
            || inherited::isGreaterThan(source, hasMultipleGreater, dValue > source.dValue,
               true /* bool doesAssumeErrorValue */, (bfMin > source.bfMax) /* errorValue */);
         if (result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultipleLess || hasMultipleGreater) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
      else if ((bfMin == source.bfMax && bfMax == source.bfMin)
           || ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isLessThan(source, hasMultipleLess, dValue < source.dValue,
                  true /* bool doesAssumeErrorValue */, false /* errorValue */)
               || inherited::isGreaterThan(source, hasMultipleGreater, dValue > source.dValue,
                  true /* bool doesAssumeErrorValue */, false /* errorValue */);
         if (!result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultipleLess || hasMultipleGreater) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
   };
   // bfMax >= source.bfMin && bfMin <= source.bfMax
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   bool result = inherited::isLessThan(source, hasMultipleLess, dValue < source.dValue)
         || inherited::isGreaterThan(source, hasMultipleGreater, dValue > source.dValue);
   if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal) {
      if (!result) {
         if (bfMin < source.bfMin)
            const_cast<thisType&>(*this).bfMin = source.bfMin;
         else if (source.bfMin < bfMin)
            const_cast<thisType&>(source).bfMin = bfMin;
         if (bfMax > source.bfMax)
            const_cast<thisType&>(*this).bfMax = source.bfMax;
         else if (source.bfMax > bfMax)
            const_cast<thisType&>(source).bfMax = bfMax;
      };
   };
   if (hasMultipleLess || hasMultipleGreater) {
      bool isUnstable = mode != inherited::getMode();
      if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal
            && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
      if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
      TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
      const_cast<thisType&>(source).updateLocalState();
      TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
   };
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::operator>=(const thisType& source) const {
   typename inherited::GuardStateZonotope thisGuard(*this), sourceGuard(source);
   // const_cast<thisType&>(*this).updateLocalState();
   // const_cast<thisType&>(source).updateLocalState();
   bool hasMultiple = false;
   if (!this->doesComputeError() || !source.doesComputeError()) {
      typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
      bool result = inherited::isGreaterOrEqualThan(source, hasMultiple, dValue >= source.dValue);
      if (hasMultiple) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         const_cast<thisType&>(source).updateLocalState();
         TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
      };
      return result;
   };
   if (!this->doesComputeReal() || !source.doesComputeReal()) {
      if ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))
         return false;
      else if (bfMax < source.bfMin)
         return false;
      else if (bfMin >= source.bfMax)
         return true;
   }
   else {
      if ((bfMax < source.bfMin)
            || ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isGreaterOrEqualThan(source, hasMultiple, dValue >= source.dValue,
               true /* bool doesAssumeErrorValue */, false /* errorValue */);
         if (!result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
      else if (bfMin >= source.bfMax) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isGreaterOrEqualThan(source, hasMultiple, dValue >= source.dValue,
               true /* bool doesAssumeErrorValue */, true /* errorValue */);
         if (result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      };
   };

   // bfMax >= source.bfMin && bfMin < source.bfMax
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   bool result = inherited::isGreaterOrEqualThan(source, hasMultiple, dValue >= source.dValue);
   if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal) {
      if (result) {
         if (bfMax < source.bfMax)
            const_cast<thisType&>(source).bfMax = bfMax;
         if (source.bfMin > bfMin)
            const_cast<thisType&>(*this).bfMin = source.bfMin;                    
      }
      else {
         if (bfMax >= source.bfMax) {
            const_cast<thisType&>(*this).bfMax = source.bfMax;
            const_cast<thisType&>(*this).bfMax.setToPrevious();
         };
         if (source.bfMin <= bfMin) {
            const_cast<thisType&>(source).bfMin = bfMin;
            const_cast<thisType&>(source).bfMin.setToNext();
         };
      }
   };
   if (hasMultiple) {
      bool isUnstable = mode != inherited::getMode();
      if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal
            && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
      if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
      TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
      const_cast<thisType&>(source).updateLocalState();
      TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
   };
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::operator>(const thisType& source) const {
   typename inherited::GuardStateZonotope thisGuard(*this), sourceGuard(source);
   // const_cast<thisType&>(*this).updateLocalState();
   // const_cast<thisType&>(source).updateLocalState();
   bool hasMultiple = false;
   if (!this->doesComputeError() || !source.doesComputeError()) {
      typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
      bool result = inherited::isGreaterThan(source, hasMultiple, dValue > source.dValue);
      if (hasMultiple) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         const_cast<thisType&>(source).updateLocalState();
         TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
      };
      return result;
   };
   if (!this->doesComputeReal() || !source.doesComputeReal()) {
      if ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))
         return false;
      else if (bfMax <= source.bfMin)
         return false;
      else if (bfMin > source.bfMax)
         return true;
   }
   else {
      if ((bfMax <= source.bfMin)
            || ((bfMin.isNaN() && bfMax.isNaN()) || (source.bfMin.isNaN() && source.bfMax.isNaN()))) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isGreaterThan(source, hasMultiple, dValue > source.dValue,
               true /* bool doesAssumeErrorValue */, false /* errorValue */);
         if (!result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      }
      else if (bfMin > source.bfMax) {
         typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
         bool result = inherited::isGreaterThan(source, hasMultiple, dValue > source.dValue,
               true /* bool doesAssumeErrorValue */, true /* errorValue */);
         if (result && this->doesComputeReal() && this->doesComputeError())
            const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
         if (hasMultiple) {
            bool isUnstable = mode != inherited::getMode();
            TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
            const_cast<thisType&>(source).updateLocalState();
            TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
         };
         return result;
      };
   };

   // bfMax >= source.bfMin && bfMin < source.bfMax
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   bool result = inherited::isGreaterThan(source, hasMultiple, dValue > source.dValue);
   if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal) {
      if (result) {
         if (bfMax <= source.bfMax) {
            const_cast<thisType&>(source).bfMax = bfMax;
            const_cast<thisType&>(source).bfMax.setToPrevious();
         };
         if (source.bfMin >= bfMin) {
            const_cast<thisType&>(*this).bfMin = source.bfMin;                    
            const_cast<thisType&>(*this).bfMin.setToNext();
         };
      }
      else {
         if (bfMax > source.bfMax)
            const_cast<thisType&>(*this).bfMax = source.bfMax;
         if (source.bfMin < bfMin)
            const_cast<thisType&>(source).bfMin = bfMin;
      }
   };
   if (hasMultiple) {
      bool isUnstable = mode != inherited::getMode();
      if (TypeBaseFloatAffine::getMode() != TypeBaseFloatAffine::MOnlyReal
            && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
      if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
      TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
      const_cast<thisType&>(source).updateLocalState();
      TypeBaseFloatAffine::notifyForBranchCompare(source, isUnstable);
   };
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::plusAssign(const thisType& source, typename Equation::PolicyCall policyCall) {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this << source) >> *this;
   bool isApproximate = !this->isZero() && !source.isZero();
   inherited::plusAssign(source, policyCall);
   dValue += source.dValue;
   if (!this->hasNoError() && !source.hasNoError()) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      bfMin.plusAssign(source.bfMin, nearestParams);
      nearestParams.clear();
      bfMax.plusAssign(source.bfMax, nearestParams);
      nearestParams.clear();
      if (this->doesComputeError()) {
         if (isApproximate)
            addSemiUlpToError();
         restrictImplementationFromRealAndError();
         computeRelativeError();
      };
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::minusAssign(const thisType& source, typename Equation::PolicyCall policyCall) {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this << source) >> *this;
   bool isApproximate = !this->isZero() && !source.isZero();
   inherited::minusAssign(source, policyCall);
   dValue -= source.dValue;
   if (!this->hasNoError() && !source.hasNoError()) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      bfMin.minusAssign(source.bfMax, nearestParams);
      nearestParams.clear();
      bfMax.minusAssign(source.bfMin, nearestParams);
      nearestParams.clear();
      if (this->doesComputeError()) {
         if (isApproximate)
            addSemiUlpToError();
         restrictImplementationFromRealAndError();
         computeRelativeError();
      };
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::multAssign(const thisType& source, typename Equation::PolicyCall policyCall) {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this << source) >> *this;
   bool isApproximate = !this->isZero() && !source.isZero()
      && !this->isTwoPower() && !source.isTwoPower();
   inherited::multAssign(source, policyCall);
   dValue *= source.dValue;
   if (!this->hasNoError() && !source.hasNoError()) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      if (bfMin.isPositive() || bfMin.isZero()) {
         if (source.bfMin.isPositive() || source.bfMin.isZero()) {
            bfMin.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
         }
         else if (source.bfMax.isNegative() || source.bfMax.isZero()) {
            bfMin.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMin.swap(bfMax);
         }
         else { // bfMin.isPositive() && source.bfMin.isNegative() && source.bfMax.isPositive()
            bfMin = bfMax;
            bfMin.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
         };
      }
      else if (bfMax.isNegative() || bfMax.isZero()) {
         if (source.bfMin.isPositive() || source.bfMin.isZero()) {
            bfMin.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
         }
         else if (source.bfMax.isNegative() || source.bfMax.isZero()) {
            bfMin.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMin.swap(bfMax);
         }
         else { // bfMin.isNegative() && source.bfMin.isNegative() && source.bfMax.isPositive()
            bfMax = bfMin;
            bfMin.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMin.swap(bfMax);
         };
      }
      else { // bfMin.isNegative() && bfMax.isPositive()
         if (source.bfMin.isPositive() || source.bfMin.isZero()) {
            bfMin.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
         }
         else if (source.bfMax.isNegative() || source.bfMax.isZero()) {
            bfMin.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMin.swap(bfMax);
         }
         else { // bfMin.isNegative() && bfMax.isPositive() && source.bfMin.isNegative() && source.bfMax.isPositive()
            BuiltDouble min(bfMin), max(bfMin);
            min.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            BuiltDouble min2 = bfMax;
            min2.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            if (min2 < min)
               min = min2;
            max.multAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            BuiltDouble max2 = bfMax;
            max2.multAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            if (max2 > max)
               max = max2;
            bfMin = min;
            bfMax = max;
         };
      }

      auto& maxParams = TypeBaseFloatAffine::maxParams();
      auto& minParams = TypeBaseFloatAffine::minParams();
      BuiltDouble additionalMin(bfMinRelativeError), additionalMax(bfMaxRelativeError);
      if (additionalMin.isPositive() || additionalMin.isZero()) {
         if (source.bfMinRelativeError.isPositive() || source.bfMinRelativeError.isZero()) {
            additionalMin.multAssign(source.bfMinRelativeError, minParams);
            minParams.clear();
            additionalMax.multAssign(source.bfMaxRelativeError, maxParams);
            maxParams.clear();
         }
         else if (source.bfMaxRelativeError.isNegative() || source.bfMaxRelativeError.isZero()) {
            additionalMin.multAssign(source.bfMaxRelativeError, maxParams);
            maxParams.clear();
            additionalMin.multAssign(source.bfMinRelativeError, minParams);
            minParams.clear();
            additionalMin.swap(additionalMax);
         }
         else { // additionalMin.isPositive() && source.bfMinRelativeError.isNegative() && source.bfMaxRelativeError.isPositive()
            additionalMin = additionalMax;
            additionalMin.multAssign(source.bfMinRelativeError, minParams);
            minParams.clear();
            additionalMax.multAssign(source.bfMaxRelativeError, maxParams);
            maxParams.clear();
         };
      }
      else if (additionalMax.isNegative() || additionalMax.isZero()) {
         if (source.bfMinRelativeError.isPositive() || source.bfMinRelativeError.isZero()) {
            additionalMin.multAssign(source.bfMaxRelativeError, minParams);
            minParams.clear();
            additionalMax.multAssign(source.bfMinRelativeError, maxParams);
            maxParams.clear();
         }
         else if (source.bfMaxRelativeError.isNegative() || source.bfMaxRelativeError.isZero()) {
            additionalMin.multAssign(source.bfMinRelativeError, maxParams);
            maxParams.clear();
            additionalMax.multAssign(source.bfMaxRelativeError, minParams);
            minParams.clear();
            additionalMin.swap(additionalMax);
         }
         else { // bfMinRelativeError.isNegative() && source.bfMinRelativeError.isNegative() && source.bfMaxRelativeError.isPositive()
            additionalMax = additionalMin;
            additionalMin.multAssign(source.bfMinRelativeError, maxParams);
            maxParams.clear();
            additionalMax.multAssign(source.bfMaxRelativeError, minParams);
            minParams.clear();
            additionalMin.swap(additionalMax);
         };
      }
      else { // additionalMin.isNegative() && additionalMax.isPositive()
         if (source.bfMinRelativeError.isPositive() || source.bfMinRelativeError.isZero()) {
            additionalMin.multAssign(source.bfMaxRelativeError, minParams);
            minParams.clear();
            additionalMax.multAssign(source.bfMaxRelativeError, maxParams);
            maxParams.clear();
         }
         else if (source.bfMaxRelativeError.isNegative() || source.bfMaxRelativeError.isZero()) {
            additionalMin.multAssign(source.bfMinRelativeError, maxParams);
            maxParams.clear();
            additionalMax.multAssign(source.bfMinRelativeError, minParams);
            minParams.clear();
            additionalMin.swap(additionalMax);
         }
         else { // additionalMin.isNegative() && additionalMax.isPositive() && source.bfMinRelativeError.isNegative() && source.bfMaxRelativeError.isPositive()
            BuiltDouble min(additionalMin), max(additionalMin);
            min.multAssign(source.bfMaxRelativeError, minParams);
            minParams.clear();
            BuiltDouble min2 = additionalMax;
            min2.multAssign(source.bfMinRelativeError, minParams);
            minParams.clear();
            if (min2 < min)
               min = min2;
            max.multAssign(source.bfMinRelativeError, maxParams);
            maxParams.clear();
            BuiltDouble max2 = additionalMax;
            max2.multAssign(source.bfMaxRelativeError, maxParams);
            maxParams.clear();
            if (max2 > max)
               max = max2;
            additionalMin = min;
            additionalMax = max;
         };
      }
      bfMinRelativeError.plusAssign(source.bfMinRelativeError, minParams);
      minParams.clear();
      bfMinRelativeError.plusAssign(additionalMin, minParams);
      minParams.clear();
      bfMaxRelativeError.plusAssign(source.bfMaxRelativeError, maxParams);
      maxParams.clear();
      bfMaxRelativeError.plusAssign(additionalMax, maxParams);
      maxParams.clear();
      if (isApproximate)
         addSemiUlpToRelativeError();
      if (this->doesComputeError()) {
         if (isApproximate)
            addSemiUlpToError();
         restrictImplementationFromRealAndError();
         if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
            if (!TypeBaseFloatAffine::isPureZonotope()) {
               restrictErrorFromRealAndImplementation();
               restrictRealFromErrorAndImplementation();
            };
            restrictRelativeErrorFromRealAndError();
         };
      };
   };

   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::divAssign(const thisType& source, typename Equation::PolicyCall policyCall) {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this << source) >> *this;
   bool isApproximate = !this->isZero() && !source.isTwoPower();
   inherited::divAssign(source, policyCall);
   dValue /= source.dValue;
   if (!this->hasNoError() && !source.hasNoError()) {
      if (bfMin.isPositive() || bfMin.isZero()) {
         if (source.bfMin.isPositive() || source.bfMin.isZero()) {
            if (source.bfMin.isZero()) // [TODO] should be in FloatZonotope::operator/=
               TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            bfMin.divAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMax.divAssign(source.bfMin, nearestParams);
            nearestParams.clear();
         }
         else if (source.bfMax.isNegative() || source.bfMax.isZero()) {
            if (source.bfMax.isZero()) // [TODO] should be in FloatZonotope::operator/=
               TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            bfMin.divAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.divAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMin.swap(bfMax);
         }
         else { // bfMin.isPositive() && source.bfMin.isNegative() && source.bfMax.isPositive()
            // [TODO] should be in FloatZonotope::operator/=
            TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            bfMin.setInfty();
            bfMin.setNegative();
            bfMax.setInfty();
         };
      }
      else if (bfMax.isNegative() || bfMax.isZero()) {
         if (source.bfMin.isPositive() || source.bfMin.isZero()) {
            if (source.bfMin.isZero()) // [TODO] should be in FloatZonotope::operator/=
               TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            bfMin.divAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.divAssign(source.bfMax, nearestParams);
            nearestParams.clear();
         }
         else if (source.bfMax.isNegative() || source.bfMax.isZero()) {
            if (source.bfMax.isZero()) // [TODO] should be in FloatZonotope::operator/=
               TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            bfMin.divAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMax.divAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMin.swap(bfMax);
         }
         else { // bfMin.isNegative() && source.bfMin.isNegative() && source.bfMax.isPositive()
            // [TODO] should be in FloatZonotope::operator/=
            TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            bfMin.setInfty();
            bfMin.setNegative();
            bfMax.setInfty();
         };
      }
      else { // bfMin.isNegative() && bfMax.isPositive()
         if (source.bfMin.isPositive() || source.bfMin.isZero()) {
            if (source.bfMin.isZero()) // [TODO] should be in FloatZonotope::operator/=
               TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            bfMin.divAssign(source.bfMin, nearestParams);
            nearestParams.clear();
            bfMax.divAssign(source.bfMin, nearestParams);
            nearestParams.clear();
         }
         else if (source.bfMax.isNegative() || source.bfMax.isZero()) {
            if (source.bfMax.isZero()) // [TODO] should be in FloatZonotope::operator/=
               TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            bfMin.divAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMax.divAssign(source.bfMax, nearestParams);
            nearestParams.clear();
            bfMin.swap(bfMax);
         }
         else { // bfMin.isNegative() && bfMax.isPositive() && source.bfMin.isNegative() && source.bfMax.isPositive()
            // [TODO] should be in FloatZonotope::operator/=
            TypeBaseFloatAffine::notifyForDivisionByZero(*this);
            bfMin.setInfty();
            bfMin.setNegative();
            bfMax.setInfty();
         };
      }

      if (this->doesComputeError()) {
         // [TODO] implement the formula for the relative error
         if (isApproximate)
            addSemiUlpToError();
         restrictImplementationFromRealAndError();
         if (!TypeBaseFloatAffine::isPureZonotope()
               && TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation) {
            restrictErrorFromRealAndImplementation();
            restrictRealFromErrorAndImplementation();
         };
         computeRelativeError();
      };
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

// error = implementation-real
// implementationResult < result
// roundMode == RMZero
//    => implementationResult > 0
//       // result <= real <= result+1
//       // implementationResult <= implementation < implementationResult+1
//       // so implementationResult+1-result > error >= implementationResult-(result+1)
//       // so implementationResult+1-error > real >= implementationResult-error
//    => result < 0
//       // result-1 <= real <= result
//       // implementationResult-1 < implementation <= implementationResult
//       // so implementationResult-(result-1) >= error > implementationResult-1-result
//       // so implementationResult-error >= real > implementationResult-1-error
//    => implementationResult = 0 < result
//       // result <= real <= result+1
//       // implementationResult-1 < implementation < implementationResult+1
//       // so implementationResult+1-result > error > -1+implementationResult-(result+1)
//       // so implementationResult+1-error > real > implementationResult-1-error
//    => implementationResult < 0 = result
//       // result-1 <= real <= result+1
//       // implementationResult-1 < implementation <= implementationResult
//       // so implementationResult-(result-1) >= error > -1+implementationResult-(result+1)
//       // so implementationResult-error >= real > implementationResult-1-error
//    => implementationResult < 0 < result
//       // result <= real <= result+1
//       // implementationResult-1 < implementation <= implementationResult
//       // so implementationResult-result >= error > -1+implementationResult-(result+1)
//       // so implementationResult-error >= real > implementationResult-1-error
// roundMode == RMNearest
//    // result-0.5 <= real < result+0.5
//    // implementationResult-0.5 <= implementation <= implementationResult+0.5
//    // so implementationResult+0.5-(result-0.5) >= error >= implementationResult-0.5-(result+0.5)
//    // so implementationResult+0.5-error >= real >= implementationResult-0.5-error
// roundMode == RMLowest
//    // result <= real <= result+1
//    // implementationResult <= implementation < implementationResult+1
//    // so implementationResult+1-result > error >= implementationResult-(result+1)
//    // so implementationResult+1-error > real >= implementationResult-error
//    semiUlpNumber = 2;
// roundMode == RMHighest
//    // result-1 <= real <= result
//    // implementationResult-1 < implementation <= implementationResult
//    // so implementationResult-(result-1) >= error > implementationResult-1-result
//    // so implementationResult-error >= real > implementationResult-1-error
// implementationResult > result
// roundMode == RMZero
//    => result > 0
//       // result <= real <= result+1
//       // implementationResult <= implementation < implementationResult+1
//       // so implementationResult+1-result > error >= implementationResult-(result+1)
//       // so implementationResult+1-error > real >= implementationResult-error
//    => implementationResult < 0
//       // result-1 <= real <= result
//       // implementationResult-1 < implementation <= implementationResult
//       // so implementationResult-(result-1) >= error > implementationResult-1-result
//       // so implementationResult-error >= real > implementationResult-1-error
//    => result = 0 < implementationResult
//       // result-1 <= real <= result+1
//       // implementationResult <= implementation < implementationResult+1
//       // so implementationResult+1-(result-1) > error >= implementationResult-(result+1)
//       // so implementationResult+1-error > real >= implementationResult-error
//    => result < 0 = implementationResult
//       // result-1 <= real <= result
//       // implementationResult-1 < implementation < implementationResult+1
//       // so implementationResult+1-(result-1) > error > -1+implementationResult-result
//       // so implementationResult+1-error > real > implementationResult-1-error
//    => result < 0 < implementationResult
//       // result-1 <= real <= result
//       // implementationResult <= implementation < implementationResult+1
//       // so implementationResult+1-(result-1) >= error >= implementationResult-result
//       // so implementationResult+1-error > real >= implementationResult-error
// roundMode == RMNearest
//    // result-0.5 <= real < result+0.5
//    // implementationResult-0.5 <= implementation <= implementationResult+0.5
//    // so implementationResult+0.5-(result-0.5) >= error >= implementationResult-0.5-(result+0.5)
//    // so implementationResult+0.5-error >= real >= implementationResult-0.5-error
// roundMode == RMLowest
//    // result <= real <= result+1
//    // implementationResult <= implementation < implementationResult+1
//    // so implementationResult+1-result > error >= implementationResult-(result+1)
//    // so implementationResult+1-error > real >= implementationResult-error
//    semiUlpNumber = 2;
// roundMode == RMHighest
//    // result-1 <= real <= result
//    // implementationResult-1 < implementation <= implementationResult
//    // so implementationResult-(result-1) >= error > implementationResult-1-result
//    // so implementationResult-error >= real > implementationResult-1-error

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::optimizeUnstableConversionForRealFlow(unsigned result, unsigned implementationResult,
            signed signedResult, int signedImplementationResult,
            bool isSigned, bool hasMultiple, typename TypeBaseFloatAffine::Mode mode,
            Numerics::DDouble::Access::ReadParameters& minParams,
            Numerics::DDouble::Access::ReadParameters& maxParams,
            ReadParametersBase::RoundMode roundMode) const {
   BuiltReal errorMin, errorMax;
   getError().retrieveBound(errorMin, errorMax, false /* hasExternalCoefficient */);

   if (isSigned ? (signedImplementationResult < signedResult)
                : (implementationResult < result)) {
      bool isStrictGreater = false;
      int unitSub = 1;
      if (roundMode == ReadParametersBase::RMZero
            && (isSigned && (signedImplementationResult < 0) && (0 < signedResult)))
         unitSub = 0;
      if ((roundMode == ReadParametersBase::RMZero
               && (!isSigned || (signedImplementationResult >= 0)))
            || roundMode == ReadParametersBase::RMLowest)
         isStrictGreater = true;

      typename BuiltReal::IntConversion conversion;
      if (isSigned) {
         conversion.setSigned();
         conversion.assign((int) (signedResult-signedImplementationResult-unitSub));
      }
      else {
         conversion.setUnsigned();
         conversion.assign((unsigned) (result-implementationResult-unitSub));
      };
      BuiltReal errorBound;
      errorBound.setInteger(conversion, maxParams);
      maxParams.clear();
      errorBound.opposite(); // = implementation-result+1
      // if (isStrictGreater)
      //    errorBound.setToNext();

      if (isStrictGreater ? (errorMin >= errorBound) : (errorMin > errorBound)) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         return false;
      };
      Equation constraintError(getError());
      if (isStrictGreater ? (errorMax >= errorBound) : (errorMax > errorBound)) {
         constraintError.getSCentral().minusAssign(errorBound, minParams);
         minParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
            .createDefinedSymbol(typename inherited::TemplateTraits(), constraintError);
         bool hasAllSimplified = hasMultiple
            ? constraintError.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintError.simplifyAllEquations(*constrainedSymbol, true, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintError, true);
      };

      // getSRealDomain() <= implementation+1-error
      if (roundMode == ReadParametersBase::RMZero)
         isStrictGreater = !isSigned || (signedImplementationResult >= 0);
      else
         isStrictGreater = (roundMode == ReadParametersBase::RMLowest);
      unitSub = isStrictGreater ? 1 : 0;
      Equation constraint(getRealDomain());
      if (isSigned)
         conversion.assign(signedImplementationResult);
      else
         conversion.assign(implementationResult);
      BuiltReal max;
      max.setInteger(conversion, maxParams);
      maxParams.clear();
      if (unitSub > 0) {
         BuiltReal one;
         one.setOne();
         if (roundMode == ReadParametersBase::RMNearest)
            one.getSBasicExponent().dec();
         max.plusAssign(one, maxParams);
         maxParams.clear();
      };
      // restrict the interval and do not shift the center
      // if (isStrictGreater)
      //    max.setToPrevious();
      constraint.getSCentral().minusAssign(max, minParams);
      minParams.clear();
      constraint.plusAssign(constraintError, Equation::PCSourceRValue, symbolsManager());
      Symbol* constrainedSymbol = symbolsManager()
         .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
      bool hasAllSimplified = hasMultiple
         ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager(),
               TypeBaseFloatAffine::getConditionSameBranch())
         : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager());
      if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
         constraints().pushConstraint().setFrom(constraint, true);
   }
   else { // implementationResult > result
      int unitSub=1;
      bool isStrictGreater=false;
      if (roundMode == ReadParametersBase::RMZero
            && (isSigned && signedResult < 0 && 0 < signedImplementationResult))
         unitSub = 0;
      if ((roundMode == ReadParametersBase::RMZero
               && (!isSigned || signedImplementationResult <= 0))
            || (roundMode == ReadParametersBase::RMHighest))
         isStrictGreater=true;
      typename BuiltReal::IntConversion conversion;
      if (isSigned) {
         conversion.setSigned();
         conversion.assign((int) (signedImplementationResult-signedResult-unitSub));
      }
      else {
         conversion.setUnsigned();
         conversion.assign((unsigned) (implementationResult-result-unitSub));
      };
      BuiltReal errorBound;
      errorBound.setInteger(conversion, maxParams);
      maxParams.clear();
      // if (isStrictGreater)
      //    errorBound.setToPrevious();

      if (isStrictGreater ? (errorMax <= errorBound) : (errorMax < errorBound)) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         return false;
      };

      Equation constraintError(getError());
      if (isStrictGreater ? (errorMin <= errorBound) : (errorMin < errorBound)) {
         constraintError.getSCentral().minusAssign(errorBound, maxParams);
         maxParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
            .createDefinedSymbol(typename inherited::TemplateTraits(), constraintError);
         bool hasAllSimplified = hasMultiple
            ? constraintError.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraintError.simplifyAllEquations(*constrainedSymbol, false, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraintError, false);
      };

      // getSRealDomain() >= implementation-error
      isStrictGreater = (roundMode == ReadParametersBase::RMZero
               && (!isSigned || signedImplementationResult <= 0))
            || (roundMode == ReadParametersBase::RMHighest);
      unitSub = isStrictGreater ? 1 : 0;
      Equation constraint(getRealDomain());
      if (isSigned)
         conversion.assign(signedImplementationResult);
      else
         conversion.assign(implementationResult);
      BuiltReal max;
      max.setInteger(conversion, maxParams);
      maxParams.clear();
      if (unitSub > 0) {
         BuiltReal one;
         one.setOne();
         if (roundMode == ReadParametersBase::RMNearest)
            one.getSBasicExponent().dec();
         max.minusAssign(one, maxParams);
         maxParams.clear();
      };
      // restrict the interval and do not shift the center
      // if (isStrictGreater)
      //    max.setToNext();
      constraint.getSCentral().minusAssign(max, minParams);
      minParams.clear();
      constraint.plusAssign(constraintError, Equation::PCSourceRValue, symbolsManager());
      Symbol* constrainedSymbol = symbolsManager()
         .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
      bool hasAllSimplified = hasMultiple
         ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager(),
               TypeBaseFloatAffine::getConditionSameBranch())
         : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager());
      if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
         constraints().pushConstraint().setFrom(constraint, false);
   }
   return true;
}

// real=implementation-error
// realResult > result
// roundMode == RMZero
//    => result > 0
//       // realResult <= real <= realResult+1
//       // result <= implementation < result+1
//       // so result+1-realResult > error >= result-(realResult+1)
//    => realResult < 0
//       // realResult-1 <= real <= realResult
//       // result-1 < implementation <= result
//       // so result-(realResult-1) >= error > result-1-realResult
//    => result = 0 < realResult
//       // realResult <= real <= realResult+1
//       // result-1 < implementation < result+1
//       // so result+1-realResult > error > -1+result-(realResult+1)
//    => result < 0 = realResult
//       // realResult-1 <= real <= realResult+1
//       // result-1 < implementation <= result
//       // so result-(realResult-1) >= error > -1+result-(realResult+1)
//    => result < 0 < realResult
//       // realResult <= real <= realResult+1
//       // result-1 < implementation <= result
//       // so result-realResult >= error > -1+result-(realResult+1)
// roundMode == RMNearest
//    // realResult-0.5 <= real < realResult+0.5
//    // result-0.5 <= implementation <= result+0.5
//    // so result+0.5-(realResult-0.5) >= error >= result-0.5-(realResult+0.5)
// roundMode == RMLowest
//    // realResult <= real <= realResult+1
//    // result <= implementation < result+1
//    // so result+1-realResult > error >= result-(realResult+1)
// roundMode == RMHighest
//    // realResult-1 <= real <= realResult
//    // result-1 < implementation <= result
//    // so result-(realResult-1) >= error > result-1-realResult
// result > realResult
// roundMode == RMZero
//    => realResult > 0
//       // realResult <= real <= realResult+1
//       // result <= implementation < result+1
//       // so result+1-realResult > error >= result-(realResult+1)
//    => result < 0
//       // realResult-1 <= real <= realResult
//       // result-1 < implementation <= result
//       // so result-(realResult-1) >= error > result-1-realResult
//    => realResult = 0 < result
//       // realResult-1 <= real <= realResult+1
//       // result <= implementation < result+1
//       // so result+1-(realResult-1) > error >= result-(realResult+1)
//    => realResult < 0 = result
//       // realResult-1 <= real <= realResult
//       // result-1 < implementation < result+1
//       // so result+1-(realResult-1) > error > -1+result-realResult
//    => realResult < 0 < result
//       // realResult-1 <= real <= realResult
//       // result <= implementation < result+1
//       // so result+1-(realResult-1) >= error >= result-realResult
// roundMode == RMNearest
//    // realResult-0.5 <= real < realResult+0.5
//    // result-0.5 <= implementation <= result+0.5
//    // so result+0.5-(realResult-0.5) >= error >= result-0.5-(realResult+0.5)
// roundMode == RMLowest
//    // realResult <= real <= realResult+1
//    // result <= implementation < result+1
//    // so result+1-realResult > error >= result-(realResult+1)
// roundMode == RMHighest
//    // realResult-1 <= real <= realResult
//    // result-1 < implementation <= result
//    // so result-(realResult-1) >= error > result-1-realResult

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
bool
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::optimizeUnstableConversionForImplementationFlow(unsigned result, unsigned realResult,
            int signedResult, int signedRealResult, bool isSigned,
            bool hasMultiple, typename TypeBaseFloatAffine::Mode mode,
            Numerics::DDouble::Access::ReadParameters& minParams,
            Numerics::DDouble::Access::ReadParameters& maxParams,
            ReadParametersBase::RoundMode roundMode) const {
   BuiltReal errorMin, errorMax;
   getError().retrieveBound(errorMin, errorMax, false /* hasExternalCoefficient */);
   
   if (isSigned ? (signedRealResult > signedResult) : (realResult > result)) {
      bool isStrictGreater = false;
      int unitSub = 1;
      if (roundMode == ReadParametersBase::RMZero
            && isSigned && (signedResult < 0) && (0 < signedRealResult))
         unitSub = 0;
      if ((roundMode == ReadParametersBase::RMZero && (!isSigned || signedResult >= 0))
            || roundMode == ReadParametersBase::RMLowest)
         isStrictGreater = true;
      typename BuiltReal::IntConversion conversion;
      if (isSigned) {
         conversion.setSigned();
         conversion.assign((int) (signedRealResult-signedResult-unitSub));
      }
      else {
         conversion.setUnsigned();
         conversion.assign((int) (realResult-result-unitSub));
      };
      BuiltReal errorBound;
      errorBound.setInteger(conversion, maxParams);
      maxParams.clear();
      errorBound.opposite(); // = result+unitSub-realResult

      if (isStrictGreater ? (errorMin >= errorBound) : (errorMin > errorBound)) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         return false;
      };

      if (roundMode == ReadParametersBase::RMZero)
         unitSub = (isSigned && signedRealResult <= 0) ? 1 : 0;
      else
         unitSub = (roundMode == ReadParametersBase::RMHighest) ? 1 : 0;
      Equation constraint(getRealDomain());
      if (isSigned)
         conversion.assign(signedRealResult);
      else
         conversion.assign(realResult);
      BuiltReal max;
      max.setInteger(conversion, maxParams);
      maxParams.clear();
      if (unitSub > 0) {
         BuiltReal one;
         one.setOne();
         if (roundMode == ReadParametersBase::RMNearest)
            one.getSBasicExponent().dec();
         max.minusAssign(one, maxParams);
         maxParams.clear();
      };
      // real - realResult+unitSub >= 0
      constraint.getSCentral().minusAssign(max, maxParams);
      maxParams.clear();
      Symbol* constrainedSymbol = symbolsManager()
         .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
      bool hasAllSimplified = hasMultiple
         ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager(),
               TypeBaseFloatAffine::getConditionSameBranch())
         : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager());
      if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
         constraints().pushConstraint().setFrom(constraint, false);
   }
   else { // realResult < result
      int unitSub=1;
      bool isStrictGreater=false;
      if (roundMode == ReadParametersBase::RMZero
            && (isSigned && signedRealResult < 0 && 0 < signedResult))
         unitSub = 0;
      if ((roundMode == ReadParametersBase::RMZero && (isSigned && signedResult <= 0))
            || (roundMode == ReadParametersBase::RMHighest))
         isStrictGreater=true;
      typename BuiltReal::IntConversion conversion;
      if (isSigned) {
         conversion.setSigned();
         conversion.assign((int) (signedResult-signedRealResult-unitSub));
      }
      else {
         conversion.setUnsigned();
         conversion.assign((unsigned) (result-realResult-unitSub));
      };
      BuiltReal errorBound;
      errorBound.setInteger(conversion, maxParams);
      maxParams.clear();

      if (isStrictGreater ? (errorMax <= errorBound) : (errorMax < errorBound)) {
         bool isUnstable = mode != inherited::getMode();
         TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
         TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
         return false;
      };

      // getSRealDomain() <= realResult+1
      unitSub = ((roundMode == ReadParametersBase::RMZero
               && (!isSigned || signedRealResult >= 0))
            || (roundMode == ReadParametersBase::RMHighest)) ? 1 : 0;
      Equation constraint(getRealDomain());
      if (isSigned)
         conversion.assign(signedRealResult);
      else
         conversion.assign(realResult);
      BuiltReal max;
      max.setInteger(conversion, maxParams);
      maxParams.clear();
      if (unitSub > 0) {
         BuiltReal one;
         one.setOne();
         if (roundMode == ReadParametersBase::RMNearest)
            one.getSBasicExponent().dec();
         max.plusAssign(one, maxParams);
         maxParams.clear();
      };
      constraint.getSCentral().minusAssign(max, minParams);
      minParams.clear();
      Symbol* constrainedSymbol = symbolsManager()
         .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
      bool hasAllSimplified = hasMultiple
         ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager(),
               TypeBaseFloatAffine::getConditionSameBranch())
         : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager());
      if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
         constraints().pushConstraint().setFrom(constraint, true);
   }
   return true;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
int
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::asInt(ReadParametersBase::RoundMode roundMode) const {
   typename inherited::GuardStateZonotope thisGuard(*this, true /* isConstEquation*/, false /* isXValue */);
   // const_cast<thisType&>(*this).updateLocalState();
   int realResultMin=0, realResultMax=-1, implementationResultMin=0, implementationResultMax=-1,
      realPlusErrorResultMin=0, realPlusErrorResultMax=-1,
      implementationBoundResultMin=0, implementationBoundResultMax=-1;
   typename inherited::EquationHolder implementation;
   auto roundParams = TypeBaseFloatAffine::nearestParams();
   if (roundMode != ReadParametersBase::RMNearest)
      roundParams.setRoundMode(roundMode);
   if (this->doesComputeReal()) {
      BuiltReal min, max;
      getRealDomain().retrieveBound(min, max, false /* hasExternalCoefficient */);

      typename BuiltReal::IntConversion conversion;
      min.retrieveInteger(conversion.setSigned(), roundParams);
      roundParams.clear();
      realResultMin = conversion.asInt();
      max.retrieveInteger(conversion.setSigned(), roundParams);
      roundParams.clear();
      realResultMax = conversion.asInt();
   }

   if (this->doesComputeError()) {
      implementation = getRealDomain();
      implementation.plusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
      BuiltReal min, max;
      constraints().retrieveBound(implementation, min, max);

      typename BuiltReal::IntConversion conversion;
      min.retrieveInteger(conversion.setSigned(), roundParams);
      roundParams.clear();
      implementationResultMin = realPlusErrorResultMin = conversion.asInt();
      max.retrieveInteger(conversion.setSigned(), roundParams);
      roundParams.clear();
      implementationResultMax = realPlusErrorResultMax = conversion.asInt();
      {  typename BuiltDouble::IntConversion conversion;
         bfMin.retrieveInteger(conversion.setSigned(), roundParams);
         roundParams.clear();
         implementationBoundResultMin = conversion.asInt();
         if (implementationBoundResultMin > implementationResultMin)
            implementationResultMin = implementationBoundResultMin;
      };
      {  typename BuiltDouble::IntConversion conversion;
         bfMax.retrieveInteger(conversion.setSigned(), roundParams);
         roundParams.clear();
         implementationBoundResultMax = conversion.asInt();
         if (implementationBoundResultMax < implementationResultMax)
            implementationResultMax = implementationBoundResultMax;
      };
   };

   if (realResultMin == realResultMax
         && ((implementationResultMin > implementationResultMax)
            || (implementationResultMin == realResultMin && implementationResultMin == implementationResultMax)))
      return realResultMin;

   if (implementationResultMin == implementationResultMax && (realResultMin > realResultMax))
      return implementationResultMin;

   if ((realResultMax - realResultMin >= (1 << 12))
         || (implementationResultMax - implementationResultMin >= (1 << 12)))
      return (int) dValue;

   unsigned firstReal = (realResultMin <= realResultMax) ? 0 : 1;
   unsigned lastReal = (realResultMin <= realResultMax) ? (realResultMax-realResultMin) : 0;
   int baseResult = (realResultMin <= realResultMax) ? realResultMin : implementationResultMin;
   if ((realResultMin <= realResultMax) && (implementationResultMin <= implementationResultMax)
         && (implementationResultMin < realResultMin)) {
      baseResult = implementationResultMin;
      firstReal += (realResultMin - baseResult);
      lastReal += (realResultMin - baseResult);
   };
   unsigned firstImplementation = (implementationResultMin <= implementationResultMax) ? 0 : 1;
   unsigned lastImplementation = (implementationResultMin <= implementationResultMax)
      ? (implementationResultMax-implementationResultMin) : 0;
   if ((realResultMin <= realResultMax) && (implementationResultMin <= implementationResultMax)
         && (realResultMin < implementationResultMin)) {
      firstImplementation += (implementationResultMin - baseResult);
      lastImplementation += (implementationResultMin - baseResult);
   };

   unsigned casesNumber = TypeBaseFloatAffine::getConversionNumber(firstReal, lastReal,
         firstImplementation, lastImplementation);
   bool realChoice = this->doesComputeReal(), implementationChoice = this->doesComputeError();
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   unsigned ualternativeResult;
   int result = baseResult + TypeBaseFloatAffine::getConversionBranch(casesNumber,
         firstReal, lastReal, firstImplementation, lastImplementation,
         realChoice, implementationChoice, (unsigned) ((int) dValue - baseResult), ualternativeResult);
   int alternativeResult = baseResult + ualternativeResult;

   auto& maxParams = TypeBaseFloatAffine::maxParams();
   auto& minParams = TypeBaseFloatAffine::minParams();
   if (realChoice) {
      if (!implementationChoice) {
         AssumeCondition(ualternativeResult != ~0U && alternativeResult != result)
         if (inherited::doesComputeError()) {
            if (!optimizeUnstableConversionForRealFlow(result, alternativeResult,
                     result, alternativeResult, true /* isSigned */,
                     casesNumber > 1, mode, minParams, maxParams, roundMode))
               return result;
            const_cast<thisType*>(this)->mergeNoError();
         };
      };
      if ((realResultMin <= realResultMax) && (result+1 < realResultMax)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setSigned();
         conversion.assign(result+1);
         BuiltReal newMax;
         newMax.setInteger(conversion, maxParams);
         maxParams.clear();
         Equation constraint(getRealDomain());
         constraint.getSCentral().minusAssign(newMax, minParams);
         minParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
            .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
      };

      if ((realResultMin <= realResultMax) && (result > realResultMin)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setSigned();
         conversion.assign(result);
         BuiltReal newMin;
         newMin.setInteger(conversion, minParams);
         minParams.clear();
         Equation constraint(getRealDomain());
         constraint.getSCentral().minusAssign(newMin, maxParams);
         maxParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
               .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
      };
   };

   if (implementationChoice) {
      if (!realChoice) {
         AssumeCondition(ualternativeResult != ~0U && alternativeResult != result)
         if (inherited::doesComputeError()) {
            if (!optimizeUnstableConversionForImplementationFlow(result, alternativeResult,
                     result, alternativeResult, true /* isSigned */, casesNumber > 1,
                     mode, minParams, maxParams, roundMode))
               return result;
            const_cast<thisType*>(this)->mergeNoReal();
            implementation = getError();
         };
      };
      if ((realPlusErrorResultMin <= realPlusErrorResultMax) && (result+1 < realPlusErrorResultMax)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setSigned();
         conversion.assign(result+1);
         BuiltReal newMax;
         newMax.setInteger(conversion, maxParams);
         maxParams.clear();
         addSemiUlp(newMax);
         Equation constraint(implementation);
         constraint.getSCentral().minusAssign(newMax, minParams);
         minParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
               .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
      };

      if ((realPlusErrorResultMin <= realPlusErrorResultMax) && (result > realPlusErrorResultMin)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setSigned();
         conversion.assign(result);
         BuiltReal newMin;
         newMin.setInteger(conversion, minParams);
         minParams.clear();
         subSemiUlp(newMin);
         Equation constraint(implementation);
         constraint.getSCentral().minusAssign(newMin, maxParams);
         maxParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
               .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
      };

      if (result < implementationBoundResultMax) {
         typename BuiltDouble::IntConversion conversion;
         conversion.setSigned();
         conversion.assign(result);
         const_cast<thisType&>(*this).bfMax.setInteger(conversion, maxParams);
         maxParams.clear();
         if (bfMax.isPositive()) {
            BuiltDouble one;
            one.setOne();
            const_cast<thisType&>(*this).bfMax.plusAssign(one, maxParams);
            maxParams.clear();
            const_cast<thisType&>(*this).bfMax.setToPrevious();
         };
      };

      if (result > implementationBoundResultMin) {
         typename BuiltDouble::IntConversion conversion;
         conversion.setSigned();
         conversion.assign(result);
         const_cast<thisType&>(*this).bfMin.setInteger(conversion, minParams);
         minParams.clear();
         if (bfMin.isNegative()) {
            BuiltDouble one;
            one.setOne();
            const_cast<thisType&>(*this).bfMin.minusAssign(one, minParams);
            minParams.clear();
            const_cast<thisType&>(*this).bfMin.setToNext();
         };
      };
      if (realChoice) {
         const_cast<thisType*>(this)->restrictErrorFromRealAndImplementation();
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
   };

   bool isUnstable = mode != inherited::getMode();
   if (implementationChoice
         && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
      TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
   if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation)
      const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
   TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
unsigned
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::asUnsigned(ReadParametersBase::RoundMode roundMode) const {
   typename inherited::GuardStateZonotope thisGuard(*this, true /* isConstEquation*/, false /* isXValue */);
   // const_cast<thisType&>(*this).updateLocalState();
   unsigned realResultMin=1, realResultMax=0, implementationResultMin=1, implementationResultMax=0,
      realPlusErrorResultMin=1, realPlusErrorResultMax=0,
      implementationBoundResultMin=1, implementationBoundResultMax=0;
   typename inherited::EquationHolder implementation;
   auto roundParams = TypeBaseFloatAffine::nearestParams();
   if (roundMode != ReadParametersBase::RMNearest)
      roundParams.setRoundMode(roundMode);
   if (this->doesComputeReal()) {
      BuiltReal min, max;
      getRealDomain().retrieveBound(min, max, false /* hasExternalCoefficient */);

      typename BuiltReal::IntConversion conversion;
      min.retrieveInteger(conversion.setUnsigned(), roundParams);
      roundParams.clear();
      realResultMin = conversion.asUnsignedInt();
      max.retrieveInteger(conversion.setUnsigned(), roundParams);
      roundParams.clear();
      realResultMax = conversion.asUnsignedInt();
   }

   if (this->doesComputeError()) {
      implementation = getRealDomain();
      implementation.plusAssign(getError(), Equation::PCSourceRValue, symbolsManager());
      BuiltReal min, max;
      constraints().retrieveBound(implementation, min, max);

      typename BuiltReal::IntConversion conversion;
      min.retrieveInteger(conversion.setUnsigned(), roundParams);
      roundParams.clear();
      implementationResultMin = realPlusErrorResultMin = conversion.asUnsignedInt();
      max.retrieveInteger(conversion.setUnsigned(), roundParams);
      roundParams.clear();
      implementationResultMax = realPlusErrorResultMax = conversion.asUnsignedInt();
      {  typename BuiltDouble::IntConversion conversion;
         bfMin.retrieveInteger(conversion.setUnsigned(), roundParams);
         roundParams.clear();
         implementationBoundResultMin = conversion.asUnsignedInt();
         if (implementationBoundResultMin > implementationResultMin)
            implementationResultMin = implementationBoundResultMin;
      };
      {  typename BuiltDouble::IntConversion conversion;
         bfMax.retrieveInteger(conversion.setUnsigned(), roundParams);
         roundParams.clear();
         implementationBoundResultMax = conversion.asUnsignedInt();
         if (implementationBoundResultMax < implementationResultMax)
            implementationResultMax = implementationBoundResultMax;
      };
   };

   if (realResultMin == realResultMax
         && ((implementationResultMin > implementationResultMax)
            || (implementationResultMin == realResultMin && implementationResultMin == implementationResultMax)))
      return realResultMin;

   if (implementationResultMin == implementationResultMax && (realResultMin > realResultMax))
      return implementationResultMin;

   if ((realResultMax - realResultMin >= (1 << 12))
         || (implementationResultMax - implementationResultMin >= (1 << 12)))
      return (unsigned) dValue;

   unsigned firstReal = (realResultMin <= realResultMax) ? 0 : 1;
   unsigned lastReal = (realResultMin <= realResultMax) ? (realResultMax-realResultMin) : 0;
   unsigned baseResult = (realResultMin <= realResultMax) ? realResultMin : implementationResultMin;
   if ((realResultMin <= realResultMax) && (implementationResultMin <= implementationResultMax)
         && (implementationResultMin < realResultMin)) {
      baseResult = implementationResultMin;
      firstReal += (realResultMin - baseResult);
      lastReal += (realResultMin - baseResult);
   };
   unsigned firstImplementation = (implementationResultMin <= implementationResultMax) ? 0 : 1;
   unsigned lastImplementation = (implementationResultMin <= implementationResultMax)
      ? (implementationResultMax-implementationResultMin) : 0;
   if ((realResultMin <= realResultMax) && (implementationResultMin <= implementationResultMax)
         && (realResultMin < implementationResultMin)) {
      firstImplementation += (implementationResultMin - baseResult);
      lastImplementation += (implementationResultMin - baseResult);
   };

   unsigned casesNumber = TypeBaseFloatAffine::getConversionNumber(firstReal, lastReal,
         firstImplementation, lastImplementation);
   bool realChoice = this->doesComputeReal(), implementationChoice = this->doesComputeError();
   typename TypeBaseFloatAffine::Mode mode = inherited::getMode();
   unsigned alternativeResult;
   unsigned result = baseResult + TypeBaseFloatAffine::getConversionBranch(casesNumber,
         firstReal, lastReal, firstImplementation, lastImplementation,
         realChoice, implementationChoice, (unsigned) ((unsigned) dValue - baseResult), alternativeResult);
   alternativeResult += baseResult;

   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   if (realChoice) {
      if (!implementationChoice) {
         AssumeCondition(alternativeResult != ~0U && alternativeResult != result)
         if (inherited::doesComputeError()) {
            if (!optimizeUnstableConversionForRealFlow(result, alternativeResult, 0, 0, false /* isSigned */,
                     casesNumber > 1, mode, minParams, maxParams, roundMode))
               return result;
            const_cast<thisType*>(this)->mergeNoError();
         };
      };
      if ((realResultMin <= realResultMax) && (result+1 < realResultMax)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setUnsigned();
         conversion.assign(result+1);
         BuiltReal newMax;
         newMax.setInteger(conversion, maxParams);
         maxParams.clear();
         Equation constraint(getRealDomain());
         constraint.getSCentral().minusAssign(newMax, minParams);
         minParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
               .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
      };

      if ((realResultMin <= realResultMax) && (result > realResultMin)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setUnsigned();
         conversion.assign(result);
         BuiltReal newMin;
         newMin.setInteger(conversion, minParams);
         minParams.clear();
         Equation constraint(getRealDomain());
         constraint.getSCentral().minusAssign(newMin, maxParams);
         maxParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
               .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
      };
   };

   if (implementationChoice) {
      if (!realChoice) {
         AssumeCondition(alternativeResult != ~0U && alternativeResult != result)
         if (inherited::doesComputeError()) {
            if (!optimizeUnstableConversionForImplementationFlow(result, alternativeResult,
                     0, 0, false /* isSigned */, casesNumber > 1,
                     mode, minParams, maxParams, roundMode))
               return result;
            const_cast<thisType*>(this)->mergeNoReal();
            implementation = getError();
         };
      };
      if ((realPlusErrorResultMin <= realPlusErrorResultMax) && (result+1 < realPlusErrorResultMax)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setUnsigned();
         conversion.assign(result+1);
         BuiltReal newMax;
         newMax.setInteger(conversion, maxParams);
         maxParams.clear();
         addSemiUlp(newMax);
         Equation constraint(implementation);
         constraint.getSCentral().minusAssign(newMax, minParams);
         minParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
               .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, true, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, true, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, true);
      };

      if ((realPlusErrorResultMin <= realPlusErrorResultMax) && (result > realPlusErrorResultMin)) {
         typename BuiltReal::IntConversion conversion;
         conversion.setUnsigned();
         conversion.assign(result);
         BuiltReal newMin;
         newMin.setInteger(conversion, minParams);
         minParams.clear();
         subSemiUlp(newMin);
         Equation constraint(implementation);
         constraint.getSCentral().minusAssign(newMin, maxParams);
         maxParams.clear();
         Symbol* constrainedSymbol = symbolsManager()
               .createDefinedSymbol(typename inherited::TemplateTraits(), constraint);
         bool hasAllSimplified = TypeBaseFloatAffine::hasMultipleBranches()
            ? constraint.simplifyAllEquationsIf(*constrainedSymbol, false, symbolsManager(),
                  TypeBaseFloatAffine::getConditionSameBranch())
            : constraint.simplifyAllEquations(*constrainedSymbol, false, symbolsManager());
         if (!hasAllSimplified && TypeBaseFloatAffine::doesAllowSimplex())
            constraints().pushConstraint().setFrom(constraint, false);
      };

      if (result < implementationBoundResultMax) {
         typename BuiltDouble::IntConversion conversion;
         conversion.setUnsigned();
         conversion.assign(result);
         const_cast<thisType&>(*this).bfMax.setInteger(conversion, maxParams);
         maxParams.clear();
         BuiltDouble one;
         one.setOne();
         const_cast<thisType&>(*this).bfMax.plusAssign(one, maxParams);
         maxParams.clear();
         const_cast<thisType&>(*this).bfMax.setToPrevious();
      };

      if (result > implementationBoundResultMin) {
         typename BuiltDouble::IntConversion conversion;
         conversion.setUnsigned();
         conversion.assign(result);
         const_cast<thisType&>(*this).bfMin.setInteger(conversion, minParams);
         minParams.clear();
      };
      if (realChoice) {
         const_cast<thisType*>(this)->restrictErrorFromRealAndImplementation();
         const_cast<thisType*>(this)->restrictRealFromErrorAndImplementation();
         const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
      };
   };

   bool isUnstable = mode != inherited::getMode();
   if (implementationChoice
         && !const_cast<thisType*>(this)->restrictImplementationFromRealAndError())
      TypeBaseFloatAffine::throwEmptyBranch(isUnstable);
   if (TypeBaseFloatAffine::getMode() == TypeBaseFloatAffine::MRealAndImplementation)
      const_cast<thisType*>(this)->restrictRelativeErrorFromRealAndError();
   TypeBaseFloatAffine::notifyForBranchCompare(*this, isUnstable);
   return result;
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::sqrtAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   bool isApproximate = !this->isFourPower();
   dValue = ::sqrt((double) dValue);
   inherited::sqrtAssign();
   if (!this->hasNoError()) {
      if (bfMin.isNegative() && !bfMin.isZero()) {
         // [TODO] should be in FloatZonotope::sqrtAssign
         TypeBaseFloatAffine::notifyForNegativeSqrt(*this);
         bfMin = 0;
         if (bfMax.isNegative() && !bfMax.isZero())
            bfMax = 0;
      };

      bfMin.sqrtAssign();
      bfMax.sqrtAssign();

      if (this->doesComputeError()) {
         if (isApproximate)
            addSemiUlpToError();
         restrictImplementationFromRealAndError();
         computeRelativeError();
      };
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::sinAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   dValue = ::sin((double) dValue);
   inherited::sinAssign();
   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::cosAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   dValue = ::cos((double) dValue);
   inherited::cosAssign();
   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::asinAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   dValue = ::asin((double) dValue);
   inherited::asinAssign();
   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::acosAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   dValue = ::acos((double) dValue);
   inherited::acosAssign();
   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::tanAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   dValue = ::tan((double) dValue);
   inherited::tanAssign();
   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::atanAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   dValue = ::atan((double) dValue);
   inherited::atanAssign();

/* typedef Numerics::DefineTaylorDouble<
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent) >,
         Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
            DefineRealMantissaExponentTemplateParameters(URealBitsNumber, USizeMantissa+5, USizeExponent) >,
         Numerics::BigInteger > TaylorDouble;
   TaylorDouble extendedResult(std::move(bfMin));
   BuiltDouble errorMin, errorMax;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   extendedResult.atanAssign(errorMin, errorMax, nearestParams);
   nearestParams.clear();
   bfMin = std::move(extendedResult);
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   // bfMin.plusAssign(errorMin, maxParams); maxParams.clear();
   extendedResult = std::move(bfMax);
   errorMin.setZero(); errorMax.setZero();
   extendedResult.atanAssign(errorMin, errorMax, nearestParams);
   nearestParams.clear();
   bfMax = std::move(extendedResult);
   // auto& minParams = TypeBaseFloatAffine::minParams();
   // bfMax.plusAssign(errorMax, minParams); minParams.clear();

   restrictImplementationFromRealAndError();
*/

   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::expAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   bool isApproximate = !this->isZero();
   dValue = ::exp((double) dValue);
   inherited::expAssign();

   if (!this->hasNoError()) {
      typedef Numerics::DefineTaylorDouble<
            Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent) >,
            Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, USizeMantissa+5, USizeExponent) >,
            Numerics::BigInteger > TaylorDouble;
      TaylorDouble extendedResult(std::move(bfMin));
      BuiltDouble errorMin, errorMax;
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      extendedResult.expAssign(errorMin, errorMax, nearestParams);
      nearestParams.clear();
      bfMin = std::move(extendedResult);
      // auto& maxParams = TypeBaseFloatAffine::maxParams();
      // bfMin.plusAssign(errorMin, maxParams); maxParams.clear();
      extendedResult = std::move(bfMax);
      errorMin.setZero(); errorMax.setZero();
      extendedResult.expAssign(errorMin, errorMax, nearestParams);
      nearestParams.clear();
      bfMax = std::move(extendedResult);
      // auto& minParams = TypeBaseFloatAffine::minParams();
      // bfMax.plusAssign(errorMax, minParams); minParams.clear();

      if (this->doesComputeError()) {
         if (isApproximate)
            addSemiUlpToError();
         restrictImplementationFromRealAndError();
         computeRelativeError();
      };
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::logAssign() {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this) >> *this;
   bool isApproximate = !this->isOne();
   dValue = ::log((double) dValue);
   inherited::logAssign();
   if (bfMin.isNegative() && !bfMin.isZero()) {
      // [TODO] should be in FloatZonotope::logAssign
      TypeBaseFloatAffine::notifyForNegativeOrNulLog(*this);
      bfMin = 0;
      if (bfMax.isNegative() && !bfMax.isZero())
         bfMax = 0;
   };

   if (!this->hasNoError()) {
      typedef Numerics::DefineTaylorDouble<
            Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent) >,
            Numerics::DefineBuiltDouble<DefineBuiltDoubleTraits
               DefineRealMantissaExponentTemplateParameters(URealBitsNumber, USizeMantissa+5, USizeExponent) >,
            Numerics::BigInteger > TaylorDouble;
      TaylorDouble extendedResult(std::move(bfMin));
      BuiltDouble errorMin, errorMax;
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      extendedResult.logAssign(errorMin, errorMax, nearestParams);
      nearestParams.clear();
      bfMin = std::move(extendedResult);
      // auto& maxParams = TypeBaseFloatAffine::maxParams();
      // bfMin.plusAssign(errorMin, maxParams); maxParams.clear();
      extendedResult = std::move(bfMax);
      errorMin.setZero(); errorMax.setZero();
      extendedResult.logAssign(errorMin, errorMax, nearestParams);
      nearestParams.clear();
      bfMax = std::move(extendedResult);
      // auto& minParams = TypeBaseFloatAffine::minParams();
      // bfMax.plusAssign(errorMax, minParams); minParams.clear();

      if (this->doesComputeError()) {
         if (isApproximate)
            addSemiUlpToError();
         restrictImplementationFromRealAndError();
         computeRelativeError();
      };
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::log10Assign() {
   bool isApproximate = !this->isOne();
   dValue = ::log10((double) dValue);
   inherited::log10Assign();
   if (!this->hasNoError()) {
      if (bfMin.isNegative() && !bfMin.isZero()) {
         // [TODO] should be in FloatZonotope::log10Assign
         TypeBaseFloatAffine::notifyForNegativeOrNulLog(*this);
         bfMin = 0;
         if (bfMax.isNegative() && !bfMax.isZero())
            bfMax = 0;
      };

/*    typedef Numerics::TTaylorDouble<
            Numerics::TBuiltDouble<BuiltDoubleTraits<USizeMantissa, USizeExponent> >,
            Numerics::TBuiltDouble<BuiltDoubleTraits<USizeMantissa+5, USizeExponent> >,
            Numerics::BigInteger > TaylorDouble;
      TaylorDouble extendedResult(std::move(bfMin));
      BuiltDouble errorMin, errorMax;
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      extendedResult.log10Assign(errorMin, errorMax, nearestParams);
      nearestParams.clear();
      bfMin = std::move(extendedResult);
      // auto& maxParams = TypeBaseFloatAffine::maxParams();
      // bfMin.plusAssign(errorMin, maxParams); maxParams.clear();
      extendedResult = std::move(bfMax);
      errorMin.setZero(); errorMax.setZero();
      extendedResult.log10Assign(errorMin, errorMax, nearestParams);
      nearestParams.clear();
      bfMax = std::move(extendedResult);
      // auto& minParams = TypeBaseFloatAffine::minParams();
      // bfMax.plusAssign(errorMax, minParams); minParams.clear();

      restrictImplementationFromRealAndError();
*/

      if (this->doesComputeError()) {
         if (isApproximate)
            addSemiUlpToError(true /* isBeforeValidImplementation */);
         computeImplementation();
         computeRelativeError();
      };
   };
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::powAssign(const thisType& source, typename Equation::PolicyCall policyCall) {
   auto simplificationRules = (SimplificationRules(TypeBaseFloatAffine::getLimitNoiseSymbolsNumber())
         << *this << source) >> *this;
   dValue = ::pow((double) dValue, (double) source.dValue);
   inherited::powAssign(source, policyCall);
   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

DefineBasicFloatZonotopeTemplateHeader(URealBitsNumber, USizeMantissa, USizeExponent)
void
DefineBasicFloatZonotope DefineBasicFloatZonotopeTemplateParameters(URealBitsNumber, USizeMantissa, USizeExponent)
      ::atan2Assign(const thisType& source, typename Equation::PolicyCall policyCall) {
   dValue = ::atan2((double) dValue, (double) source.dValue);
   inherited::atan2Assign(source, policyCall);
   if (this->doesComputeError())
      addSemiUlpToError(true /* isBeforeValidImplementation */);
   if (!this->hasNoError())
      computeImplementation();
   if (this->doesComputeError())
      computeRelativeError();
   TypeBaseFloatAffine::notifyForCompare(*this);
}

} // end of namespace DAffine

#undef DefineEquationTemplateHeader
#undef DefineEquationTemplateParameters
#undef DefineSizeofBaseTypeInBits
#undef DefineDefinedSymbol
#undef DefineBuiltDouble
#undef DefineBuiltDoubleTraits
#undef DefineRealMantissaExponentTemplateParameters
#undef DefineSetContent
#undef DefineFillContent
#undef DefineBaseFloatZonotope
#undef DefineBasicFloatZonotopeTemplateHeader
#undef DefineBasicFloatZonotope
#undef DefineBasicFloatZonotopeTemplateParameters
#undef DefineTaylorDouble

