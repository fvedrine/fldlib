/**************************************************************************/
/*                                                                        */
/*  This file is part of FLDLib                                           */
/*                                                                        */
/*  Copyright (C) 2011-2017                                               */
/*    CEA (Commissariat a l'Energie Atomique et aux Energies              */
/*         Alternatives)                                                  */
/*                                                                        */
/*  you can redistribute it and/or modify it under the terms of the GNU   */
/*  Lesser General Public License as published by the Free Software       */
/*  Foundation, version 2.1.                                              */
/*                                                                        */
/*  It is distributed in the hope that it will be useful,                 */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of        */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
/*  GNU Lesser General Public License for more details.                   */
/*                                                                        */
/*  See the GNU Lesser General Public License version 2.1                 */
/*  for more details (enclosed in the file LICENSE).                      */
/*                                                                        */
/**************************************************************************/

/////////////////////////////////
//
// Library   : NumericalDomains
// Unit      : Affine relationships
// File      : FloatAffineBaseComponents.template
// Description :
//   Implementation of a class of affine relations.
//

#ifndef DefineGeneric

#define DefineEquationTemplateHeader(RealBitsNumber)                 \
   template <int RealBitsNumber, class TypeBaseFloatAffine>
#define DefineEquationTemplateParameters(RealBitsNumber)             \
   <RealBitsNumber, TypeBaseFloatAffine>
#define DefineEquationServices TEquationServices
#define DefineEquation TEquation
#define DefineSingleTemplateParameters(RealBitsNumber)               \
   <RealBitsNumber>
#define DefineSizeofBaseTypeInBits                                   \
   (sizeof(unsigned int)*8)
#define DefineDefinedSymbol TDefinedSymbol
#define DefineConstraint TConstraint
#define DefineConstraintsSet TConstraintsSet
#define DefineBuiltReal TBuiltReal

#else

#define DefineEquationTemplateHeader(RealBitsNumber)                 \
   template <class BaseStoreTraits, int RealBitsNumber, class TypeBaseFloatAffine>
#define DefineEquationTemplateParameters(RealBitsNumber)             \
   <BaseStoreTraits, RealBitsNumber, TypeBaseFloatAffine>
#define DefineEquationServices TGEquationServices
#define DefineEquation TGEquation
#define DefineSingleTemplateParameters(RealBitsNumber)               \
   <BaseStoreTraits, RealBitsNumber>
#define DefineSizeofBaseTypeInBits                                   \
   BaseStoreTraits::sizeBaseInBits()
#define DefineDefinedSymbol TGDefinedSymbol
#define DefineConstraint TGConstraint
#define DefineConstraintsSet TGConstraintsSet
#define DefineBuiltReal TGBuiltReal

#endif

namespace DAffine {

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquationServices DefineEquationTemplateParameters(URealBitsNumber)::adjustComputation(
      const BuiltReal& computationResult, BuiltReal& highLevelError) const {
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   if (nearestParams.isApproximate()) {
      BuiltReal semiUlp;
      semiUlp.setBasicExponent(computationResult.getBasicExponent());
      if (semiUlp.getSBasicExponent().minusAssign(BuiltReal::BitSizeMantissa+1).hasCarry()) {
         int shift = semiUlp.getSBasicExponent().neg()[0]+1;
         semiUlp.getSMantissa() = 1U;
         if (BuiltReal::BitSizeMantissa-shift-1 > 0)
            semiUlp.getSMantissa() <<= (BuiltReal::BitSizeMantissa-shift-1);
         semiUlp.getSBasicExponent() = 0;
      };
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      highLevelError.plusAssign(semiUlp, maxParams);
      maxParams.clear();
   };
   nearestParams.clear();
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::_read(ISBase& in,
      const STG::IOObject::FormatParameters& aparams) {
   const auto& params = (const ReadParameters&) aparams;
   char ch = in.get();
   while (isspace(ch))
      ch = in.get();
   in.unget();
   BuiltReal value;
   value.read(in, const_cast<ReadParameters&>(params));
   const_cast<ReadParameters&>(params).clear();
   ch = in.get();
   while (isspace(ch))
      ch = in.get();
   bool endRead = false;
   if (!(ch == '+' || ch == '*' || ch == '-')) {
      dCentral = value;
      in.unget();
      endRead = true;
   };

   if (!endRead) {
      bool isNegative = false;
      if (ch == '+' || ch == '-') {
         isNegative = ch == '-';
         dCentral = value;
         ch = in.get();
         while (isspace(ch))
            ch = in.get();
         in.unget();
         value.read(in, const_cast<ReadParameters&>(params));
         const_cast<ReadParameters&>(params).clear();
         ch = in.get();
         while (isspace(ch))
            ch = in.get();
      };

      while (!endRead) {
         if (isNegative)
            value.opposite();
         if (ch != '*') {
            in.unget();
            throw STG::EReadError();
         };
         ch = in.get();
         while (isspace(ch))
            ch = in.get();
         if (ch == 'e') {
            ch = in.get();
            if (ch != '_')
               throw STG::EReadError();
            int index=0;
            in >> index;
            addCoefficient(value, params.hasMergeTable()
               ? params.mergeTable().findCentralSymbol(index, params.ssymbolsManager())
               : params.symbolsManager().findCentralSymbol(index));
         }
         else if (ch == 'u') {
            ch = in.get();
            bool isMarked = ch == 'm';
            if (isMarked)
               ch = in.get();
            if (ch != '_')
               throw STG::EReadError();
            int index=0;
            in >> index;
            addCoefficient(value, params.hasMergeTable()
               ? params.mergeTable().findNoiseSymbol(index, params.ssymbolsManager())
               : params.symbolsManager().findNoiseSymbol(index));
         }
         else if (ch == 'h') {
            ch = in.get();
            if (ch != '_')
               throw STG::EReadError();
            int index=0;
            in >> index;
            addCoefficient(value, params.hasMergeTable()
               ? params.mergeTable().findHighLevelSymbol(index, params.ssymbolsManager())
               : params.symbolsManager().findHighLevelSymbol(index));
         }
         // else if (ch == 'l') {
         //    ch = is.get();
         //    if (ch != '_')
         //       throw STG::EReadError();
         //    int index=0;
         //    in >> index;
         //    addCoefficient(value, params.hasMergeTable()
         //       : params.mergeTable().findClosedSymbol(index, params.ssymbolsManager())
         //       ? params.symbolsManager().findClosedSymbol(index));
         // }
         else if (ch == 'd') {
            ch = in.get();
            if (ch != '_')
               throw STG::EReadError();
            int index=0;
            in >> index;
            thisType definition;
            if (params.hasMergeTable() && params.doesReadDefinition()) {
               ch = in.get();
               while (isspace(ch))
                  ch = in.get();
               if (ch != '{')
                  throw STG::EReadError();
               thisType definition;
               definition.read(in, params);
               ch = in.get();
               while (isspace(ch))
                  ch = in.get();
               if (ch != '}')
                  throw STG::EReadError();
            }
            addCoefficient(value, params.hasMergeTable()
               ? params.mergeTable().findDefinedSymbol(TemplateTraits(), index,
                     params.ssymbolsManager(), std::move(definition))
               : params.symbolsManager().findDefinedSymbol(index));
         }
         else
            throw STG::EReadError();
         ch = in.get();
         while (isspace(ch))
            ch = in.get();
         if (!(ch == '+' || ch == '*' || ch == '-')) {
            in.unget();
            endRead = true;
         };

         if (!endRead) {
            isNegative = false;
            if (ch == '+' || ch == '-') {
               isNegative = ch == '-';
               ch = in.get();
               while (isspace(ch))
                  ch = in.get();
               in.unget();
               value.read(in, const_cast<ReadParameters&>(params));
               const_cast<ReadParameters&>(params).clear();
               ch = in.get();
               while (isspace(ch))
                  ch = in.get();
            };
         };
      };
   };

   ch = in.get();
   while (isspace(ch))
      ch = in.get();
   if (ch != '=')
      throw STG::EReadError();
   in.assume(" [");
   BuiltReal min, max, readMin, readMax;
   readMin.read(in, (typename BuiltReal::ReadParameters&) const_cast<ReadParameters&>(params));
   ((typename BuiltReal::ReadParameters&) const_cast<ReadParameters&>(params)).clear();
   in.assume(", ");
   readMax.read(in, (typename BuiltReal::ReadParameters&) const_cast<ReadParameters&>(params));
   ((typename BuiltReal::ReadParameters&) const_cast<ReadParameters&>(params)).clear();
   in.assume(']');
   retrieveBound(min, max, false /* hasExternalCoefficient */);
   if (min != readMin)
      throw STG::EReadError();
   if (max != readMax)
      throw STG::EReadError();
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::assume(ISBase& in,
      const STG::IOObject::FormatParameters& aparams) const {
   const auto& params = (const ReadParameters&) aparams;
   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   bool isRaw = params.isRaw();
   bool isInterval = params.isInterval();
   bool isFirst = true;
   BuiltReal min, max;
   if (isInterval || (!isRaw && (!dCentral.isZero() || isEmpty()))) {
      if (!isInterval) {
         if (params.doesReadExternal() && apcCentralAdditions.isValid()
               && apcCentralAdditions->isExternal()) {
            in.assume('(');
            apcCentralAdditions->assume(in, params);
            in.assume(')');
         }
         else {
            BuiltReal value;
            value.read(in, const_cast<ReadParameters&>(params));
            const_cast<ReadParameters&>(params).clear();
            if ((!apcCentralAdditions.isValid() ? dCentral : apcCentralAdditions->getValue())
                  != value)
               throw STG::EReadError();
         }
         isFirst = false;
      };
      min = max = dCentral;
   };
   Cursor cursor(*this);
   if (cursor.setToFirst()) {
      do {
         if (!isInterval) {
            if (!isRaw && !isFirst)
               in.assume(" + ");
            isFirst = false;
         };
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const auto& coeff = ((const Coefficient&) cursor.globalElementAt());
         const BuiltReal& value = coeff.getValue();
         if (value.isPositive()) {
            min.minusAssign(value, minParams);
            max.plusAssign(value, maxParams);
         }
         else {
            min.plusAssign(value, minParams);
            max.minusAssign(value, maxParams);
         };
         minParams.clear();
         maxParams.clear();
         if (!isInterval) {
            if (params.doesReadExternal() && coeff.isExternal()) {
               in.assume('(');
               coeff.assume(in, params);
               in.assume(')');
            }
            else {
               BuiltReal temp;
               temp.read(in, const_cast<ReadParameters&>(params));
               const_cast<ReadParameters&>(params).clear();
               if (temp != value)
                  throw STG::EReadError();
            };
            if (!isRaw) in.assume('*');
            const Symbol& symbol = cursor.elementAt();
            Symbol::Type type = symbol.getType();
            if (isRaw) {
               in.assume((char) type);
            }
            else
               in.assume(getSymbolPrefix(type));
            int order = 0;
            in.read(order, isRaw);
            if (order != symbol.getOrder())
               throw STG::EReadError();
            if (type == Symbol::TDefined && params.hasMergeTable() && params.doesReadDefinition()) {
               typedef DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) DefinedSymbol;
               AssumeCondition(dynamic_cast<const DefinedSymbol*>(&symbol))
               in.assume(" {");
               thisType definition;
               definition.read(in, params);
               BuiltReal highLevelError;
               definition.plusAssign(((const DefinedSymbol&) symbol).getDefinition(),
                     PCSourceRValue, params.ssymbolsManager(), highLevelError, true /* isMinus */,
                     false /* hasExternalCoefficient */);
               in.assume(" }");
               if (!definition.isAtomic() || !definition.getCentral().isZero()
                     || !highLevelError.isZero())
                  throw STG::EReadError();
            };
         };
      } while (cursor.setToNext());
   };
   if (isInterval || !isRaw) {
      if (!isRaw) {
         if (!isInterval)
            in.assume(" = ");
         in.assume('[');
      };
      BuiltReal temp;
      temp.read(in, const_cast<ReadParameters&>(params));
      const_cast<ReadParameters&>(params).clear();
      if (temp != min)
         throw STG::EReadError();
      if (!isRaw)
         in.assume(", ");
      temp.read(in, const_cast<ReadParameters&>(params));
      const_cast<ReadParameters&>(params).clear();
      if (temp != max)
         throw STG::EReadError();
      if (!isRaw)
         in.assume(']');
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::_write(OSBase& out,
      const STG::IOObject::FormatParameters& aparams) const {
   const auto& params = (const WriteParameters&) aparams;
   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   bool isRaw = params.isRaw();
   bool isInterval = params.isInterval();
   bool isFirst = true;
   BuiltReal min, max;
   if (isInterval || (!isRaw && (!dCentral.isZero() || apcCentralAdditions.isValid() || isEmpty()))) {
      if (!isInterval) {
         if (!params.doesWriteExternal() || !apcCentralAdditions.isValid()
               || !apcCentralAdditions->isExternal()) {
            if (!params.doesWriteExternal() || !apcCentralAdditions.isValid())
               dCentral.write(out, (const typename BuiltReal::WriteParameters&) params);
            else
               apcCentralAdditions->getValue().write(out, (const typename BuiltReal::WriteParameters&) params);
         }
         else {
            out.put('(');
            apcCentralAdditions->write(out, params);
            out.put(')');
         }
         isFirst = false;
      };
      min = max = dCentral;
   };
   Cursor cursor(*this);
   bool doesWriteSymbolPrefix = params.doesWriteSymbolPrefix();
   if (cursor.setToFirst()) {
      do {
         if (!isInterval) {
            if (!isRaw && !isFirst) out.writesome(" + ");
            isFirst = false;
         };
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const auto& coeff = ((const Coefficient&) cursor.globalElementAt());
         const BuiltReal& value = coeff.getValue();
         if (value.isPositive()) {
            min.minusAssign(value, minParams);
            max.plusAssign(value, maxParams);
         }
         else {
            min.plusAssign(value, minParams);
            max.minusAssign(value, maxParams);
         };
         minParams.clear();
         maxParams.clear();
         if (!isInterval) {
            if (!params.doesWriteExternal() || !coeff.isExternal())
               value.write(out, (const typename BuiltReal::WriteParameters&) params);
            else {
               out.put('(');
               coeff.write(out, params);
               out.put(')');
            }
            if (!isRaw) out.put('*');
            const Symbol& symbol = cursor.elementAt();
            Symbol::Type type = symbol.getType();
            if (isRaw) {
               out.put(type);
            }
            else if (!doesWriteSymbolPrefix)
               out.writesome(getSymbolPrefix(type));
            else
               out.writesome(symbol.getOwnPrefix());
            out.write(symbol.getOrder(), isRaw);
            if (type == Symbol::TDefined && params.doesWriteDefinition()) {
               typedef DefineDefinedSymbol DefineEquationTemplateParameters(URealBitsNumber) DefinedSymbol;
               AssumeCondition(dynamic_cast<const DefinedSymbol*>(&symbol))
               out.writesome(" {");
               ((const DefinedSymbol&) symbol).getDefinition().write(out, params);
               out.writesome(" }");
            };
         };
      } while (cursor.setToNext());
   };
   if (isInterval || !isRaw) {
      if (!isRaw) {
         if (!isInterval)
            out.writesome(" = ");
         out.put('[');
      };
      min.write(out, (const typename BuiltReal::WriteParameters&) params);
      if (!isRaw)
         out.writesome(", ");
      max.write(out, (const typename BuiltReal::WriteParameters&) params);
      if (!isRaw)
         out.put(']');
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::invariant() const {
   Cursor cursor(*this);
   if (cursor.setToFirst()) {
      if (((const Coefficient&) cursor.globalElementAt()).getValue().isZero())
         return false;
      const Symbol* previous = &cursor.elementAt();
      while (cursor.setToNext()) {
         if (((const Coefficient&) cursor.globalElementAt()).getValue().isZero())
            return false;
         const Symbol* next = &cursor.elementAt();
         if (!(previous < next))
            return false;
      };
   };
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)&
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::setInterval(
      const BuiltReal& min, const BuiltReal& max, SymbolsManager& manager) {
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   clear(&manager);
   dCentral = min;
   if (max.compareValue(min) == CRGreater) {
      dCentral.plusAssign(max, nearestParams);
      dCentral.divAssign(2, nearestParams);

      Symbol* symbol = manager.createNoiseSymbol();
      GlobalElement* coefficient = addElement(*symbol);
      AssumeCondition(dynamic_cast<const Coefficient*>(coefficient))
      if (!nearestParams.isUpApproximate()) {
         BuiltReal coefficientValue(max);
         coefficientValue.minusAssign(dCentral, maxParams);
         ((Coefficient&) *coefficient).setValue(coefficientValue);
      }
      else {
         BuiltReal coefficientValue(dCentral);
         coefficientValue.minusAssign(min, maxParams);
         ((Coefficient&) *coefficient).setValue(coefficientValue);
      };
      maxParams.clear();
      nearestParams.clear();
      ++basicOperationCounter;
   }
   return *this;
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)&
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::setIntervalWithHighLevel(
      const BuiltReal& min, const BuiltReal& max, SymbolsManager& manager) {
   clear(&manager);
   dCentral = min;
   if (max.compareValue(min) == CRGreater) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      dCentral.plusAssign(max, nearestParams);
      dCentral.divAssign(2, nearestParams);

      Symbol* symbol = manager.createHighLevelSymbol();
      GlobalElement* coefficient = addElement(*symbol);
      AssumeCondition(dynamic_cast<const Coefficient*>(coefficient))
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      if (!nearestParams.isUpApproximate()) {
         BuiltReal coefficientValue(max);
         coefficientValue.minusAssign(dCentral, maxParams);
         ((Coefficient&) *coefficient).setValue(coefficientValue);
      }
      else {
         BuiltReal coefficientValue(dCentral);
         coefficientValue.minusAssign(min, maxParams);
         ((Coefficient&) *coefficient).setValue(coefficientValue);
      };
      maxParams.clear();
      nearestParams.clear();
      ++basicOperationCounter;
   }
   return *this;
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)&
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::setInputInterval(
      const BuiltReal& min, const BuiltReal& max, SymbolsManager& manager) {
   clear(&manager);
   dCentral = min;
   if (max.compareValue(min) == CRGreater) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      dCentral.plusAssign(max, nearestParams);
      dCentral.divAssign(2, nearestParams);

      Symbol* symbol = manager.createCentralSymbol();
      GlobalElement* coefficient = addElement(*symbol);
      AssumeCondition(dynamic_cast<const Coefficient*>(coefficient))
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      if (!nearestParams.isUpApproximate()) {
         BuiltReal coefficientValue(max);
         coefficientValue.minusAssign(dCentral, maxParams);
         ((Coefficient&) *coefficient).setValue(coefficientValue);
      }
      else {
         BuiltReal coefficientValue(dCentral);
         coefficientValue.minusAssign(min, maxParams);
         ((Coefficient&) *coefficient).setValue(coefficientValue);
      };
      maxParams.clear();
      nearestParams.clear();
      ++basicOperationCounter;
   };
   return *this;
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::retrieveBound(BuiltReal& min,
      BuiltReal& max, bool hasExternalCoefficient) const {
   if (!hasExternalCoefficient || !apcCentralAdditions.isValid())
      min = max = dCentral;
   else
      apcCentralAdditions->retrieveBound(min, max);
   ++basicOperationCounter;
   Cursor cursor(*this);
   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
      AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
      const Coefficient& coefficient = (const Coefficient&) cursor.globalElementAt();
      const BuiltReal& coefficientValue = coefficient.getValue();
      ++basicOperationCounter;
      addAssignBoundFromCoeff(min, max, coefficient, coefficientValue, minParams, maxParams,
            hasExternalCoefficient);
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::retrieveMidRange(
      BuiltReal& midRange, bool hasExternalCoefficient) const {
   ++basicOperationCounter;
   Cursor cursor(*this);
   midRange.clear();
   BuiltReal min;

   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
      AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
      const Coefficient& coefficient = (const Coefficient&) cursor.globalElementAt();
      const BuiltReal& coefficientValue = coefficient.getValue();
      ++basicOperationCounter;
      addAssignBoundFromCoeff(min, midRange, coefficient, coefficientValue, minParams, maxParams,
            hasExternalCoefficient);
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::setPositiveCoefficients() {
   AssumeCondition(!apcCentralAdditions.isValid())
   if (dCentral.isNegative())
      dCentral.opposite();
   Cursor cursor(*this);
   while (cursor.setToNext()) {
      auto& coefficient = cursor.globalElementSAt();
      AssumeCondition(dynamic_cast<const Coefficient*>(&coefficient)
            && !((const Coefficient&) coefficient).isExternal())
      if (((const Coefficient&) coefficient).getValue().isNegative())
         ((Coefficient&) coefficient).getSValue().opposite();
   }
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::plusAssignPositiveCoefficients(
      const thisType& source) {
   AssumeCondition(!apcCentralAdditions.isValid() && !source.apcCentralAdditions.isValid()
         && !dCentral.isNegative())
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   if (source.dCentral.isPositive())
      dCentral.plusAssign(source.dCentral, maxParams);
   else
      dCentral.minusAssign(source.dCentral, maxParams);
   maxParams.clear();

   Cursor thisCursor(*this), sourceCursor(source);
   if (thisCursor.setToFirst()) {
      Symbol* thisSymbol = &thisCursor.elementSAt();
      if (sourceCursor.setToFirst()) {
         Symbol* sourceSymbol = &sourceCursor.elementSAt();
         do {
            ++basicOperationCounter;
            ComparisonResult compare = thisSymbol->compare(*sourceSymbol);
            if (compare == CREqual) {
               auto& thisCoeff = thisCursor.globalElementSAt();
               const auto& sourceCoeff = sourceCursor.globalElementAt();
               AssumeCondition(dynamic_cast<const Coefficient*>(&thisCoeff)
                     && dynamic_cast<const Coefficient*>(&sourceCoeff)
                     && !((const Coefficient&) thisCoeff).isExternal()
                     && !((const Coefficient&) sourceCoeff).isExternal()
                     && ((const Coefficient&) thisCoeff).getValue().isPositive())
               if (((const Coefficient&) sourceCoeff).getValue().isPositive())
                  ((Coefficient&) thisCoeff).getSValue().plusAssign(
                        ((const Coefficient&) sourceCoeff).getValue(), maxParams);
               else
                  ((Coefficient&) thisCoeff).getSValue().minusAssign(
                        ((const Coefficient&) sourceCoeff).getValue(), maxParams);
               maxParams.clear();
               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else if (compare == CRGreater) {
               const auto& sourceCoeff = sourceCursor.globalElementAt();
               AssumeCondition(dynamic_cast<const Coefficient*>(&sourceCoeff)
                     && !((const Coefficient&) sourceCoeff).isExternal())
               Coefficient* coeff = (Coefficient*) absorbGlobalElementBefore(
                     sourceCoeff.createSCopy(), thisCursor);
               if (coeff->getValue().isNegative())
                  coeff->getSValue().opposite();
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else {
               AssumeCondition(compare == CRLess)
               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
            }
         } while (thisSymbol && sourceSymbol);

         while (sourceSymbol) {
            const auto& sourceCoeff = sourceCursor.globalElementAt();
            AssumeCondition(dynamic_cast<const Coefficient*>(&sourceCoeff)
                  && !((const Coefficient&) sourceCoeff).isExternal())
            Coefficient* coeff = (Coefficient*) absorbGlobalElement(sourceCoeff.createSCopy());
            if (coeff->getValue().isNegative())
               coeff->getSValue().opposite();
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         };
      };
   }
   else {
      inherited::assignFromGlobal(source);
      Cursor cursor(*this);
      while (cursor.setToNext()) {
         auto& coefficient = cursor.globalElementSAt();
         AssumeCondition(dynamic_cast<const Coefficient*>(&coefficient)
               && !((const Coefficient&) coefficient).isExternal())
         if (((const Coefficient&) coefficient).getValue().isNegative())
            ((Coefficient&) coefficient).getSValue().opposite();
      }
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::plusAssignBothCoeffs(
      Cursor& thisCursor, const Cursor& sourceCursor, Symbol* thisSymbol, Symbol* sourceSymbol,
      PolicyCall policyCall, SymbolsManager& manager, BuiltReal& referenceForAbsorption,
      Coefficient*& reusableCoeff, BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType,
      BuiltReal& highLevelError, bool isMinus, RealReadParameters& nearestParams,
      bool hasExternalCoefficient) {
   Coefficient* thisCoeff = &(Coefficient&) thisCursor.globalElementSAt();
   BuiltReal& thisCoeffValue = thisCoeff->getSValue();
   const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
   const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
   if (thisSymbol == sourceSymbol) {
      bool isXValue = (policyCall == PCSourceXValue) && thisSymbol->isDoubleReferenced();
      if (!isMinus)
         addAssignToCoefficient(thisCoeff, thisCoeffValue, sourceCoeff, sourceCoeffValue,
               highLevelError, thisCursor, nearestParams, manager, hasExternalCoefficient);
      else
         subAssignToCoefficient(thisCoeff, thisCoeffValue, sourceCoeff, sourceCoeffValue,
               highLevelError, thisCursor, nearestParams, manager, hasExternalCoefficient);
      if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
            && (TypeBaseFloatAffine::doesAbsorbHighLevel()
               || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
                  && isNegligeable(*thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
         if (reusableCoeffValue && reusableType == thisSymbol->getType()) {
            addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *thisCoeff, thisCoeffValue,
                  highLevelError, nearestParams, manager, hasExternalCoefficient);
            setToZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient);
         }
         else if (!isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
            reusableCoeff = thisCoeff;
            reusableCoeffValue = &thisCoeffValue;
            reusableType = thisSymbol->getType();
         };
      };
   }
   else {
      bool isXValue = thisSymbol->isSingleReferenced();
      if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
            && (TypeBaseFloatAffine::doesAbsorbHighLevel()
               || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
                  && isNegligeable(*thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient)
                  && isNegligeable(sourceCoeff, sourceCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
         if (reusableCoeffValue && reusableType == thisSymbol->getType()) {
            ++basicOperationCounter;
            addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *thisCoeff, thisCoeffValue,
                  highLevelError, nearestParams, manager, hasExternalCoefficient);
            setToZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient);
         }
         else if (!isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
            reusableCoeff = thisCoeff;
            reusableCoeffValue = &thisCoeffValue;
            reusableType = thisSymbol->getType();
         };
      }
      if (!reusableCoeffValue || reusableType != thisSymbol->getType()) {
         Symbol* symbol = manager.createMarkedNoiseSymbol(thisSymbol->getOrder());
         replaceElementAtWith(thisCursor, *symbol);
         reusableCoeff = thisCoeff;
         reusableCoeffValue = &thisCoeffValue;
         reusableType = symbol->getType();
         if (thisSymbol->getType() == Symbol::THighLevel && !thisSymbol->isReferenced())
            manager.freeHighLevelSymbol((HighLevelSymbol*) thisSymbol);
      };
      addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, sourceCoeff, sourceCoeffValue,
            highLevelError, nearestParams, manager, hasExternalCoefficient);
   };
   if (isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
      if (reusableCoeffValue == &thisCoeffValue) {
         reusableCoeff = nullptr;
         reusableCoeffValue = nullptr;
         reusableType = Symbol::TUndefined;
      };
      HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
            && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
      Cursor thisRemoveCursor(thisCursor);
      thisCursor.setToPrevious();
      removeAt(thisRemoveCursor);
      if (symbolToFree)
         manager.freeHighLevelSymbol(symbolToFree);
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::plusAssignThisCoeff(
      Cursor& thisCursor, Symbol* thisSymbol, SymbolsManager& manager,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, bool hasExternalCoefficient) {
   bool isXValue = thisSymbol->isSingleReferenced();
   Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
   BuiltReal& thisCoeffValue = thisCoeff.getSValue();
   if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
         && (TypeBaseFloatAffine::doesAbsorbHighLevel()
            || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
               && isNegligeable(thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
      if (reusableCoeffValue && thisSymbol->getType() == reusableType) {
         ++basicOperationCounter;
         addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, thisCoeff, thisCoeffValue,
               highLevelError, nearestParams, manager, hasExternalCoefficient);
         HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
               && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
         Cursor thisRemoveCursor(thisCursor);
         thisCursor.setToPrevious();
         removeAt(thisRemoveCursor);
         if (symbolToFree)
            manager.freeHighLevelSymbol(symbolToFree);
      }
      else {
         reusableCoeff = &thisCoeff;
         reusableCoeffValue = &thisCoeffValue;
         reusableType = thisSymbol->getType();
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::plusAssignSourceCoeff(
      Cursor* thisCursor, const Cursor& sourceCursor, Symbol* sourceSymbol, PolicyCall policyCall,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      bool isMinus, RealReadParameters& nearestParams, SymbolsManager& manager,
      bool hasExternalCoefficient) {
   ++basicOperationCounter;
   bool isXValue = (policyCall == PCSourceXValue) && sourceSymbol->isSingleReferenced();
   const Coefficient& sourceCoeff = (const Coefficient&) sourceCursor.globalElementAt();
   const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
   if (isXValue || (sourceSymbol->getType() == Symbol::THighLevel
         && (TypeBaseFloatAffine::doesAbsorbHighLevel()
            || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
               && isNegligeable(sourceCoeff, sourceCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
      if (reusableCoeffValue && sourceSymbol->getType() == reusableType)
         addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, sourceCoeff, sourceCoeffValue,
               highLevelError, nearestParams, manager, hasExternalCoefficient);
      else {
         Coefficient* coeff;
         if (thisCursor)
            coeff = (Coefficient*) absorbGlobalElementBefore(sourceCoeff.createSCopy(), *thisCursor);
         else
            coeff = (Coefficient*) absorbGlobalElement(sourceCoeff.createSCopy());
         if (isMinus)
            oppositeAssignCoefficient(*coeff, coeff->getSValue(), hasExternalCoefficient);
         if (!reusableCoeffValue) {
            reusableCoeff = coeff;
            reusableCoeffValue = &coeff->getSValue();
            reusableType = sourceSymbol->getType();
         }
      }
   }
   else {
      Coefficient* coeff;
      if (thisCursor)
         coeff = (Coefficient*) absorbGlobalElementBefore(sourceCoeff.createSCopy(), *thisCursor);
      else
         coeff = (Coefficient*) absorbGlobalElement(sourceCoeff.createSCopy());
      if (isMinus)
         oppositeAssignCoefficient(*coeff, coeff->getSValue(), hasExternalCoefficient);
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::plusAssign(
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager,
      BuiltReal& highLevelError, bool isMinus, bool hasExternalCoefficient) {
   if (this == &source) {
      if (isMinus)
         clear(&manager);
      else {
         thisType sourceCopy(source);
         plusAssign(sourceCopy, PCSourceXValue, manager, highLevelError, isMinus, hasExternalCoefficient);
      };
      return;
   };
   ++basicOperationCounter;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   if (!isMinus)
      addAssignOptionCentral(dCentral, apcCentralAdditions, source.dCentral, source.apcCentralAdditions,
            highLevelError, nearestParams, manager, hasExternalCoefficient);
   else
      subAssignOptionCentral(dCentral, apcCentralAdditions, source.dCentral, source.apcCentralAdditions,
            highLevelError, nearestParams, manager, hasExternalCoefficient);

   Coefficient* reusableCoeff = nullptr;
   BuiltReal* reusableCoeffValue = nullptr;
   Symbol::Type reusableType = Symbol::TUndefined;
   BuiltReal referenceForAbsorption;
   if (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()) {
      computeReferenceForAbsorption(referenceForAbsorption);
      BuiltReal sourceReference;
      source.computeReferenceForAbsorption(sourceReference);
      referenceForAbsorption.plusAssign(sourceReference, TypeBaseFloatAffine::maxParams());
      TypeBaseFloatAffine::maxParams().clear();
   };

   Cursor thisCursor(*this), sourceCursor(source);
   if (thisCursor.setToFirst()) {
      Symbol* thisSymbol = &thisCursor.elementSAt();
      if (sourceCursor.setToFirst()) {
         Symbol* sourceSymbol = &sourceCursor.elementSAt();
         do {
            ++basicOperationCounter;
            ComparisonResult compare = thisSymbol->compare(*sourceSymbol);
            if (compare == CREqual) {
               plusAssignBothCoeffs(thisCursor, sourceCursor, thisSymbol, sourceSymbol,
                     policyCall, manager, referenceForAbsorption, reusableCoeff, reusableCoeffValue,
                     reusableType, highLevelError, isMinus, nearestParams, hasExternalCoefficient);
               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else if (compare == CRLess) {
               plusAssignThisCoeff(thisCursor, thisSymbol,
                     manager, referenceForAbsorption, reusableCoeff, reusableCoeffValue,
                     reusableType, highLevelError, nearestParams, hasExternalCoefficient);
               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
            }
            else if (compare == CRGreater) {
               plusAssignSourceCoeff(&thisCursor, sourceCursor, sourceSymbol, policyCall,
                     referenceForAbsorption, reusableCoeff, reusableCoeffValue, reusableType,
                     highLevelError, isMinus, nearestParams, manager, hasExternalCoefficient);
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else
               {  AssumeUncalled }
         } while (thisSymbol && sourceSymbol);

         while (thisSymbol) {
            plusAssignThisCoeff(thisCursor, thisSymbol,
                  manager, referenceForAbsorption, reusableCoeff, reusableCoeffValue,
                  reusableType, highLevelError, nearestParams, hasExternalCoefficient);
            thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
         };
         while (sourceSymbol) {
            plusAssignSourceCoeff(nullptr, sourceCursor, sourceSymbol, policyCall,
                  referenceForAbsorption, reusableCoeff, reusableCoeffValue, reusableType,
                  highLevelError, isMinus, nearestParams, manager, hasExternalCoefficient);
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         };
      };
   }
   else {
      if (policyCall == PCSourceXValue)
         inherited::operator=(std::move(const_cast<thisType&>(source)));
      else
         inherited::assignFromGlobal(source);
      if (isMinus) {
         while (thisCursor.setToNext()) {
            Coefficient& coeff = (Coefficient&) thisCursor.globalElementSAt();
            oppositeAssignCoefficient(coeff, coeff.getSValue(), hasExternalCoefficient);
         };
      };
   };
   if (policyCall == PCSourceXValue)
      const_cast<thisType&>(source).clear(&manager);
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::addHighLevel(
      const BuiltReal& highLevelError, SymbolsManager& manager, bool hasExternalCoefficient) {
   if (!highLevelError.isZero()) {
      if (!TypeBaseFloatAffine::doesAbsorbHighLevel()) {
         bool isAdded = false;
         if (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()) {
            BuiltReal reference;
            computeReferenceForAbsorption(reference);
            isAdded = isNegligeable(highLevelError, reference);
            if (isAdded) {
               HighLevelSymbol symbol;
               symbol.setOrder(manager.getHighLevelSymbolOrder());
               Cursor cursor(*this);
               if (cursor.setToLast()) {
                  isAdded = false;
                  while (cursor.elementAt().getType() == Symbol::THighLevel) {
                     const Coefficient& coeff = (Coefficient&) cursor.globalElementSAt();
                     isAdded = isNegligeable(coeff, coeff.getValue(), reference, hasExternalCoefficient);
                     if (isAdded || !cursor.setToPrevious())
                        break;
                  };
                  if (isAdded) {
                     Symbol* oldSymbol = &cursor.elementSAt();
                     BuiltReal oldCoefficient = ((const Coefficient&) cursor.globalElementAt()).getValue();
                     AssumeCondition(dynamic_cast<const HighLevelSymbol*>(oldSymbol))
                     Symbol* newSymbol = manager.createHighLevelSymbol();
                     {  Cursor removeCursor(cursor);
                        if (cursor.setToNext())
                           while (cursor.elementAt() < *newSymbol && cursor.setToNext());
                        removeAt(removeCursor);
                     }
                     Coefficient* coeff = (Coefficient*) addElementBefore(*newSymbol, cursor);
                     coeff->setValue(oldCoefficient);
                     BuiltReal& coefficient = coeff->getSValue();
                     auto& minParams = TypeBaseFloatAffine::minParams();
                     auto& maxParams = TypeBaseFloatAffine::maxParams();
                     if (coefficient.isPositive() == highLevelError.isPositive()) {
                        coefficient.plusAssign(highLevelError, coefficient.isPositive() ? maxParams : minParams);
                        (coefficient.isPositive() ? maxParams : minParams).clear();
                     }
                     else {
                        coefficient.minusAssign(highLevelError, coefficient.isPositive() ? maxParams : minParams);
                        (coefficient.isPositive() ? maxParams : minParams).clear();
                     };
                     if (!oldSymbol->isReferenced())
                        manager.freeHighLevelSymbol((HighLevelSymbol*) oldSymbol);
                  }
                  else {
                     Symbol* newSymbol = manager.createHighLevelSymbol();
                     Cursor cursor(*this);
                     if (cursor.setToLast())
                        while (cursor.elementAt() > *newSymbol && cursor.setToPrevious());
                     Coefficient* coeff = (Coefficient*) addElementAfter(*newSymbol, cursor);
                     coeff->setValue(highLevelError);
                     if (!highLevelError.isPositive())
                        oppositeAssignCoefficient(*coeff, coeff->getSValue(), hasExternalCoefficient);
                     isAdded = true;
                  }
               }
            };
         }
         if (!isAdded) {
            Symbol* symbol = manager.createNoiseSymbol();
            Cursor cursor(*this);
            if (cursor.setToLast())
               while (cursor.elementAt() > *symbol && cursor.setToPrevious());
            Coefficient* coefficient = (Coefficient*) addElementAfter(*symbol, cursor);
            coefficient->setValue(highLevelError);
         };
      }
      else {
         Symbol* symbol = manager.createHighLevelSymbol();
         Cursor cursor(*this);
         bool isAdded = false;
         if (cursor.setToLast()) {
            while ((cursor.elementAt() > *symbol) && cursor.setToPrevious());
            if (cursor.isValid() && cursor.elementAt().getType() == Symbol::THighLevel) {
               Symbol* oldSymbol = &cursor.elementSAt();
               BuiltReal oldCoefficient = ((const Coefficient&) cursor.globalElementAt()).getValue();
               AssumeCondition(dynamic_cast<const HighLevelSymbol*>(oldSymbol))
               {  Cursor removeCursor(cursor);
                  if (cursor.setToNext())
                     while (cursor.elementAt() < *symbol && cursor.setToNext());
                  removeAt(removeCursor);
               }
               Coefficient* coeff = (Coefficient*) addElementBefore(*symbol, cursor);
               coeff->setValue(oldCoefficient);
               BuiltReal& coefficient = coeff->getSValue();
               auto& maxParams = TypeBaseFloatAffine::maxParams();
               auto& minParams = TypeBaseFloatAffine::minParams();
               if (coefficient.isPositive() == highLevelError.isPositive()) {
                  coefficient.plusAssign(highLevelError, coefficient.isPositive() ? maxParams : minParams);
                  (coefficient.isPositive() ? maxParams : minParams).clear();
               }
               else {
                  coefficient.minusAssign(highLevelError, coefficient.isPositive() ? maxParams : minParams);
                  (coefficient.isPositive() ? maxParams : minParams).clear();
               };
               isAdded = true;
               if (!oldSymbol->isReferenced())
                  manager.freeHighLevelSymbol((HighLevelSymbol*) oldSymbol);
            }
         }
         if (!isAdded) {
            if (cursor.setToLast())
               while (cursor.elementAt() > *symbol && cursor.setToPrevious());
            Coefficient* coefficient = (Coefficient*) addElementAfter(*symbol, cursor);
            coefficient->setValue(highLevelError);
         };
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::plusAssign(
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager, bool hasExternalCoefficient) {
   BuiltReal highLevelError; // no need to separate min from max, since it is not representable with dCentral
   plusAssign(source, policyCall, manager, highLevelError, false /* isMinus */, hasExternalCoefficient);
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::minusAssign(
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager, bool hasExternalCoefficient) {
   BuiltReal highLevelError; // no need to separate min from max, since it is not representable with dCentral
   plusAssign(source, policyCall, manager, highLevelError, true /* isMinus */, hasExternalCoefficient);
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::oppositeAssign(bool hasExternalCoefficient) {
   dCentral.opposite();
   if (apcCentralAdditions.isValid())
      apcCentralAdditions->oppositeAssign();
   ++basicOperationCounter;
   Cursor thisCursor(*this);
   while (thisCursor.setToNext()) {
      Coefficient& coeff = (Coefficient&) thisCursor.globalElementSAt();
      oppositeAssignCoefficient(coeff, coeff.getSValue(), hasExternalCoefficient);
      ++basicOperationCounter;
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssign(
      const BuiltReal& value, SymbolsManager& manager, BuiltReal& highLevelError,
      bool hasExternalCoefficient) {
   if (value.isZero()) {
      clear(&manager);
      return;
   };
   
   ++basicOperationCounter;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   PNT::AutoPointer<Coefficient> valueAdditions;
   multAssignOptionCentral(dCentral, apcCentralAdditions, value, valueAdditions, highLevelError,
         nearestParams, TypeBaseFloatAffine::maxParams(), manager, hasExternalCoefficient);

   Cursor thisCursor(*this);
   Symbol* thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
   while (thisSymbol) {
      Coefficient& coeff = (Coefficient&) thisCursor.globalElementSAt();
      BuiltReal& coeffValue = coeff.getSValue();
      multAssignToCoefficient(coeff, coeffValue, value, highLevelError, nearestParams, manager,
            hasExternalCoefficient);
      if (isZero(coeff, coeffValue, hasExternalCoefficient)) {
         HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
               && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
         Cursor thisRemoveCursor(thisCursor);
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
         removeAt(thisRemoveCursor);
         if (symbolToFree)
            manager.freeHighLevelSymbol(symbolToFree);
      }
      else
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
      ++basicOperationCounter;
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssign(
      const BuiltReal& value, SymbolsManager& manager, bool hasExternalCoefficient) {
   BuiltReal highLevelError;
   multAssign(value, manager, highLevelError, hasExternalCoefficient);
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::divAssign(const BuiltReal& value,
      SymbolsManager& manager, BuiltReal& highLevelError, bool hasExternalCoefficient) {
   if (value.isZero()) {
      bool isPositive = dCentral.isNegative() == value.isNegative();
      clear(&manager);
      dCentral.setInfty();
      dCentral.setNegative(!isPositive);
      return;
   };
   
   ++basicOperationCounter;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   divAssignOptionCentral(dCentral, apcCentralAdditions, value, highLevelError, nearestParams,
         manager, hasExternalCoefficient);
   if (dCentral.isInfty()) {
      nearestParams.clear();
      BuiltReal central = dCentral;
      clear(&manager);
      dCentral = central;
      return;
   };

   Cursor thisCursor(*this);
   Symbol* thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
   while (thisSymbol) {
      Coefficient& coeff = (Coefficient&) thisCursor.globalElementSAt();
      BuiltReal& coeffValue = coeff.getSValue();
      divAssignToCoefficient(coeff, coeffValue, value, highLevelError, nearestParams, manager,
            hasExternalCoefficient);
      if (isZero(coeff, coeffValue, hasExternalCoefficient)) {
         Cursor thisRemoveCursor(thisCursor);
         HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
               && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
         removeAt(thisRemoveCursor);
         if (symbolToFree)
            manager.freeHighLevelSymbol(symbolToFree);
      }
      else
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
      ++basicOperationCounter;
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::divAssign(unsigned value,
      SymbolsManager& manager, BuiltReal& highLevelError, bool hasExternalCoefficient) {
   if (value == 0) {
      bool isPositive = !dCentral.isNegative();
      clear(&manager);
      dCentral.setInfty();
      dCentral.setNegative(!isPositive);
      return;
   };
   
   ++basicOperationCounter;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   divAssignOptionCentral(dCentral, apcCentralAdditions, value, highLevelError, nearestParams,
         manager, hasExternalCoefficient);
   Cursor thisCursor(*this);
   Symbol* thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
   while (thisSymbol) {
      Coefficient& coeff = (Coefficient&) thisCursor.globalElementSAt();
      BuiltReal& coeffValue = coeff.getSValue();
      divAssignToCoefficient(coeff, coeffValue, value, highLevelError, nearestParams, manager,
            hasExternalCoefficient);
      if (isZero(coeff, coeffValue, hasExternalCoefficient)) {
         Cursor thisRemoveCursor(thisCursor);
         HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
               && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
         removeAt(thisRemoveCursor);
         if (symbolToFree)
            manager.freeHighLevelSymbol(symbolToFree);
      }
      else
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
      ++basicOperationCounter;
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssignAddCrossFromSourceCoeff(
      const Cursor& thisCursor, const Cursor& sourceCursor, BuiltReal& newCrossCoeffValue,
      PNT::AutoPointer<Coefficient>& crossCoeffAdditions, bool& areAllHighLevel,
      BuiltReal& highLevelError, RealReadParameters& nearestParams, RealReadParameters& maxParams,
      SymbolsManager& manager, bool hasExternalCoefficient) {
   Cursor thisCopyCursor(thisCursor);
   const Coefficient& sourceCoeff = (const Coefficient&) sourceCursor.globalElementAt();
   const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
   bool isSourceHighLevel = sourceCursor.elementAt().getType() == Symbol::THighLevel;
   do {
      const Coefficient& thisCopyCoeff = (const Coefficient&) thisCopyCursor.globalElementAt();
      const BuiltReal& thisCopyCoeffValue = thisCopyCoeff.getValue();
      if (areAllHighLevel && !isSourceHighLevel
            && thisCopyCursor.elementAt().getType() != Symbol::THighLevel)
         areAllHighLevel = false;
      ++basicOperationCounter;
      addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions, sourceCoeff, sourceCoeffValue,
            thisCopyCoeff, thisCopyCoeffValue, highLevelError, nearestParams, maxParams, manager,
            hasExternalCoefficient);
   } while (thisCopyCursor.setToNext());
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssignAddCrossFromThisCoeff(
      const Cursor& thisCursor, const Cursor& sourceCursor, BuiltReal& newCrossCoeffValue,
      PNT::AutoPointer<Coefficient>& crossCoeffAdditions, bool& areAllHighLevel,
      BuiltReal& highLevelError, RealReadParameters& nearestParams, RealReadParameters& maxParams,
      SymbolsManager& manager, bool hasExternalCoefficient) {
   Cursor sourceCopyCursor(sourceCursor);
   const Coefficient& thisCoeff = (const Coefficient&) thisCursor.globalElementAt();
   const BuiltReal& thisCoeffValue = thisCoeff.getValue();
   bool isThisHighLevel = thisCursor.elementAt().getType() == Symbol::THighLevel;
   do {
      const Coefficient& sourceCopyCoeff = (const Coefficient&) sourceCopyCursor.globalElementAt();
      const BuiltReal& sourceCopyCoeffValue = sourceCopyCoeff.getValue();
      if (areAllHighLevel && !isThisHighLevel
            && sourceCopyCursor.elementAt().getType() != Symbol::THighLevel)
         areAllHighLevel = false;
      addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions, thisCoeff, thisCoeffValue,
            sourceCopyCoeff, sourceCopyCoeffValue, highLevelError, nearestParams, maxParams,
            manager, hasExternalCoefficient);
   } while (sourceCopyCursor.setToNext());
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssignAddCentralSquareAndCrossFromBothCoeffs(
      const Cursor& thisCursor, const Cursor& sourceCursor, bool areSymbolEquals,
      BuiltReal& newCentral, PNT::AutoPointer<Coefficient>& newCentralAdditions,
      BuiltReal& newSquareCoeffValue, PNT::AutoPointer<Coefficient>& squareCoeffAdditions,
      BuiltReal& newCrossCoeffValue, PNT::AutoPointer<Coefficient>& crossCoeffAdditions,
      bool& areAllHighLevel, BuiltReal& highLevelError, RealReadParameters& nearestParams,
      RealReadParameters& maxParams, SymbolsManager& manager, bool hasExternalCoefficient) {
   if (areSymbolEquals) {
      const Coefficient& thisCoeff = (const Coefficient&) thisCursor.globalElementAt();
      const BuiltReal& thisCoeffValue = thisCoeff.getValue();
      const Coefficient& sourceCoeff = (const Coefficient&) sourceCursor.globalElementAt();
      const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
      bool isThisHighLevel = thisCursor.elementAt().getType() == Symbol::THighLevel;
      bool isSourceHighLevel = sourceCursor.elementAt().getType() == Symbol::THighLevel;
      if (areAllHighLevel && !isSourceHighLevel && !isThisHighLevel)
         areAllHighLevel = false;
      addAssignSemiProductToValue(newSquareCoeffValue, squareCoeffAdditions,
            thisCoeff, thisCoeffValue, sourceCoeff, sourceCoeffValue, newCentral,
            newCentralAdditions, highLevelError, nearestParams,
            maxParams, manager, hasExternalCoefficient);

      Cursor thisCopyCursor(thisCursor);
      Cursor sourceCopyCursor(sourceCursor);
      Symbol* thisCopySymbol = thisCopyCursor.setToNext() ? &thisCopyCursor.elementSAt() : nullptr;
      Symbol* sourceCopySymbol = sourceCopyCursor.setToNext() ? &sourceCopyCursor.elementSAt() : nullptr;
      ++basicOperationCounter;
      while (thisCopySymbol || sourceCopySymbol) {
         if (thisCopySymbol && sourceCopySymbol) {
            ComparisonResult compareGreater = thisCopySymbol->compare(*sourceCopySymbol);
            ++basicOperationCounter;
            if (compareGreater == CRGreater) {
               if (areAllHighLevel && !isThisHighLevel
                     && sourceCopyCursor.elementAt().getType() != Symbol::THighLevel)
                  areAllHighLevel = false;
               const Coefficient& sourceCopyCoeff = (const Coefficient&) sourceCopyCursor.globalElementAt();
               const BuiltReal& sourceCopyCoeffValue = sourceCopyCoeff.getValue();
               addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions,
                     thisCoeff, thisCoeffValue, sourceCopyCoeff, sourceCopyCoeffValue,
                     highLevelError, nearestParams, maxParams, manager, hasExternalCoefficient);
               sourceCopySymbol = sourceCopyCursor.setToNext() ? &sourceCopyCursor.elementSAt() : nullptr;
            }
            else if (compareGreater == CRLess) {
               if (areAllHighLevel && !isSourceHighLevel
                     && thisCopyCursor.elementAt().getType() != Symbol::THighLevel)
                  areAllHighLevel = false;
               const Coefficient& thisCopyCoeff = (const Coefficient&) thisCopyCursor.globalElementAt();
               const BuiltReal& thisCopyCoeffValue = thisCopyCoeff.getValue();
               addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions,
                     sourceCoeff, sourceCoeffValue, thisCopyCoeff, thisCopyCoeffValue,
                     highLevelError, nearestParams, maxParams, manager, hasExternalCoefficient);
               thisCopySymbol = thisCopyCursor.setToNext() ? &thisCopyCursor.elementSAt() : nullptr;
            }
            else {
               AssumeCondition(compareGreater == CREqual)
               if (areAllHighLevel && !isThisHighLevel
                     && sourceCopyCursor.elementAt().getType() != Symbol::THighLevel)
                  areAllHighLevel = false;
               if (areAllHighLevel && !isSourceHighLevel
                     && thisCopyCursor.elementAt().getType() != Symbol::THighLevel)
                  areAllHighLevel = false;
               const Coefficient& sourceCopyCoeff = (const Coefficient&) sourceCopyCursor.globalElementAt();
               const BuiltReal& sourceCopyCoeffValue = sourceCopyCoeff.getValue();
               const Coefficient& thisCopyCoeff = (const Coefficient&) thisCopyCursor.globalElementAt();
               const BuiltReal& thisCopyCoeffValue = thisCopyCoeff.getValue();
               addAssignDoubleAbsProduct(newCrossCoeffValue, crossCoeffAdditions,
                     thisCoeff, thisCoeffValue, sourceCopyCoeff, sourceCopyCoeffValue,
                     sourceCoeff, sourceCoeffValue, thisCopyCoeff, thisCopyCoeffValue,
                     highLevelError, nearestParams, maxParams, manager, hasExternalCoefficient);
               thisCopySymbol = thisCopyCursor.setToNext() ? &thisCopyCursor.elementSAt() : nullptr;
               sourceCopySymbol = sourceCopyCursor.setToNext() ? &sourceCopyCursor.elementSAt() : nullptr;
            };
         }
         else if (thisCopySymbol) {
            if (areAllHighLevel && !isSourceHighLevel
                  && thisCopyCursor.elementAt().getType() != Symbol::THighLevel)
               areAllHighLevel = false;
            const Coefficient& thisCopyCoeff = (const Coefficient&) thisCopyCursor.globalElementAt();
            const BuiltReal& thisCopyCoeffValue = thisCopyCoeff.getValue();
            addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions, sourceCoeff,
                  sourceCoeffValue, thisCopyCoeff, thisCopyCoeffValue, highLevelError,
                  nearestParams, maxParams, manager, hasExternalCoefficient);
            thisCopySymbol = thisCopyCursor.setToNext() ? &thisCopyCursor.elementSAt() : nullptr;
            ++basicOperationCounter;
         }
         else { // sourceCopySymbol
            if (areAllHighLevel && !isThisHighLevel && sourceCopyCursor.elementAt().getType() != Symbol::THighLevel)
               areAllHighLevel = false;
            const Coefficient& sourceCopyCoeff = (const Coefficient&) sourceCopyCursor.globalElementAt();
            const BuiltReal& sourceCopyCoeffValue = sourceCopyCoeff.getValue();
            addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions, thisCoeff, thisCoeffValue,
                  sourceCopyCoeff, sourceCopyCoeffValue, highLevelError, nearestParams, maxParams,
                  manager, hasExternalCoefficient);
            sourceCopySymbol = sourceCopyCursor.setToNext() ? &sourceCopyCursor.elementSAt() : nullptr;
            ++basicOperationCounter;
         };
      };
   }
   else {
      Cursor thisCopyCursor(thisCursor);
      bool isSourceHighLevel = sourceCursor.elementAt().getType() == Symbol::THighLevel;
      const Coefficient& sourceCoeff = (const Coefficient&) sourceCursor.globalElementAt();
      const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
      do {
         if (areAllHighLevel && !isSourceHighLevel
               && thisCopyCursor.elementAt().getType() == Symbol::THighLevel)
            areAllHighLevel = false;
         const Coefficient& thisCopyCoeff = (const Coefficient&) thisCopyCursor.globalElementAt();
         const BuiltReal& thisCopyCoeffValue = thisCopyCoeff.getValue();
         addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions, sourceCoeff, sourceCoeffValue,
               thisCopyCoeff, thisCopyCoeffValue, highLevelError, nearestParams, maxParams, manager,
               hasExternalCoefficient);
         ++basicOperationCounter;
      } while (thisCopyCursor.setToNext());

      Cursor sourceCopyCursor(sourceCursor);
      bool isThisHighLevel = thisCursor.elementAt().getType() == Symbol::THighLevel;
      const Coefficient& thisCoeff = (const Coefficient&) thisCursor.globalElementAt();
      const BuiltReal& thisCoeffValue = thisCoeff.getValue();
      do {
         if (areAllHighLevel && !isThisHighLevel
               && sourceCopyCursor.elementAt().getType() == Symbol::THighLevel)
            areAllHighLevel = false;
         const Coefficient& sourceCopyCoeff = (const Coefficient&) sourceCopyCursor.globalElementAt();
         const BuiltReal& sourceCopyCoeffValue = sourceCopyCoeff.getValue();
         addAssignAbsProduct(newCrossCoeffValue, crossCoeffAdditions, thisCoeff, thisCoeffValue,
               sourceCopyCoeff, sourceCopyCoeffValue, highLevelError, nearestParams, maxParams,
               manager, hasExternalCoefficient);
         ++basicOperationCounter;
      } while (sourceCopyCursor.setToNext());
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssignBothCoeffsWithCentrals(
      Cursor& thisCursor, const Cursor& sourceCursor, Symbol* thisSymbol, Symbol* sourceSymbol,
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, RealReadParameters& maxParams, bool hasExternalCoefficient) {
   Coefficient* thisCoeff = &(Coefficient&) thisCursor.globalElementSAt();
   BuiltReal& thisCoeffValue = thisCoeff->getSValue();
   const Coefficient& sourceCoeff = (const Coefficient&) sourceCursor.globalElementAt();
   const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
   ++basicOperationCounter;
   if (thisSymbol == sourceSymbol) {
      bool isXValue = (policyCall == PCSourceXValue) && thisSymbol->isDoubleReferenced();
      multAssignDoubleToCoefficient(thisCoeff, thisCoeffValue, source.dCentral,
            source.apcCentralAdditions, sourceCoeff, sourceCoeffValue, dCentral,
            apcCentralAdditions, highLevelError, false /* isSub */, thisCursor,
            nearestParams, maxParams, manager, hasExternalCoefficient);
      if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
            && (TypeBaseFloatAffine::doesAbsorbHighLevel()
               || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
                  && isNegligeable(*thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
         if (reusableCoeffValue && reusableType == thisSymbol->getType()) {
            addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *thisCoeff, thisCoeffValue,
                  highLevelError, nearestParams, manager, hasExternalCoefficient);
            setToZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient);
         }
         else if (!isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
            reusableCoeff = thisCoeff;
            reusableCoeffValue = &thisCoeffValue;
            reusableType = thisSymbol->getType();
         };
      };
   }
   else {
      bool isXValue = thisSymbol->isSingleReferenced();
      multAssignDoubleAbsToCoefficient(thisCoeff, thisCoeffValue, source.dCentral,
            source.apcCentralAdditions, sourceCoeff, sourceCoeffValue, dCentral,
            apcCentralAdditions, highLevelError, thisCursor, nearestParams, maxParams, manager,
            hasExternalCoefficient);
      if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
            && (TypeBaseFloatAffine::doesAbsorbHighLevel()
               || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
                  && isNegligeable(*thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
         if (reusableCoeffValue && reusableType == thisSymbol->getType()) {
            addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *thisCoeff, thisCoeffValue,
                  highLevelError, nearestParams, manager, hasExternalCoefficient);
            setToZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient);
         }
         else if (!thisCoeffValue.isZero()) {
            reusableCoeff = thisCoeff;
            reusableCoeffValue = &thisCoeffValue;
            reusableType = thisSymbol->getType();
         };
      };
      if (!reusableCoeffValue || reusableType != thisSymbol->getType()) {
         Symbol* symbol = manager.createMarkedNoiseSymbol(thisSymbol->getOrder());
         replaceElementAtWith(thisCursor, *symbol);
         reusableCoeff = thisCoeff;
         reusableCoeffValue = &thisCoeffValue;
         reusableType = symbol->getType();
         if (thisSymbol->getType() == Symbol::THighLevel && !thisSymbol->isReferenced())
            manager.freeHighLevelSymbol((HighLevelSymbol*) thisSymbol);
      }
   };
   if (isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
      if (reusableCoeffValue == &thisCoeffValue) {
         reusableCoeff = nullptr;
         reusableCoeffValue = nullptr;
         reusableType = Symbol::TUndefined;
      };
      Cursor thisRemoveCursor(thisCursor);
      HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
            && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
      thisCursor.setToPrevious();
      removeAt(thisRemoveCursor);
      if (symbolToFree)
         manager.freeHighLevelSymbol(symbolToFree);
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssignThisCoeffWithSourceCentral(
      Cursor& thisCursor, Symbol* thisSymbol, const thisType& source, SymbolsManager& manager,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, RealReadParameters& maxParams, bool hasExternalCoefficient) {
   bool isXValue = thisSymbol->isSingleReferenced();
   Coefficient* thisCoeff = &(Coefficient&) thisCursor.globalElementSAt();
   BuiltReal& thisCoeffValue = thisCoeff->getSValue();
   multAssignOptionCoefficient(thisCoeff, thisCoeffValue, source.dCentral,
         source.apcCentralAdditions, highLevelError, thisCursor, nearestParams, maxParams,
         manager, hasExternalCoefficient);
   ++basicOperationCounter;
   if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
         && (TypeBaseFloatAffine::doesAbsorbHighLevel()
            || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
               && isNegligeable(*thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
      if (reusableCoeffValue && thisSymbol->getType() == reusableType) {
         ++basicOperationCounter;
         addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *thisCoeff, thisCoeffValue,
               highLevelError, nearestParams, manager, hasExternalCoefficient);
         setToZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient);
      }
      else if (!isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
         reusableCoeff = thisCoeff;
         reusableCoeffValue = &thisCoeffValue;
         reusableType = thisSymbol->getType();
      };
   };
   if (isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
      Cursor thisRemoveCursor(thisCursor);
      HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
            && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
      thisCursor.setToPrevious();
      removeAt(thisRemoveCursor);
      if (symbolToFree)
         manager.freeHighLevelSymbol(symbolToFree);
   }
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssignSourceCoeffWithThisCentral(
      Cursor* thisCursor, const Cursor& sourceCursor, Symbol* sourceSymbol, PolicyCall policyCall,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, RealReadParameters& maxParams, SymbolsManager& manager,
      bool hasExternalCoefficient) {
   PNT::AutoPointer<Coefficient> newCoeff((const Coefficient&) sourceCursor.globalElementAt());
   sourceSymbol->unlock(*newCoeff);
   BuiltReal& newCoeffValue = newCoeff->getSValue();
   multAssignOptionCoefficient(newCoeff, newCoeffValue, dCentral, apcCentralAdditions,
         highLevelError, nearestParams, maxParams, manager, hasExternalCoefficient);
   ++basicOperationCounter;
   if (!isZero(*newCoeff, newCoeffValue, hasExternalCoefficient)) {
      ++basicOperationCounter;
      bool isXValue = (policyCall == PCSourceXValue) && sourceSymbol->isSingleReferenced();
      if (isXValue || (sourceSymbol->getType() == Symbol::THighLevel
            && (TypeBaseFloatAffine::doesAbsorbHighLevel()
               || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
                  && isNegligeable(*newCoeff, newCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
         if (reusableCoeffValue && sourceSymbol->getType() == reusableType)
            addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *newCoeff, newCoeffValue,
                  highLevelError, nearestParams, manager, hasExternalCoefficient);
         else {
            sourceSymbol->lock(*newCoeff);
            Coefficient* coeff;
            if (thisCursor)
               coeff = (Coefficient*) absorbGlobalElementBefore(newCoeff.extractElement(), *thisCursor);
            else
               coeff = (Coefficient*) absorbGlobalElement(newCoeff.extractElement());
            if (!reusableCoeffValue) {
               reusableCoeff = coeff;
               reusableCoeffValue = &coeff->getSValue();
               reusableType = sourceSymbol->getType();
            }
         }
      }
      else {
         sourceSymbol->lock(*newCoeff);
         if (thisCursor)
            absorbGlobalElementBefore(newCoeff.extractElement(), *thisCursor);
         else
            absorbGlobalElement(newCoeff.extractElement());
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssign(
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager,
      BuiltReal& newCrossCoeffValue, BuiltReal& newSquareCoeffValue, BuiltReal& highLevelError,
      PNT::AutoPointer<Coefficient>& crossCoeffAdditions,
      PNT::AutoPointer<Coefficient>& squareCoeffAdditions,
      bool hasExternalCoefficient) {
   if (this == &source) {
      thisType sourceCopy(source);
      multAssign(sourceCopy, PCSourceXValue, manager, newCrossCoeffValue, newSquareCoeffValue,
            highLevelError, crossCoeffAdditions, squareCoeffAdditions, hasExternalCoefficient);
      return;
   };

   BuiltReal referenceForAbsorption;
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   if (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()) {
      computeReferenceForAbsorption(referenceForAbsorption);
      BuiltReal sourceCentral;
      computeReference(sourceCentral, source.dCentral, source.apcCentralAdditions);
      referenceForAbsorption.multAssign(sourceCentral, maxParams);
      maxParams.clear();
      BuiltReal sourceReference;
      BuiltReal thisCentral;
      computeReference(thisCentral, dCentral, apcCentralAdditions);
      source.computeReferenceForAbsorption(sourceReference);
      sourceReference.multAssign(thisCentral, maxParams);
      maxParams.clear();
      referenceForAbsorption.plusAssign(sourceReference, maxParams);
      maxParams.clear();
   };

   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   bool areAllHighLevel = TypeBaseFloatAffine::doesAbsorbHighLevel();
   BuiltReal newCentral;
   PNT::AutoPointer<Coefficient> newCentralAdditions;
   {  Cursor thisCursor(*this), sourceCursor(source);
      Symbol* thisSymbol = thisCursor.setToFirst() ? &thisCursor.elementSAt() : nullptr;
      Symbol* sourceSymbol = sourceCursor.setToFirst() ? &sourceCursor.elementSAt() : nullptr;
      ++basicOperationCounter;

      ComparisonResult compare = CREqual;
      if (thisSymbol != nullptr) {
         if (sourceSymbol != nullptr)
            compare = thisSymbol->compare(*sourceSymbol);
         else
            compare = CRLess;
      }
      else if (sourceSymbol != nullptr)
         compare = CRGreater;

      while (thisSymbol && sourceSymbol) {
         if (compare == CRGreater) {
            multAssignAddCrossFromSourceCoeff(thisCursor, sourceCursor, newCrossCoeffValue,
                  crossCoeffAdditions, areAllHighLevel, highLevelError, nearestParams, maxParams,
                  manager, hasExternalCoefficient);
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            compare = sourceSymbol ? thisSymbol->compare(*sourceSymbol) : CRLess;
            ++basicOperationCounter;
         }
         else if (compare == CRLess) {
            multAssignAddCrossFromThisCoeff(thisCursor, sourceCursor, newCrossCoeffValue,
                  crossCoeffAdditions, areAllHighLevel, highLevelError, nearestParams, maxParams,
                  manager, hasExternalCoefficient);
            thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
            compare = thisSymbol ? thisSymbol->compare(*sourceSymbol) : CRGreater;
            ++basicOperationCounter;
         }
         else {
            AssumeCondition(compare == CREqual)
            multAssignAddCentralSquareAndCrossFromBothCoeffs(thisCursor, sourceCursor,
                  thisSymbol == sourceSymbol, newCentral, newCentralAdditions,
                  newSquareCoeffValue, squareCoeffAdditions,
                  newCrossCoeffValue, crossCoeffAdditions, areAllHighLevel, highLevelError,
                  nearestParams, maxParams, manager, hasExternalCoefficient);
            ++basicOperationCounter;
            if (thisCursor.setToNext()) {
               thisSymbol = &thisCursor.elementSAt();
               if (sourceCursor.setToNext()) {
                  sourceSymbol = &sourceCursor.elementSAt();
                  compare = thisSymbol->compare(*sourceSymbol);
               }
               else {
                  sourceSymbol = nullptr;
                  compare = CRLess;
               };
            }
            else if (sourceCursor.setToNext()) {
               thisSymbol = nullptr;
               sourceSymbol = &sourceCursor.elementSAt();
               compare = CRGreater;
            }
            else {
               thisSymbol = sourceSymbol = nullptr;
               compare = CREqual;
            };
         };
      };
   };

   {  Coefficient* reusableCoeff = nullptr;
      BuiltReal* reusableCoeffValue = nullptr;
      Symbol::Type reusableType = Symbol::TUndefined;

      Cursor thisCursor(*this), sourceCursor(source);
      Symbol* thisSymbol = thisCursor.setToFirst() ? &thisCursor.elementSAt() : nullptr;
      Symbol* sourceSymbol = sourceCursor.setToFirst() ? &sourceCursor.elementSAt() : nullptr;

      while (thisSymbol && sourceSymbol) {
         ComparisonResult compare = thisSymbol->compare(*sourceSymbol);
         ++basicOperationCounter;
         if (compare == CREqual) {
            multAssignBothCoeffsWithCentrals(thisCursor, sourceCursor, thisSymbol, sourceSymbol,
                  source, policyCall, manager, referenceForAbsorption, reusableCoeff,
                  reusableCoeffValue, reusableType, highLevelError, nearestParams, maxParams,
                  hasExternalCoefficient);
            thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         }
         else if (compare == CRLess) {
            multAssignThisCoeffWithSourceCentral(thisCursor, thisSymbol, source, manager,
                  referenceForAbsorption, reusableCoeff, reusableCoeffValue, reusableType,
                  highLevelError, nearestParams, maxParams, hasExternalCoefficient);
            thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
         }
         else if (compare == CRGreater) {
            multAssignSourceCoeffWithThisCentral(&thisCursor, sourceCursor, sourceSymbol,
                  policyCall, referenceForAbsorption, reusableCoeff, reusableCoeffValue,
                  reusableType, highLevelError, nearestParams, maxParams, manager, hasExternalCoefficient);
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         }
         else
            {  AssumeUncalled }
      };

      while (thisSymbol) {
         multAssignThisCoeffWithSourceCentral(thisCursor, thisSymbol, source, manager,
               referenceForAbsorption, reusableCoeff, reusableCoeffValue, reusableType,
               highLevelError, nearestParams, maxParams, hasExternalCoefficient);
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
      };
      while (sourceSymbol) {
         multAssignSourceCoeffWithThisCentral(nullptr, sourceCursor, sourceSymbol,
               policyCall, referenceForAbsorption, reusableCoeff, reusableCoeffValue,
               reusableType, highLevelError, nearestParams, maxParams, manager, hasExternalCoefficient);
         sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
      };
   };

   multAssignOptionCentral(dCentral, apcCentralAdditions, source.dCentral, source.apcCentralAdditions,
         highLevelError, nearestParams, TypeBaseFloatAffine::maxParams(), manager, hasExternalCoefficient);
   addAssignOptionCoefficient(dCentral, apcCentralAdditions, newCentral, newCentralAdditions,
         highLevelError, nearestParams, manager, hasExternalCoefficient);
   if (areAllHighLevel) {
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      if (!hasExternalCoefficient || !crossCoeffAdditions.isValid()) {
         highLevelError.plusAssign(newCrossCoeffValue, maxParams);
         maxParams.clear();
         newCrossCoeffValue.setZero();
      }
      else {
         BuiltReal min, max;
         crossCoeffAdditions->retrieveBound(min, max);
         AssumeCondition(min.isPositive())
         highLevelError.plusAssign(max, maxParams);
         maxParams.clear();
         crossCoeffAdditions.release();
      };
      if (!hasExternalCoefficient || !squareCoeffAdditions.isValid()) {
         highLevelError.plusAssign(newSquareCoeffValue, maxParams);
         maxParams.clear();
         newSquareCoeffValue.setZero();
      }
      else {
         BuiltReal min, max;
         squareCoeffAdditions->retrieveBound(min, max);
         AssumeCondition(min.isPositive())
         highLevelError.plusAssign(max, maxParams);
         maxParams.clear();
         squareCoeffAdditions.release();
      };
   }
   ++basicOperationCounter;
   if (policyCall == PCSourceXValue)
      const_cast<thisType&>(source).clear(&manager);
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::addNoise(
      const BuiltReal& newCoeffValue, PNT::AutoPointer<Coefficient>& coeffAdditions,
      BuiltReal& highLevelError, SymbolsManager& manager, int* marked, bool hasExternalCoefficient) {
   if ((!hasExternalCoefficient || !coeffAdditions.isValid()) ? !newCoeffValue.isZero() : coeffAdditions->isZero()) {
      bool isAdded = false;
      if (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()) {
         BuiltReal reference;
         computeReferenceForAbsorption(reference);
         isAdded = (!hasExternalCoefficient || !coeffAdditions.isValid())
               ? isNegligeable(newCoeffValue, reference)
               : isNegligeable(*coeffAdditions, coeffAdditions->getSValue(), reference, true);
         if (isAdded) {
            HighLevelSymbol symbol;
            symbol.setOrder(manager.getHighLevelSymbolOrder());
            Cursor cursor(*this);
            isAdded = false;
            if (cursor.setToLast()) {
               while (cursor.elementAt().getType() == Symbol::THighLevel) {
                  const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
                  const BuiltReal& coeffValue = coeff.getValue();
                  isAdded = isNegligeable(coeff, coeffValue, reference, hasExternalCoefficient);
                  if (isAdded || !cursor.setToPrevious())
                     break;
               };
            };
            if (isAdded) {
               Symbol* oldSymbol = &cursor.elementSAt();
               PNT::AutoPointer<GlobalElement> acoeff((const Coefficient&) cursor.globalElementAt());
               oldSymbol->unlock(*acoeff);
               AssumeCondition(dynamic_cast<const HighLevelSymbol*>(oldSymbol))
               Symbol* newSymbol = manager.createHighLevelSymbol();
               {  Cursor removeCursor(cursor);
                  if (cursor.setToNext())
                     while (cursor.elementAt() < *newSymbol && cursor.setToNext());
                  removeAt(removeCursor);
               };
               newSymbol->lock(*acoeff);
               Coefficient* coeff = (Coefficient*) absorbGlobalElementBefore(acoeff.extractElement(), cursor);
               cursor.setToPrevious();
               BuiltReal& coeffValue = coeff->getSValue();
               addMaxAbsAssignToCoefficient(coeff, coeffValue, newCoeffValue, coeffAdditions,
                     cursor, TypeBaseFloatAffine::minParams(), TypeBaseFloatAffine::maxParams(),
                     manager, hasExternalCoefficient);
               // cursor.setToNext(); // not useful
               if (!oldSymbol->isReferenced())
                  manager.freeHighLevelSymbol((HighLevelSymbol*) oldSymbol);
            }
            else {
               Symbol* newSymbol = manager.createHighLevelSymbol();
               Cursor cursor(*this);
               if (cursor.setToLast())
                  while (cursor.elementAt() > *newSymbol && cursor.setToPrevious());
               if (!coeffAdditions.isValid()) {
                  Coefficient* coeff = (Coefficient*) addElementAfter(*newSymbol, cursor);
                  coeff->setValue(newCoeffValue);
               }
               else
                  absorbGlobalElementAfter(coeffAdditions.extractElement(), cursor);
               isAdded = true;
            }
         };
      }
      if (!isAdded) {
         Symbol* foundSymbol = nullptr;
         Coefficient* foundCoeff = nullptr;
         BuiltReal* foundCoeffValue = nullptr;
         if (marked) {
            Cursor foundCursor(*this);
            if (foundCursor.setToLast()) {
               MarkedNoiseSymbol search(*marked);
               ComparisonResult compare;
               do {
                  compare = foundCursor.elementAt().compare(search);
               } while (compare == CRGreater && foundCursor.setToPrevious());
               if (compare == CREqual) {
                  foundSymbol = manager.createMarkedNoiseSymbol(foundCursor.elementAt().getOrder());
                  replaceElementAtWith(foundCursor, *foundSymbol);
                  // foundSymbol = &foundCursor.elementSAt();
                  foundCoeff = &(Coefficient&) foundCursor.globalElementSAt();
                  foundCoeffValue = &foundCoeff->getSValue();
               };
            };
         };
         ++basicOperationCounter;
         if (!foundSymbol) {
            Symbol* newSymbol = !marked ? manager.createNoiseSymbol() : manager.createMarkedNoiseSymbol(*marked);
            Cursor cursor(*this);
            if (cursor.setToLast())
               while (cursor.elementAt() > *newSymbol && cursor.setToPrevious());
            if (!coeffAdditions.isValid()) {
               Coefficient* coeff = (Coefficient*) addElementAfter(*newSymbol, cursor);
               coeff->setValue(newCoeffValue);
            }
            else
               absorbGlobalElementAfter(coeffAdditions.extractElement(), cursor);
         }
         else {
            auto& nearestParams = TypeBaseFloatAffine::nearestParams();
            if (!coeffAdditions.isValid()) {
               Coefficient coeff;
               coeff.setValue(newCoeffValue);
               addAbsAssignToCoefficient(foundCoeff, foundCoeffValue, coeff, newCoeffValue,
                     highLevelError, nearestParams, manager, hasExternalCoefficient);
            }
            else
               addAbsAssignToCoefficient(foundCoeff, foundCoeffValue, *coeffAdditions,
                     coeffAdditions->getValue(), highLevelError, nearestParams, manager,
                     hasExternalCoefficient);
         };
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::multAssign(
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager, bool isHighLevel,
      int* marked, bool hasExternalCoefficient) {
   if (this == &source) {
      thisType sourceCopy(source);
      multAssign(sourceCopy, PCSourceXValue, manager, isHighLevel, marked, hasExternalCoefficient);
      return;
   };

   BuiltReal thisMin, thisMax;
   if (!TypeBaseFloatAffine::isPureZonotope())
      retrieveBound(thisMin, thisMax, hasExternalCoefficient);
   BuiltReal sourceMin, sourceMax;
   if (!TypeBaseFloatAffine::isPureZonotope())
      source.retrieveBound(sourceMin, sourceMax, hasExternalCoefficient);

   BuiltReal newCrossCoeffValue, newSquareCoeffValue, highLevelError;
   PNT::AutoPointer<Coefficient> crossCoeffAdditions, squareCoeffAdditions;
   multAssign(source, policyCall, manager, newCrossCoeffValue, newSquareCoeffValue, highLevelError,
         crossCoeffAdditions, squareCoeffAdditions, hasExternalCoefficient);
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   if (isHighLevel) {
      if (!hasExternalCoefficient || !crossCoeffAdditions.isValid()) {
         highLevelError.plusAssign(newCrossCoeffValue, maxParams);
         maxParams.clear();
         newCrossCoeffValue.setZero();
      }
      else {
         BuiltReal min, max;
         crossCoeffAdditions->retrieveBound(min, max);
         AssumeCondition(min.isPositive())
         highLevelError.plusAssign(max, maxParams);
         maxParams.clear();
         crossCoeffAdditions.release();
      };
      if (!hasExternalCoefficient || !squareCoeffAdditions.isValid()) {
         highLevelError.plusAssign(newSquareCoeffValue, maxParams);
         maxParams.clear();
         newSquareCoeffValue.setZero();
      }
      else {
         BuiltReal min, max;
         squareCoeffAdditions->retrieveBound(min, max);
         AssumeCondition(min.isPositive())
         highLevelError.plusAssign(max, maxParams);
         maxParams.clear();
         squareCoeffAdditions.release();
      };
   }
   if (TypeBaseFloatAffine::isPureZonotope()) {
      if (!isHighLevel)
         addAssignOptionCoefficient(newCrossCoeffValue, crossCoeffAdditions, newSquareCoeffValue,
               squareCoeffAdditions, maxParams, manager, hasExternalCoefficient);
      addNoise(newCrossCoeffValue, crossCoeffAdditions, highLevelError, manager, marked, hasExternalCoefficient);
      addHighLevel(highLevelError, manager, hasExternalCoefficient);
   }
   else {
      BuiltReal decision;
      setValueFromMaxCoeff(decision, newCrossCoeffValue, crossCoeffAdditions, hasExternalCoefficient);
      decision.divAssign(2U, maxParams);
      maxParams.clear();
      bool shouldChooseInterval = isValueGreaterOrEqualMaxCoeff(decision, newSquareCoeffValue, squareCoeffAdditions, hasExternalCoefficient);
      if (shouldChooseInterval) {
         subValueFromMaxCoeff(decision, newSquareCoeffValue, squareCoeffAdditions, maxParams,
               hasExternalCoefficient);
         decision.multAssign(16U, maxParams);
         maxParams.clear();
         Cursor cursor(*this);
         for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
            AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
            const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
            const BuiltReal& coeffValue = coeff.getValue();
            subValueFromMaxAbsCoeff(decision, coeff, coeffValue, maxParams, hasExternalCoefficient);
         };
         shouldChooseInterval = decision.isPositive();
      };
      if (!shouldChooseInterval) {
         if (!isHighLevel)
            addAssignOptionCoefficient(newCrossCoeffValue, crossCoeffAdditions, newSquareCoeffValue,
                  squareCoeffAdditions, maxParams, manager, hasExternalCoefficient);
         addNoise(newCrossCoeffValue, crossCoeffAdditions, highLevelError, manager, marked, hasExternalCoefficient);
         addHighLevel(highLevelError, manager, hasExternalCoefficient);
      }
      else {
         auto& minParams = TypeBaseFloatAffine::minParams();
         if (thisMin.isPositive() || thisMin.isZero()) {
            if (sourceMin.isPositive() || sourceMin.isZero()) {
               thisMin.multAssign(sourceMin, minParams);
               minParams.clear();
               thisMax.multAssign(sourceMax, maxParams);
               maxParams.clear();
            }
            else if (sourceMax.isNegative() || sourceMax.isZero()) {
               thisMin.multAssign(sourceMax, maxParams);
               maxParams.clear();
               thisMax.multAssign(sourceMin, minParams);
               minParams.clear();
               thisMin.swap(thisMax);
            }
            else { // thisMin.isPositive() && sourceMin.isNegative() && sourceMax.isPositive()
               thisMin = thisMax;
               thisMin.multAssign(sourceMin, minParams);
               minParams.clear();
               thisMax.multAssign(sourceMax, maxParams);
               maxParams.clear();
            };
         }
         else if (thisMax.isNegative() || thisMax.isZero()) {
            if (sourceMin.isPositive() || sourceMin.isZero()) {
               thisMin.multAssign(sourceMax, minParams);
               minParams.clear();
               thisMax.multAssign(sourceMin, maxParams);
               maxParams.clear();
            }
            else if (sourceMax.isNegative() || sourceMax.isZero()) {
               thisMin.multAssign(sourceMin, maxParams);
               maxParams.clear();
               thisMax.multAssign(sourceMax, minParams);
               minParams.clear();
               thisMin.swap(thisMax);
            }
            else { // thisMin.isNegative() && sourceMin.isNegative() && sourceMax.isPositive()
               thisMax = thisMin;
               thisMin.multAssign(sourceMin, maxParams);
               maxParams.clear();
               thisMax.multAssign(sourceMax, minParams);
               minParams.clear();
               thisMin.swap(thisMax);
            };
         }
         else { // thisMin.isNegative() && thisMax.isPositive()
            if (sourceMin.isPositive() || sourceMin.isZero()) {
               thisMin.multAssign(sourceMax, minParams);
               minParams.clear();
               thisMax.multAssign(sourceMax, maxParams);
               maxParams.clear();
            }
            else if (sourceMax.isNegative() || sourceMax.isZero()) {
               thisMin.multAssign(sourceMin, maxParams);
               maxParams.clear();
               thisMax.multAssign(sourceMin, minParams);
               minParams.clear();
               thisMin.swap(thisMax);
            }
            else { // thisMin.isNegative() && thisMax.isPositive() && sourceMin.isNegative() && sourceMax.isPositive()
               BuiltReal min(thisMin), max(thisMin);
               min.multAssign(sourceMax, minParams);
               minParams.clear();
               BuiltReal min2 = thisMax;
               min2.multAssign(sourceMin, minParams);
               minParams.clear();
               if (min2 < min)
                  min = min2;
               max.multAssign(sourceMin, maxParams);
               maxParams.clear();
               BuiltReal max2 = thisMax;
               max2.multAssign(sourceMax, maxParams);
               maxParams.clear();
               if (max2 > max)
                  max = max2;
               thisMin = min;
               thisMax = max;
            };
         }
         clear(&manager);
         setInterval(thisMin, thisMax, manager);
      };
   }
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::inverseAssignCoeff(
      Cursor& thisCursor, const Symbol* thisSymbol, SymbolsManager& manager,
      const BuiltReal& centralSquare, const BuiltReal& highLevelCentralSquare,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, RealReadParameters& minParams,
      RealReadParameters& maxParams, bool hasExternalCoefficient) {
   bool isXValue = thisSymbol->isSingleReferenced();
   Coefficient& coeff = (Coefficient&) thisCursor.globalElementSAt();
   BuiltReal& coeffValue = coeff.getSValue();
   // coeffValue = -coeffValue/(dCentral*dCentral);
   oppositeAssignCoefficient(coeff, coeffValue, hasExternalCoefficient);
   // highLevelError += coeffValue/(centralSquare - highLevelCentralSquare) - coeffValue/centralSquare;
   // highLevelError += coeffValue * (highLevelCentralSquare/(centralSquare * (centralSquare - highLevelCentralSquare)))
   BuiltReal temp;
   setAbsAssignToValue(temp, coeff, coeffValue, hasExternalCoefficient);
   temp.multAssign(highLevelCentralSquare, maxParams);
   maxParams.clear();
   BuiltReal minCentralSquare(centralSquare);
   minCentralSquare.minusAssign(highLevelCentralSquare, minParams);
   minParams.clear();
   minCentralSquare.multAssign(centralSquare, minParams);
   minParams.clear();
   temp.divAssign(minCentralSquare, maxParams);
   maxParams.clear();
   highLevelError.plusAssign(temp, maxParams);
   maxParams.clear();
   divAssignToCoefficient(coeff, coeffValue, centralSquare, highLevelError, nearestParams, manager,
         hasExternalCoefficient);
   ++basicOperationCounter;
   if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
         && (TypeBaseFloatAffine::doesAbsorbHighLevel()
            || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
               && isNegligeable(coeff, coeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
      if (reusableCoeffValue && thisSymbol->getType() == reusableType) {
         addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, coeff, coeffValue,
               highLevelError, nearestParams, manager, hasExternalCoefficient);
         setToZero(coeff, coeffValue, hasExternalCoefficient);
      }
      else if (!isZero(coeff, coeffValue, hasExternalCoefficient)) {
         reusableCoeff = &coeff;
         reusableCoeffValue = &coeffValue;
         reusableType = thisSymbol->getType();
      };
   };
   if (isZero(coeff, coeffValue, hasExternalCoefficient)) {
      Cursor thisRemoveCursor(thisCursor);
      HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
            && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
      thisCursor.setToPrevious();
      removeAt(thisRemoveCursor);
      if (symbolToFree)
         manager.freeHighLevelSymbol(symbolToFree);
   }
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::inverseAssign(
      SymbolsManager& manager, BuiltReal& newCoeff, BuiltReal& highLevelError, bool hasExternalCoefficient) {
   BuiltReal referenceForAbsorption;
   if (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()) {
      computeReferenceForAbsorption(referenceForAbsorption);
      BuiltReal thisCentral;
      computeReference(thisCentral, dCentral, apcCentralAdditions);
      referenceForAbsorption.divAssign(thisCentral, TypeBaseFloatAffine::maxParams());
      TypeBaseFloatAffine::maxParams().clear();
   };
   ++basicOperationCounter;
   BuiltReal centralSquare = dCentral;
   if (hasExternalCoefficient && apcCentralAdditions.isValid()) {
      BuiltReal min, max;
      apcCentralAdditions->retrieveBound(min, max);
      if (min.isPositive())
         centralSquare = min;
      else if (max.isNegative())
         centralSquare = max;
      else {
         min.opposite();
         if (min <= max)
            centralSquare = min;
         else
            centralSquare = max;
      };
   };
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   centralSquare.multAssign(centralSquare, nearestParams);
   BuiltReal highLevelCentralSquare;
   adjustComputation(centralSquare, highLevelCentralSquare);
   if (centralSquare.isZero())
      return false;
   // centralSquare = dCentral^2

   BuiltReal max;
   BuiltReal highLevelMax;
   Cursor cursor(*this);
   bool areAllHighLevel = TypeBaseFloatAffine::doesAbsorbHighLevel();
   for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
      AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
      const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
      const BuiltReal& coeffValue = coeff.getValue();
      if (areAllHighLevel && cursor.elementAt().getType() != Symbol::THighLevel)
         areAllHighLevel = false;
      addAbsAssignToValue(max, coeff, coeffValue, highLevelMax, nearestParams, hasExternalCoefficient);
      ++basicOperationCounter;
   };
   
   if (mayValueGreaterOrEqualMaxAbsCoeff(max, dCentral, apcCentralAdditions, hasExternalCoefficient))
      return false;

   // max = sum |coeff_i|
   
   BuiltReal centralDiff, maxCentral, highLevelCentralDiff;
   if (!apcCentralAdditions.isValid())
      centralDiff = maxCentral = dCentral;
   else {
      apcCentralAdditions->retrieveBound(centralDiff, maxCentral);
      if (!centralDiff.isPositive()) {
         if (maxCentral.isNegative())
            centralDiff.swap(maxCentral);
         else { // centralDiff.isNegative() && maxCentral.isPositive()
            maxCentral.opposite();
            if (centralDiff < maxCentral)
               centralDiff.swap(maxCentral);
            maxCentral.opposite();
         };
      };
   };

   BuiltReal minCentral = centralDiff;
   if (centralDiff.isPositive()) {
      centralDiff.minusAssign(max, nearestParams);
      adjustComputation(centralDiff, highLevelCentralDiff);
      if (centralDiff.isZero() || centralDiff.isNegative())
         return false;
   }
   else {
      centralDiff.plusAssign(max, nearestParams);
      adjustComputation(centralDiff, highLevelCentralDiff);
      nearestParams.clear();
      if (centralDiff.isZero() || centralDiff.isPositive())
         return false;
   };
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   auto& minParams = TypeBaseFloatAffine::minParams();
   highLevelCentralDiff.plusAssign(highLevelMax, maxParams);
   maxParams.clear();
   
   highLevelCentralDiff.multAssign(maxCentral, maxParams);
   maxParams.clear();
   centralDiff.multAssign(minCentral, nearestParams);
   adjustComputation(centralDiff, highLevelCentralDiff);
   // centralDiff == dCentral * (dCentral +/- max) >= 0

   if (centralDiff.isZero() || centralDiff.isNegative())
      return false;

   BuiltReal maxSquareDivideDiff(max), highLevelMaxSquareDivideDiff(highLevelMax);
   highLevelMaxSquareDivideDiff.multAssign(max, maxParams);
   maxParams.clear();
   highLevelMaxSquareDivideDiff.multAssign(2, maxParams);
   maxParams.clear();
   BuiltReal temp(highLevelMax);
   temp.multAssign(temp, maxParams);
   maxParams.clear();
   highLevelMaxSquareDivideDiff.plusAssign(temp, maxParams);
   maxParams.clear();
   
   maxSquareDivideDiff.multAssign(max, nearestParams);
   adjustComputation(maxSquareDivideDiff, highLevelMaxSquareDivideDiff);
   // highLevelMaxSquareDivideDiff = (maxSquareDivideDiff + highLevelMaxSquareDiff) / (centralDiff - highLevelCentralDiff) - maxSquareDivideDiff / centralDiff
   // highLevelMaxSquareDivideDiff = (maxSquareDivideDiff * highLevelCentralDiff + highLevelMaxSquareDiff * centralDiff) / (centralDiff * (centralDiff - highLevelCentralDiff))
   if (centralDiff.isPositive()) {
      BuiltReal minCentral(centralDiff);
      minCentral.minusAssign(highLevelCentralDiff, minParams);
      minParams.clear();
      highLevelMaxSquareDivideDiff.divAssign(minCentral, maxParams);
      maxParams.clear();

      BuiltReal temp(maxSquareDivideDiff);
      temp.divAssign(minCentral, maxParams);
      maxParams.clear();
      temp.divAssign(centralDiff, maxParams);
      maxParams.clear();
      temp.multAssign(highLevelCentralDiff, maxParams);
      maxParams.clear();
      highLevelMaxSquareDivideDiff.plusAssign(temp, maxParams);
      maxParams.clear();
   }
   else {
      BuiltReal minCentral(centralDiff);
      minCentral.plusAssign(highLevelCentralDiff, maxParams);
      maxParams.clear();
      highLevelMaxSquareDivideDiff.divAssign(centralDiff, minParams);
      minParams.clear();

      BuiltReal temp(maxSquareDivideDiff);
      temp.divAssign(minCentral, minParams);
      minParams.clear();
      temp.divAssign(centralDiff, maxParams);
      maxParams.clear();
      temp.multAssign(highLevelCentralDiff, maxParams);
      maxParams.clear();
      highLevelMaxSquareDivideDiff.minusAssign(temp, minParams);
      minParams.clear();
      highLevelMaxSquareDivideDiff.opposite();
   };
   maxSquareDivideDiff.divAssign(centralDiff, nearestParams);
   adjustComputation(maxSquareDivideDiff, highLevelMaxSquareDivideDiff);
   ++basicOperationCounter;

   Coefficient* reusableCoeff = nullptr;
   BuiltReal* reusableCoeffValue = nullptr;
   Symbol::Type reusableType = Symbol::TUndefined;
   Cursor thisCursor(*this);
   const Symbol* thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
   while (thisSymbol) {
      inverseAssignCoeff(thisCursor, thisSymbol, manager, centralSquare, highLevelCentralSquare,
            referenceForAbsorption, reusableCoeff, reusableCoeffValue, reusableType,
            highLevelError, nearestParams, minParams, maxParams, hasExternalCoefficient);
      thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
   };

   newCoeff = maxSquareDivideDiff;
   BuiltReal highLevelNewCoeff(highLevelMaxSquareDivideDiff);
   highLevelNewCoeff.divAssign(2, maxParams);
   maxParams.clear();
   newCoeff.divAssign(2, nearestParams);
   adjustComputation(newCoeff, highLevelNewCoeff);
   highLevelNewCoeff.divAssign(minCentral, maxParams);
   maxParams.clear();
   newCoeff.divAssign(minCentral, nearestParams);
   adjustComputation(newCoeff, highLevelNewCoeff);
   ++basicOperationCounter;

   {  // dCentral = 1/dCentral + maxSquareDivideDiff/(2*dCentral);
      BuiltReal newCentral(maxSquareDivideDiff), highLevelNewCentral(highLevelMaxSquareDivideDiff);
      highLevelNewCentral.divAssign(2, maxParams);
      maxParams.clear();
      newCentral.divAssign(2, nearestParams);
      adjustComputation(newCentral, highLevelNewCentral);
      newCentral.plusAssign(BuiltReal(1U), nearestParams);
      adjustComputation(newCentral, highLevelNewCentral);
      if (minCentral.isPositive()) {
         highLevelNewCentral.divAssign(minCentral, maxParams);
         maxParams.clear();
      }
      else {
         highLevelNewCentral.divAssign(minCentral, minParams);
         minParams.clear();
         highLevelNewCentral.opposite();
      }
      ++basicOperationCounter;
      newCentral.divAssign(minCentral, nearestParams);
      adjustComputation(newCentral, highLevelNewCentral);
      dCentral = newCentral;
      if (hasExternalCoefficient && apcCentralAdditions.isValid())
         apcCentralAdditions.release();
      highLevelError.plusAssign(highLevelNewCentral, maxParams);
      maxParams.clear();
   };

   highLevelError.plusAssign(highLevelNewCoeff, maxParams);
   maxParams.clear();
   if (areAllHighLevel) {
      highLevelError.plusAssign(newCoeff, maxParams);
      maxParams.clear();
      newCoeff.setZero();
   };
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::inverseAssign(
      SymbolsManager& manager, int* marked, bool hasExternalCoefficient) {
   BuiltReal newCoeff, highLevelError;
   if (!inverseAssign(manager, newCoeff, highLevelError, hasExternalCoefficient))
      return false;

   PNT::AutoPointer<Coefficient> coeffAdditions;
   addNoise(newCoeff, coeffAdditions, highLevelError, manager, marked, hasExternalCoefficient);
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::divAssignBothCoeffsWithCentrals(
      Cursor& thisCursor, const Cursor& sourceCursor, Symbol* thisSymbol, Symbol* sourceSymbol,
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, RealReadParameters& maxParams, bool hasExternalCoefficient) {
   BuiltReal localHighLevelError;
   // coeff = (coeff*source.dCentral - dCentral*sourceCoeff)/source.dCentral
   Coefficient* thisCoeff = &(Coefficient&) thisCursor.globalElementSAt();
   BuiltReal& thisCoeffValue = thisCoeff->getSValue();
   const Coefficient& sourceCoeff = (const Coefficient&) sourceCursor.globalElementAt();
   const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
   ++basicOperationCounter;
   bool isXValue = false;
   if (thisSymbol == sourceSymbol) {
      isXValue = (policyCall == PCSourceXValue) && thisSymbol->isDoubleReferenced();
      multAssignDoubleToCoefficient(thisCoeff, thisCoeffValue, source.dCentral,
            source.apcCentralAdditions, sourceCoeff, sourceCoeffValue, dCentral,
            apcCentralAdditions, localHighLevelError, true /* isSub */, thisCursor,
            nearestParams, maxParams, manager, hasExternalCoefficient);
   }
   else {
      isXValue = thisSymbol->isSingleReferenced();
      multAssignDoubleAbsToCoefficient(thisCoeff, thisCoeffValue, source.dCentral,
            source.apcCentralAdditions, sourceCoeff, sourceCoeffValue, dCentral,
            apcCentralAdditions, localHighLevelError, thisCursor, nearestParams, maxParams, manager,
            hasExternalCoefficient);
   };
   divAssignMaxOption(localHighLevelError, source.dCentral, source.apcCentralAdditions,
         maxParams, hasExternalCoefficient);
   divAssignOptionCoefficient(thisCoeff, thisCoeffValue, source.dCentral,
         source.apcCentralAdditions, localHighLevelError, thisCursor,
         nearestParams, manager, hasExternalCoefficient);
   if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
         && (TypeBaseFloatAffine::doesAbsorbHighLevel()
            || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
               && isNegligeable(*thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
      if (reusableCoeffValue && reusableType == thisSymbol->getType()) {
         addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *thisCoeff, thisCoeffValue,
               highLevelError, nearestParams, manager, hasExternalCoefficient);
         setToZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient);
      }
      else if (!isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
         reusableCoeff = thisCoeff;
         reusableCoeffValue = &thisCoeffValue;
         reusableType = thisSymbol->getType();
         if ((thisSymbol != sourceSymbol) && !isXValue) {
            Symbol* symbol = manager.createMarkedNoiseSymbol(thisSymbol->getOrder());
            replaceElementAtWith(thisCursor, *symbol);
         };
      };
   }
   else if (thisSymbol != sourceSymbol) {
      Symbol* symbol = manager.createMarkedNoiseSymbol(thisSymbol->getOrder());
      replaceElementAtWith(thisCursor, *symbol);
      reusableCoeff = thisCoeff;
      reusableCoeffValue = &thisCoeffValue;
      reusableType = symbol->getType();
      if (thisSymbol->getType() == Symbol::THighLevel && !thisSymbol->isReferenced())
         manager.freeHighLevelSymbol((HighLevelSymbol*) thisSymbol);
   }
   if (isZero(*thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
      Cursor thisRemoveCursor(thisCursor);
      HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
            && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
      thisCursor.setToPrevious();
      removeAt(thisRemoveCursor);
      if (symbolToFree)
         manager.freeHighLevelSymbol(symbolToFree);
   };
   highLevelError.plusAssign(localHighLevelError, maxParams);
   maxParams.clear();
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::divAssignThisCoeffWithSourceCentral(
      Cursor& thisCursor, Symbol* thisSymbol, SymbolsManager& manager,
      BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, bool hasExternalCoefficient) {
   // coeff remains unchanged
   bool isXValue = thisSymbol->isSingleReferenced();
   Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
   BuiltReal& thisCoeffValue = thisCoeff.getSValue();
   if (isXValue || (thisSymbol->getType() == Symbol::THighLevel
         && (TypeBaseFloatAffine::doesAbsorbHighLevel()
            || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
               && isNegligeable(thisCoeff, thisCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
      if (reusableCoeffValue && thisSymbol->getType() == reusableType) {
         ++basicOperationCounter;
         addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, thisCoeff, thisCoeffValue,
               highLevelError, nearestParams, manager, hasExternalCoefficient);
         setToZero(thisCoeff, thisCoeffValue, hasExternalCoefficient);
      }
      else if (!isZero(thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
         reusableCoeff = &thisCoeff;
         reusableCoeffValue = &thisCoeffValue;
         reusableType = thisSymbol->getType();
      };
      if (isZero(thisCoeff, thisCoeffValue, hasExternalCoefficient)) {
         Cursor thisRemoveCursor(thisCursor);
         HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
               && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
         thisCursor.setToPrevious();
         removeAt(thisRemoveCursor);
         if (symbolToFree)
            manager.freeHighLevelSymbol(symbolToFree);
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::divAssignSourceCoeffWithThisCentral(
      Cursor* thisCursor, const Cursor& sourceCursor, Symbol* sourceSymbol, const thisType& source,
      PolicyCall policyCall, BuiltReal& referenceForAbsorption, Coefficient*& reusableCoeff,
      BuiltReal*& reusableCoeffValue, Symbol::Type& reusableType, BuiltReal& highLevelError,
      RealReadParameters& nearestParams, RealReadParameters& maxParams, SymbolsManager& manager,
      bool hasExternalCoefficient) { // coeff = -(dCentral*sourceCoeff)/source.dCentral
   BuiltReal localHighLevelError;
   bool isXValue = (policyCall == PCSourceXValue) && sourceSymbol->isSingleReferenced();
   PNT::AutoPointer<Coefficient> newCoeff((const Coefficient&) sourceCursor.globalElementAt());
   sourceSymbol->unlock(*newCoeff);
   BuiltReal& newCoeffValue = newCoeff->getSValue();
   ++basicOperationCounter;
   multAssignOptionCoefficient(newCoeff, newCoeffValue, dCentral, apcCentralAdditions,
         localHighLevelError, nearestParams, maxParams, manager, hasExternalCoefficient);
   oppositeAssignCoefficient(*newCoeff, newCoeffValue, hasExternalCoefficient);
   divAssignMaxOption(localHighLevelError, source.dCentral, source.apcCentralAdditions,
         maxParams, hasExternalCoefficient);
   divAssignOptionCoefficient(newCoeff, newCoeffValue, source.dCentral,
         source.apcCentralAdditions, localHighLevelError, nearestParams, manager,
         hasExternalCoefficient);
   if (!isZero(*newCoeff, newCoeffValue, hasExternalCoefficient)) {
      if (isXValue || (sourceSymbol->getType() == Symbol::THighLevel
            && (TypeBaseFloatAffine::doesAbsorbHighLevel()
               || (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()
                  && isNegligeable(*newCoeff, newCoeffValue, referenceForAbsorption, hasExternalCoefficient))))) {
         if (reusableCoeffValue && sourceSymbol->getType() == reusableType)
            addAbsAssignToCoefficient(reusableCoeff, reusableCoeffValue, *newCoeff, newCoeffValue,
                  highLevelError, nearestParams, manager, hasExternalCoefficient);
         else {
            sourceSymbol->lock(*newCoeff);
            Coefficient* coeff;
            if (thisCursor)
               coeff = (Coefficient*) absorbGlobalElementBefore(newCoeff.extractElement(), *thisCursor);
            else
               coeff = (Coefficient*) absorbGlobalElement(newCoeff.extractElement());
            if (!reusableCoeffValue) {
               reusableCoeff = coeff;
               reusableCoeffValue = &coeff->getSValue();
               reusableType = sourceSymbol->getType();
            }
         }
      }
      else {
         sourceSymbol->lock(*newCoeff);
         if (thisCursor)
            absorbGlobalElementBefore(newCoeff.extractElement(), *thisCursor);
         else
            absorbGlobalElement(newCoeff.extractElement());
      };
   };
   highLevelError.plusAssign(localHighLevelError, maxParams);
   maxParams.clear();
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::divAssign(
      const thisType& source, PolicyCall policyCall, SymbolsManager& manager, int* marked,
      bool hasExternalCoefficient) {
   if (this == &source) {
      thisType sourceCopy(source);
      return divAssign(sourceCopy, PCSourceXValue, manager, marked, hasExternalCoefficient);
   };

   BuiltReal referenceForAbsorption;
   if (TypeBaseFloatAffine::getLimitStartSymbolAbsorption()) {
      computeReferenceForAbsorption(referenceForAbsorption);
      BuiltReal sourceCentral;
      computeReference(sourceCentral, source.dCentral, source.apcCentralAdditions);
      referenceForAbsorption.divAssign(sourceCentral, TypeBaseFloatAffine::maxParams());
      TypeBaseFloatAffine::maxParams().clear();
      BuiltReal sourceReference;
      BuiltReal thisCentral;
      computeReference(thisCentral, dCentral, apcCentralAdditions);
      source.computeReferenceForAbsorption(sourceReference);
      sourceReference.multAssign(thisCentral, TypeBaseFloatAffine::maxParams());
      TypeBaseFloatAffine::maxParams().clear();
      referenceForAbsorption.plusAssign(sourceReference, TypeBaseFloatAffine::maxParams());
      TypeBaseFloatAffine::maxParams().clear();
   };

   BuiltReal thisMin, thisMax;
   if (!TypeBaseFloatAffine::isPureZonotope())
      retrieveBound(thisMin, thisMax, hasExternalCoefficient);
   thisType sourceInverse;
   sourceInverse.setCentral(source.dCentral, source.apcCentralAdditions);
   if (policyCall == PCSourceXValue)
      sourceInverse.inherited::operator=(std::move(const_cast<thisType&>(source)));
   else
      sourceInverse.inherited::assignFromGlobal(source);

   BuiltReal maxSourceInverse(sourceInverse.dCentral);
   if (apcCentralAdditions.isValid()) {
      BuiltReal min;
      apcCentralAdditions->retrieveBound(min, maxSourceInverse);
      if (!min.isPositive()) {
         if (maxSourceInverse.isNegative())
            min.swap(maxSourceInverse);
         else {
            min.opposite();
            if (min > maxSourceInverse)
               maxSourceInverse = min;
         };
      };
   };

   ++basicOperationCounter;
   if (maxSourceInverse.isNegative())
      maxSourceInverse.opposite();
   Cursor sourceCursor(sourceInverse);
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   for (bool doesContinue = sourceCursor.setToFirst(); doesContinue; doesContinue = sourceCursor.setToNext()) {
      AssumeCondition(dynamic_cast<const Coefficient*>(&sourceCursor.globalElementAt()))
      const Coefficient& coeff = (const Coefficient&) sourceCursor.globalElementAt();
      const BuiltReal& coeffValue = coeff.getValue();
      ++basicOperationCounter;
      addAbsAssignToValue(maxSourceInverse, coeff, coeffValue, maxParams, hasExternalCoefficient);
   };

   BuiltReal inverseNewCoeff, inverseHighLevel;
   GuardXValue guard(const_cast<thisType&>(source), policyCall == PCSourceXValue, manager);
   if (!sourceInverse.inverseAssign(manager, inverseNewCoeff, inverseHighLevel, hasExternalCoefficient))
      return false;

   ++basicOperationCounter;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   BuiltReal highLevelError;
   BuiltReal centralAdd(dCentral);
   PNT::AutoPointer<Coefficient> centralAddAdditions(apcCentralAdditions);
   divAssignOptionCentral(centralAdd, centralAddAdditions, source.dCentral,
         source.apcCentralAdditions, highLevelError, nearestParams, manager, hasExternalCoefficient);

   BuiltReal highLevelLinear;
   {  Cursor thisCursor(*this), sourceCursor(source);
      Symbol* thisSymbol = thisCursor.setToFirst() ? &thisCursor.elementSAt() : nullptr;
      Symbol* sourceSymbol = sourceCursor.setToFirst() ? &sourceCursor.elementSAt() : nullptr;

      Coefficient* reusableCoeff = nullptr;
      BuiltReal* reusableCoeffValue = nullptr;
      Symbol::Type reusableType = Symbol::TUndefined;
      while (thisSymbol && sourceSymbol) {
         ComparisonResult compare = thisSymbol->compare(*sourceSymbol);
         ++basicOperationCounter;
         // coeff = (coeff*source.dCentral - dCentral*sourceCoeff)/source.dCentral
         if (compare == CREqual) {
            divAssignBothCoeffsWithCentrals(thisCursor, sourceCursor, thisSymbol, sourceSymbol,
                  source, policyCall, manager, referenceForAbsorption, reusableCoeff,
                  reusableCoeffValue, reusableType, highLevelLinear, nearestParams, maxParams,
                  hasExternalCoefficient);
            thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         }
         else if (compare == CRLess) {
            divAssignThisCoeffWithSourceCentral(thisCursor, thisSymbol, manager,
                  referenceForAbsorption, reusableCoeff, reusableCoeffValue, reusableType,
                  highLevelLinear, nearestParams, hasExternalCoefficient);
            thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
         }
         else if (compare == CRGreater) {
            divAssignSourceCoeffWithThisCentral(&thisCursor, sourceCursor, sourceSymbol, source,
                  policyCall, referenceForAbsorption, reusableCoeff, reusableCoeffValue,
                  reusableType, highLevelLinear, nearestParams, maxParams, manager,
                  hasExternalCoefficient);
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         }
         else
            {  AssumeUncalled }
      };

      while (thisSymbol) {
         divAssignThisCoeffWithSourceCentral(thisCursor, thisSymbol, manager, referenceForAbsorption,
               reusableCoeff, reusableCoeffValue, reusableType, highLevelLinear, nearestParams,
               hasExternalCoefficient);
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
      };
      while (sourceSymbol) {
         divAssignSourceCoeffWithThisCentral(nullptr, sourceCursor, sourceSymbol, source,
               policyCall, referenceForAbsorption, reusableCoeff, reusableCoeffValue, reusableType,
               highLevelLinear, nearestParams, maxParams, manager, hasExternalCoefficient);
         sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
      };
   };

   dCentral.setZero();
   apcCentralAdditions.release();
   BuiltReal max;
   ++basicOperationCounter;
   Cursor cursor(*this);
   for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
      AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
      const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
      const BuiltReal& coeffValue = coeff.getValue();
      ++basicOperationCounter;
      addAbsAssignToValue(max, coeff, coeffValue, maxParams, hasExternalCoefficient);
   };

   BuiltReal newCrossCoeffValue, newSquareCoeffValue;
   PNT::AutoPointer<Coefficient> crossCoeffAdditions, squareCoeffAdditions;
   multAssign(sourceInverse, PCSourceXValue, manager, newCrossCoeffValue, newSquareCoeffValue,
         highLevelError, crossCoeffAdditions, squareCoeffAdditions, hasExternalCoefficient);

   if (!TypeBaseFloatAffine::isPureZonotope()) {
      BuiltReal decision;
      setValueFromMaxCoeff(decision, newCrossCoeffValue, crossCoeffAdditions, hasExternalCoefficient);
      decision.divAssign(2U, maxParams);
      maxParams.clear();
      bool shouldChooseInterval = isValueGreaterOrEqualMaxCoeff(decision, newSquareCoeffValue, squareCoeffAdditions, hasExternalCoefficient);
      if (shouldChooseInterval) {
         subValueFromMaxCoeff(decision, newSquareCoeffValue, squareCoeffAdditions,
               maxParams, hasExternalCoefficient);
         decision.multAssign(16U, maxParams);
         maxParams.clear();
         Cursor cursor(*this);
         for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
            AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
            const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
            const BuiltReal& coeffValue = coeff.getValue();
            subValueFromMaxAbsCoeff(decision, coeff, coeffValue, maxParams, hasExternalCoefficient);
         };
         shouldChooseInterval = decision.isPositive();
      };
      if (shouldChooseInterval) {
         BuiltReal sourceMin, sourceMax;
         source.retrieveBound(sourceMin, sourceMax, hasExternalCoefficient);

         auto& minParams = TypeBaseFloatAffine::minParams();
         if (thisMin.isPositive() || thisMin.isZero()) {
            if (sourceMin.isPositive() || sourceMin.isZero()) {
               thisMin.divAssign(sourceMax, minParams);
               minParams.clear();
               thisMax.divAssign(sourceMin, maxParams);
               maxParams.clear();
               if (sourceMin.isZero())
                  return false;
            }
            else if (sourceMax.isNegative() || sourceMax.isZero()) {
               thisMin.divAssign(sourceMin, maxParams);
               maxParams.clear();
               thisMax.divAssign(sourceMax, minParams);
               minParams.clear();
               thisMin.swap(thisMax);
               if (sourceMax.isZero())
                  return false;
            }
            else { // thisMin.isPositive() && sourceMin.isNegative() && sourceMax.isPositive()
               thisMin.setInfty();
               thisMin.setNegative();
               thisMax.setInfty();
               return false;
            };
         }
         else if (thisMax.isNegative() || thisMax.isZero()) {
            if (sourceMin.isPositive() || sourceMin.isZero()) {
               thisMin.divAssign(sourceMin, minParams);
               minParams.clear();
               thisMax.divAssign(sourceMax, maxParams);
               maxParams.clear();
               if (sourceMin.isZero())
                  return false;
            }
            else if (sourceMax.isNegative() || sourceMax.isZero()) {
               thisMin.divAssign(sourceMax, maxParams);
               maxParams.clear();
               thisMax.divAssign(sourceMin, minParams);
               minParams.clear();
               thisMin.swap(thisMax);
               if (sourceMax.isZero())
                  return false;
            }
            else { // thisMin.isNegative() && sourceMin.isNegative() && sourceMax.isPositive()
               thisMin.setInfty();
               thisMin.setNegative();
               thisMax.setInfty();
               return false;
            };
         }
         else { // thisMin.isNegative() && thisMax.isPositive()
            if (sourceMin.isPositive() || sourceMin.isZero()) {
               thisMin.divAssign(sourceMin, minParams);
               minParams.clear();
               thisMax.divAssign(sourceMin, maxParams);
               maxParams.clear();
               if (sourceMin.isZero())
                  return false;
            }
            else if (sourceMax.isNegative() || sourceMax.isZero()) {
               thisMin.divAssign(sourceMax, maxParams);
               maxParams.clear();
               thisMax.divAssign(sourceMax, minParams);
               minParams.clear();
               thisMin.swap(thisMax);
               if (sourceMax.isZero())
                  return false;
            }
            else { // thisMin.isNegative() && thisMax.isPositive() && sourceMin.isNegative() && sourceMax.isPositive()
               thisMin.setInfty();
               thisMin.setNegative();
               thisMax.setInfty();
               return false;
            };
         }

         clear(&manager);
         setInterval(thisMin, thisMax, manager);
         return true;
      };
   };

   addAssignOptionCoefficient(newCrossCoeffValue, crossCoeffAdditions, newSquareCoeffValue,
         squareCoeffAdditions, maxParams, manager, hasExternalCoefficient);

   dCentral.plusAssign(centralAdd, nearestParams);
   adjustComputation(dCentral, highLevelError);
   apcCentralAdditions.swap(centralAddAdditions);

   // newCoeff += max * inverseNewCoeff;
   BuiltReal temp(inverseNewCoeff);
   temp.multAssign(max, maxParams);
   maxParams.clear();
   {  PNT::AutoPointer<Coefficient> tempAdditions; 
      addAssignOptionCoefficient(newCrossCoeffValue, crossCoeffAdditions, temp, tempAdditions,
            maxParams, manager, hasExternalCoefficient);
   };

   // highLevelError += max * inverseHighLevel
   max.multAssign(inverseHighLevel, maxParams);
   maxParams.clear();
   highLevelError.plusAssign(max, maxParams);
   maxParams.clear();

   // highLevelError += highLevelLinear * maxSourceInverse
   highLevelLinear.multAssign(maxSourceInverse, maxParams);
   maxParams.clear();
   highLevelError.plusAssign(highLevelLinear, maxParams);
   maxParams.clear();

   addNoise(newCrossCoeffValue, crossCoeffAdditions, highLevelError, manager, marked, hasExternalCoefficient);
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::sqrtAssign(
      SymbolsManager& manager, int* marked, bool hasExternalCoefficient) {
   BuiltReal sqrtMin = dCentral, sqrtMax = dCentral;
   if (hasExternalCoefficient && apcCentralAdditions.isValid())
      apcCentralAdditions->retrieveBound(sqrtMin, sqrtMax);
   ++basicOperationCounter;
   if (sqrtMin.isNegative() && !sqrtMin.isZero())
      return false;
   auto& minParams = TypeBaseFloatAffine::minParams();
   {  Cursor cursor(*this);
      for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
         const BuiltReal& coeffValue = coeff.getValue();
         addAssignBoundFromCoeff(sqrtMin, sqrtMax, coeff, coeffValue, minParams, minParams,
               hasExternalCoefficient);
         ++basicOperationCounter;
      };
   };

   if (sqrtMin.isNegative() && !sqrtMin.isZero())
      return false;
   {  BuiltReal tmpMin, tmpMax;
      sqrtMin.sqrtAssign(tmpMin, tmpMax, minParams);
      minParams.clear();
      sqrtMax.sqrtAssign(tmpMin, tmpMax, minParams);
      minParams.clear();
   };

   typename BuiltReal::BaseDouble errorMinCentral, errorMaxCentral;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   sqrtAssignOptionCentral(dCentral, apcCentralAdditions, errorMinCentral, errorMaxCentral,
         nearestParams, manager, hasExternalCoefficient);
   if (errorMinCentral.isNegative())
      errorMinCentral.opposite();
   if (errorMaxCentral.isNegative())
      errorMaxCentral.opposite();
   if (errorMinCentral < errorMaxCentral)
      errorMinCentral = errorMaxCentral;
   ++basicOperationCounter;
   BuiltReal highLevelError = errorMinCentral;
   Cursor thisCursor(*this);
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   while (thisCursor.setToNext()) {
      Coefficient* thisCoeff = &(Coefficient&) thisCursor.globalElementSAt();
      BuiltReal& thisCoeffValue = thisCoeff->getSValue();
      BuiltReal localError;
      setValueFromMaxCoeff(localError, *thisCoeff, thisCoeffValue, hasExternalCoefficient);
      localError.multAssign(errorMinCentral, maxParams);
      maxParams.clear();
      divAssignMaxOption(localError, dCentral, apcCentralAdditions, maxParams, hasExternalCoefficient);
      {  BuiltReal tmp(dCentral);
         if (apcCentralAdditions.isValid()) {
            BuiltReal max;
            apcCentralAdditions->retrieveBound(tmp, max);
         };
         tmp.minusAssign(errorMinCentral, minParams);
         minParams.clear();
         localError.divAssign(tmp, maxParams);
         maxParams.clear();
      };
      divAssignOptionCoefficient(thisCoeff, thisCoeffValue, dCentral, apcCentralAdditions,
            localError, thisCursor, nearestParams, manager, hasExternalCoefficient);
      ++basicOperationCounter;
      localError.divAssign(2U, maxParams);
      maxParams.clear();
      divAssignToCoefficient(*thisCoeff, thisCoeffValue, 2U, localError,
            nearestParams, manager, hasExternalCoefficient);
      highLevelError.plusAssign(localError, maxParams);
      maxParams.clear();
   };

   BuiltReal sqrtComputedMin(dCentral), sqrtComputedMax(dCentral);
   if (hasExternalCoefficient && apcCentralAdditions.isValid())
      apcCentralAdditions->retrieveBound(sqrtComputedMin, sqrtComputedMax);
   {  Cursor cursor(*this);
      for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
         const BuiltReal& coeffValue = coeff.getValue();
         addAssignBoundFromCoeff(sqrtComputedMin, sqrtComputedMax, coeff, coeffValue,
               maxParams, maxParams, hasExternalCoefficient);
         ++basicOperationCounter;
      };
   };
   sqrtMin.minusAssign(sqrtComputedMin, minParams);
   minParams.clear();
   sqrtMax.minusAssign(sqrtComputedMax, minParams);
   minParams.clear();
   if (sqrtMax < sqrtMin)
      sqrtMin = sqrtMax;
   sqrtMin.divAssign(2U, minParams);
   minParams.clear();
   if (!sqrtMin.isZero()) {
      PNT::AutoPointer<Coefficient> sqrtMinAdditions;
      addAssignOptionCentral(dCentral, apcCentralAdditions, sqrtMin, sqrtMinAdditions,
            highLevelError, nearestParams, manager, hasExternalCoefficient);
      Symbol* foundSymbol = nullptr;
      Coefficient* foundCoeff = nullptr;
      BuiltReal* foundCoeffValue = nullptr;
      if (marked) {
         Cursor foundCursor(*this);
         if (foundCursor.setToLast()) {
            MarkedNoiseSymbol search(*marked);
            ComparisonResult compare;
            do {
               compare = foundCursor.elementAt().compare(search);
            } while (compare == CRGreater && foundCursor.setToPrevious());
            if (compare == CREqual) {
               foundSymbol = manager.createMarkedNoiseSymbol(foundCursor.elementAt().getOrder());
               replaceElementAtWith(foundCursor, *foundSymbol);
               // foundSymbol = &foundCursor.elementSAt();
               foundCoeff = &(Coefficient&) foundCursor.globalElementSAt();
               foundCoeffValue = &foundCoeff->getSValue();
            };
         };
      };
      if (!foundSymbol) {
         Symbol* newSymbol = !marked ? manager.createNoiseSymbol() : manager.createMarkedNoiseSymbol(*marked);
         Cursor cursor(*this);
         if (cursor.setToLast())
            while (cursor.elementAt() > *newSymbol && cursor.setToPrevious());
         Coefficient* coeff = (Coefficient*) addElementAfter(*newSymbol, cursor);
         coeff->setValue(sqrtMin);
         oppositeAssignCoefficient(*coeff, coeff->getSValue(), hasExternalCoefficient);
      }
      else {
         Coefficient coeff;
         coeff.getSValue() = sqrtMin;
         addAbsAssignToCoefficient(foundCoeff, foundCoeffValue, coeff, sqrtMin, highLevelError,
               nearestParams, manager, hasExternalCoefficient);
      }
   };
   
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::expAssign(
      SymbolsManager& manager, int* marked, bool hasExternalCoefficient) {
   BuiltReal expMin = dCentral, expMax = dCentral;
   if (hasExternalCoefficient && apcCentralAdditions.isValid())
      apcCentralAdditions->retrieveBound(expMin, expMax);
   ++basicOperationCounter;
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   {  Cursor cursor(*this);
      for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
         const BuiltReal& coeffValue = coeff.getValue();
         addAssignBoundFromCoeff(expMin, expMax, coeff, coeffValue, maxParams, maxParams,
               hasExternalCoefficient);
         ++basicOperationCounter;
      };
   };

   {  BuiltReal tmpMin, tmpMax;
      expMin.expAssign(tmpMin, tmpMax, maxParams);
      maxParams.clear();
      expMax.expAssign(tmpMin, tmpMax, maxParams);
      maxParams.clear();
   };

   typename BuiltReal::BaseDouble errorMinCentral, errorMaxCentral;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   expAssignOptionCentral(dCentral, apcCentralAdditions, errorMinCentral, errorMaxCentral,
         nearestParams, manager, hasExternalCoefficient);
   ++basicOperationCounter;
   if (errorMinCentral.isNegative())
      errorMinCentral.opposite();
   if (errorMaxCentral.isNegative())
      errorMaxCentral.opposite();
   if (errorMinCentral < errorMaxCentral)
      errorMinCentral = errorMaxCentral;
   BuiltReal highLevelError(errorMinCentral);
   Cursor thisCursor(*this);
   while (thisCursor.setToNext()) {
      Coefficient* thisCoeff = &(Coefficient&) thisCursor.globalElementSAt();
      BuiltReal& thisCoeffValue = thisCoeff->getSValue();
      BuiltReal localError;
      setValueFromMaxCoeff(localError, *thisCoeff, thisCoeffValue, hasExternalCoefficient);
      localError.multAssign(errorMinCentral, maxParams);
      maxParams.clear();
      multAssignOptionCoefficient(thisCoeff, thisCoeffValue, dCentral, apcCentralAdditions,
            localError, thisCursor, nearestParams, maxParams, manager, hasExternalCoefficient);
      ++basicOperationCounter;
      highLevelError.plusAssign(localError, maxParams);
      maxParams.clear();
   };

   BuiltReal expComputedMin(dCentral), expComputedMax(dCentral);
   if (hasExternalCoefficient && apcCentralAdditions.isValid())
      apcCentralAdditions->retrieveBound(expComputedMin, expComputedMax);
   {  Cursor cursor(*this);
      for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
         const BuiltReal& coeffValue = coeff.getValue();
         ++basicOperationCounter;
         addAssignBoundFromCoeff(expComputedMin, expComputedMax, coeff, coeffValue,
               maxParams, maxParams, hasExternalCoefficient);
      };
   };
   expMin.minusAssign(expComputedMin, maxParams);
   maxParams.clear();
   expMax.minusAssign(expComputedMax, maxParams);
   maxParams.clear();
   if (expMax < expMin)
      expMax = expMin;
   expMax.divAssign(2U, maxParams);
   maxParams.clear();
   if (!expMax.isZero()) {
      PNT::AutoPointer<Coefficient> expMaxAdditions;
      addAssignOptionCentral(dCentral, apcCentralAdditions, expMax, expMaxAdditions,
            highLevelError, nearestParams, manager, hasExternalCoefficient);
      Symbol* foundSymbol = nullptr;
      Coefficient* foundCoeff = nullptr;
      BuiltReal* foundCoeffValue = nullptr;
      if (marked) {
         Cursor foundCursor(*this);
         if (foundCursor.setToLast()) {
            MarkedNoiseSymbol search(*marked);
            ComparisonResult compare;
            do {
               compare = foundCursor.elementAt().compare(search);
            } while (compare == CRGreater && foundCursor.setToPrevious());
            if (compare == CREqual) {
               foundSymbol = manager.createMarkedNoiseSymbol(foundCursor.elementAt().getOrder());
               replaceElementAtWith(foundCursor, *foundSymbol);
               // foundSymbol = &foundCursor.elementSAt();
               foundCoeff = &(Coefficient&) foundCursor.globalElementSAt();
               foundCoeffValue = &foundCoeff->getSValue();
            };
         };
      };
      if (!foundSymbol) {
         Symbol* newSymbol = !marked ? manager.createNoiseSymbol() : manager.createMarkedNoiseSymbol(*marked);
         Cursor cursor(*this);
         if (cursor.setToLast())
            while (cursor.elementAt() > *newSymbol && cursor.setToPrevious());
         Coefficient* coeff = (Coefficient*) addElementAfter(*newSymbol, cursor);
         coeff->setValue(expMax);
      }
      else {
         Coefficient coeff;
         coeff.getSValue() = expMax;
         addAbsAssignToCoefficient(foundCoeff, foundCoeffValue, coeff, expMax, highLevelError,
               nearestParams, manager, hasExternalCoefficient);
      };
   };
   
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::logAssign(
      SymbolsManager& manager, int* marked, bool hasExternalCoefficient) {
   BuiltReal logMin = dCentral, logMax = dCentral;
   if (hasExternalCoefficient && apcCentralAdditions.isValid())
      apcCentralAdditions->retrieveBound(logMin, logMax);
   ++basicOperationCounter;
   if (logMin.isNegative() || logMin.isZero())
      return false;
   auto& minParams = TypeBaseFloatAffine::minParams();
   {  Cursor cursor(*this);
      for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
         const BuiltReal& coeffValue = coeff.getValue();
         ++basicOperationCounter;
         addAssignBoundFromCoeff(logMin, logMax, coeff, coeffValue, minParams, minParams,
               hasExternalCoefficient);
      };
   };

   if (logMin.isNegative() || logMin.isZero())
      return false;
   {  BuiltReal tmpMin, tmpMax;
      logMin.logAssign(tmpMin, tmpMax, minParams);
      minParams.clear();
      logMax.logAssign(tmpMin, tmpMax, minParams);
      minParams.clear();
   };

   BuiltReal highLevelError;
   Cursor thisCursor(*this);
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   while (thisCursor.setToNext()) {
      Coefficient* thisCoeff = &(Coefficient&) thisCursor.globalElementSAt();
      BuiltReal& thisCoeffValue = thisCoeff->getSValue();
      divAssignOptionCoefficient(thisCoeff, thisCoeffValue, dCentral, apcCentralAdditions,
            highLevelError, thisCursor, nearestParams, manager, hasExternalCoefficient);
      ++basicOperationCounter;
   };

   typename BuiltReal::BaseDouble errorMinCentral, errorMaxCentral;
   logAssignOptionCentral(dCentral, apcCentralAdditions, errorMinCentral, errorMaxCentral,
         nearestParams, manager, hasExternalCoefficient);
   if (errorMinCentral.isNegative())
      errorMinCentral.opposite();
   if (errorMaxCentral.isNegative())
      errorMaxCentral.opposite();
   if (errorMinCentral < errorMaxCentral)
      errorMinCentral = errorMaxCentral;
   ++basicOperationCounter;
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   highLevelError.plusAssign(errorMinCentral, maxParams);
   maxParams.clear();

   BuiltReal logComputedMin(dCentral), logComputedMax(dCentral);
   if (hasExternalCoefficient && apcCentralAdditions.isValid())
      apcCentralAdditions->retrieveBound(logComputedMin, logComputedMax);
   {  Cursor cursor(*this);
      for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
         AssumeCondition(dynamic_cast<const Coefficient*>(&cursor.globalElementAt()))
         const Coefficient& coeff = (const Coefficient&) cursor.globalElementAt();
         const BuiltReal& coeffValue = coeff.getValue();
         ++basicOperationCounter;
         addAssignBoundFromCoeff(logComputedMin, logComputedMax, coeff, coeffValue,
               maxParams, maxParams, hasExternalCoefficient);
      };
   };
   logMin.minusAssign(logComputedMin, minParams);
   minParams.clear();
   logMax.minusAssign(logComputedMax, minParams);
   minParams.clear();
   if (logMax < logMin)
      logMin = logMax;
   logMin.divAssign(2U, minParams);
   minParams.clear();
   if (!logMin.isZero()) {
      PNT::AutoPointer<Coefficient> logMinAdditions;
      addAssignOptionCentral(dCentral, apcCentralAdditions, logMin, logMinAdditions,
            highLevelError, nearestParams, manager, hasExternalCoefficient);
      Symbol* foundSymbol = nullptr;
      Coefficient* foundCoeff = nullptr;
      BuiltReal* foundCoeffValue = nullptr;
      if (marked) {
         Cursor foundCursor(*this);
         if (foundCursor.setToLast()) {
            MarkedNoiseSymbol search(*marked);
            ComparisonResult compare;
            do {
               compare = foundCursor.elementAt().compare(search);
            } while (compare == CRGreater && foundCursor.setToPrevious());
            if (compare == CREqual) {
               foundSymbol = manager.createMarkedNoiseSymbol(foundCursor.elementAt().getOrder());
               replaceElementAtWith(foundCursor, *foundSymbol);
               // foundSymbol = &foundCursor.elementSAt();
               foundCoeff = &(Coefficient&) foundCursor.globalElementSAt();
               foundCoeffValue = &foundCoeff->getSValue();
            };
         };
      };
      if (!foundSymbol) {
         Symbol* newSymbol = !marked ? manager.createNoiseSymbol() : manager.createMarkedNoiseSymbol(*marked);
         Cursor cursor(*this);
         if (cursor.setToLast())
            while (cursor.elementAt() > *newSymbol && cursor.setToPrevious());
         Coefficient* coeff = (Coefficient*) addElementAfter(*newSymbol, cursor);
         coeff->setValue(logMin);
         oppositeAssignCoefficient(*coeff, coeff->getSValue(), hasExternalCoefficient);
      }
      else {
         Coefficient coeff;
         coeff.getSValue() = logMin;
         addAbsAssignToCoefficient(foundCoeff, foundCoeffValue, coeff, logMin, highLevelError,
               nearestParams, manager, hasExternalCoefficient);
      };
   };
   
   addHighLevel(highLevelError, manager, hasExternalCoefficient);
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::temporalMergeWith(const thisType& source,
      SymbolsManager& manager, bool hasExternalCoefficient) {
   if (this == &source)
      return;

   BuiltReal thisAddition, thisHighLevelError, sourceAddition, sourceHighLevelError,
             thisMinConstantAddition, thisMaxConstantAddition, sourceMinConstantAddition, sourceMaxConstantAddition;
   // [TODO] improve the symetry of treatment between this and source in all cases
   if (!hasExternalCoefficient || (!apcCentralAdditions.isValid() && !source.apcCentralAdditions.isValid())) {
      if (dCentral != source.dCentral) {
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         if (dCentral < source.dCentral) {
            thisMinConstantAddition = source.dCentral;
            thisMinConstantAddition.minusAssign(dCentral, maxParams);
            maxParams.clear();
         }
         else { // dCentral > source.dCentral
            thisMinConstantAddition = dCentral;
            thisMinConstantAddition.minusAssign(source.dCentral, maxParams);
            maxParams.clear();
         };
         dCentral = source.dCentral;
         thisMaxConstantAddition = thisMinConstantAddition;
      };
   }
   else if (apcCentralAdditions.isValid()) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      if (source.apcCentralAdditions.isValid()) {
         PNT::AutoPointer<Coefficient>  diff(apcCentralAdditions);
         diff->minusAssign(*source.apcCentralAdditions, thisHighLevelError, nearestParams, manager, *this);
         diff->retrieveBound(thisMinConstantAddition, thisMaxConstantAddition);
      }
      else {
         apcCentralAdditions->retrieveBound(thisMinConstantAddition, thisMaxConstantAddition);
         thisMinConstantAddition.minusAssign(source.dCentral, nearestParams);
         adjustComputation(thisMinConstantAddition, thisHighLevelError);
         thisMaxConstantAddition.minusAssign(source.dCentral, nearestParams);
         adjustComputation(thisMaxConstantAddition, thisHighLevelError);
      };
      if (source.apcCentralAdditions.isValid())
         apcCentralAdditions = source.apcCentralAdditions;
      else {
         dCentral = source.dCentral;
         apcCentralAdditions.release();
      };
   }
   else { // sourceCoeff.isValid()
      source.apcCentralAdditions->retrieveBound(thisMinConstantAddition, thisMaxConstantAddition);
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      thisMinConstantAddition.minusAssign(dCentral, nearestParams);
      adjustComputation(thisMinConstantAddition, sourceHighLevelError);
      thisMaxConstantAddition.minusAssign(dCentral, nearestParams);
      adjustComputation(thisMaxConstantAddition, sourceHighLevelError);
      thisMinConstantAddition.swap(thisMaxConstantAddition);
      thisMinConstantAddition.opposite();
      thisMaxConstantAddition.opposite();
      apcCentralAdditions = source.apcCentralAdditions;
      dCentral.clear();
   };
   sourceMinConstantAddition = thisMaxConstantAddition;
   sourceMinConstantAddition.opposite();
   sourceMaxConstantAddition = thisMinConstantAddition;
   sourceMaxConstantAddition.opposite();

   Cursor thisCursor(*this), sourceCursor(source);
   if (thisCursor.setToFirst()) {
      Symbol* thisSymbol = &thisCursor.elementSAt();
      if (sourceCursor.setToFirst()) {
         Symbol* sourceSymbol = &sourceCursor.elementSAt();
         do {
            ++basicOperationCounter;
            ComparisonResult compare = thisSymbol->compare(*sourceSymbol);
            if (compare == CREqual) {
               Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
               BuiltReal& thisCoeffValue = thisCoeff.getSValue();
               const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
               const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
               bool doesReplace = false;
               if (!hasExternalCoefficient || (!thisCoeff.isExternal() && !sourceCoeff.isExternal())) {
                  if (sourceCoeffValue.isNegative() == thisCoeffValue.isNegative()) {
                     if (thisCoeffValue != sourceCoeffValue) {
                        auto& maxParams = TypeBaseFloatAffine::maxParams();
                        if (!thisCoeffValue.isNegative()) {
                           if (thisCoeffValue > sourceCoeffValue) {
                              BuiltReal diff = thisCoeffValue;
                              diff.minusAssign(sourceCoeffValue, maxParams);
                              maxParams.clear();
                              thisAddition.plusAssign(diff, maxParams);
                              maxParams.clear();
                              thisCoeffValue = sourceCoeffValue;
                           }
                           else {
                              BuiltReal diff = sourceCoeffValue;
                              diff.minusAssign(thisCoeffValue, maxParams);
                              maxParams.clear();
                              sourceAddition.plusAssign(diff, maxParams);
                              maxParams.clear();
                           }
                        }
                        else { // thisCoeffValue.isNegative()
                           if (thisCoeffValue < sourceCoeffValue) {
                              BuiltReal diff = sourceCoeffValue;
                              auto& maxParams = TypeBaseFloatAffine::maxParams();
                              diff.minusAssign(thisCoeffValue, maxParams);
                              maxParams.clear();
                              thisAddition.plusAssign(diff, maxParams);
                              maxParams.clear();
                              thisCoeffValue = sourceCoeffValue;
                           }
                           else {
                              BuiltReal diff = thisCoeffValue;
                              diff.minusAssign(sourceCoeffValue, maxParams);
                              maxParams.clear();
                              sourceAddition.plusAssign(diff, maxParams);
                              maxParams.clear();
                           }
                        };
                     }
                  }
                  else { // sourceCoeffValue.isNegative() != thisCoeffValue.isNegative()
                     auto& maxParams = TypeBaseFloatAffine::maxParams();
                     if (thisCoeffValue.isPositive())
                        thisAddition.plusAssign(thisCoeffValue, maxParams);
                     else
                        thisAddition.minusAssign(thisCoeffValue, maxParams);
                     maxParams.clear();
                     if (sourceCoeffValue.isPositive())
                        sourceAddition.plusAssign(sourceCoeffValue, maxParams);
                     else
                        sourceAddition.minusAssign(sourceCoeffValue, maxParams);
                     HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
                           && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
                     Cursor thisRemoveCursor(thisCursor);
                     thisCursor.setToPrevious();
                     removeAt(thisRemoveCursor);
                     if (symbolToFree)
                        manager.freeHighLevelSymbol(symbolToFree);
                  };
               }
               else if (thisCoeff.isExternal() || !sourceCoeff.isExternal()) {
                  AssumeUnimplemented
                  // PNT::AutoPointer<Coefficient> diffCoeff(thisCoeff);
                  // auto& nearestParams = TypeBaseFloatAffine::nearestParams();
                  // diffCoeff->minusAssign(sourceCoeff, thisHighLevelError, nearestParams, manager, *this);
                  // BuiltReal min, max, minThis, maxThis, minSource, maxSource;
                  // diffCoeff.retrieveBound(min, max);
                  // if (min.isPositive()) { // thisCoeff > sourceCoeff
                  //    
                  // };
                  // if (min.isPositive() && !min.isZero())
                  //    diff = min;
                  // if (!min.isZero() && !max.isZero())
                  //    inherited::replaceAndFreeGlobalElementAtWithCopy(thisCursor, sourceCoeff);
               }
               else {
                  AssumeUnimplemented
               };

               if (doesReplace)
                  inherited::replaceAndFreeGlobalElementAtWithCopy(thisCursor, sourceCoeff);
               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else if (compare == CRLess) {
               Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
               BuiltReal& thisCoeffValue = thisCoeff.getSValue();
               if (!hasExternalCoefficient || !thisCoeff.isExternal()) {
                  auto& maxParams = TypeBaseFloatAffine::maxParams();
                  if (thisCoeffValue.isPositive())
                     thisAddition.plusAssign(thisCoeffValue, maxParams);
                  else
                     thisAddition.minusAssign(thisCoeffValue, maxParams);
                  maxParams.clear();
                  HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
                        && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
                  Cursor thisRemoveCursor(thisCursor);
                  thisCursor.setToPrevious();
                  removeAt(thisRemoveCursor);
                  if (symbolToFree)
                     manager.freeHighLevelSymbol(symbolToFree);
               }
               else {
                  AssumeUnimplemented
               }
               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
            }
            else if (compare == CRGreater) {
               const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
               const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
               if (!hasExternalCoefficient || !sourceCoeff.isExternal()) {
                  auto& maxParams = TypeBaseFloatAffine::maxParams();
                  if (sourceCoeffValue.isPositive())
                     sourceAddition.plusAssign(sourceCoeffValue, maxParams);
                  else
                     sourceAddition.minusAssign(sourceCoeffValue, maxParams);
                  maxParams.clear();
               }
               else {
                  AssumeUnimplemented
               };
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else
               {  AssumeUncalled }
         } while (thisSymbol && sourceSymbol);

         while (sourceSymbol) {
            const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
            const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
            if (!hasExternalCoefficient || !sourceCoeff.isExternal()) {
               auto& maxParams = TypeBaseFloatAffine::maxParams();
               if (sourceCoeffValue.isPositive())
                  sourceAddition.plusAssign(sourceCoeffValue, maxParams);
               else
                  sourceAddition.minusAssign(sourceCoeffValue, maxParams);
               maxParams.clear();
            }
            else {
               AssumeUnimplemented
            };
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         };
      };
      while (thisSymbol) {
         Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
         BuiltReal& thisCoeffValue = thisCoeff.getSValue();
         if (!hasExternalCoefficient || !thisCoeff.isExternal()) {
            auto& maxParams = TypeBaseFloatAffine::maxParams();
            if (thisCoeffValue.isPositive())
               thisAddition.plusAssign(thisCoeffValue, maxParams);
            else
               thisAddition.minusAssign(thisCoeffValue, maxParams);
            maxParams.clear();
            HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
                  && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
            Cursor thisRemoveCursor(thisCursor);
            thisCursor.setToPrevious();
            removeAt(thisRemoveCursor);
            if (symbolToFree)
               manager.freeHighLevelSymbol(symbolToFree);
         }
         else {
            AssumeUnimplemented
         }
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
      };
   }
   else {
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      while (sourceCursor.setToNext()) {
         const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
         const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
         if (!hasExternalCoefficient || !sourceCoeff.isExternal()) {
            if (sourceCoeffValue.isPositive())
               sourceAddition.plusAssign(sourceCoeffValue, maxParams);
            else
               sourceAddition.minusAssign(sourceCoeffValue, maxParams);
            maxParams.clear();
         }
         else {
            AssumeUnimplemented
         };
      };
   };
   auto& minParams = TypeBaseFloatAffine::minParams();
   BuiltReal thisMin, sourceMin, thisMax, sourceMax;
   thisMin = thisMinConstantAddition;
   thisMin.minusAssign(thisAddition, minParams);
   minParams.clear();
   sourceMin = sourceMinConstantAddition;
   sourceMin.minusAssign(sourceAddition, minParams);
   minParams.clear();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   thisMax = thisMaxConstantAddition;
   thisMax.plusAssign(thisAddition, maxParams);
   maxParams.clear();
   sourceMax = sourceMaxConstantAddition;
   sourceMax.plusAssign(sourceAddition, maxParams);
   maxParams.clear();

   if (thisHighLevelError < sourceHighLevelError)
      thisHighLevelError = sourceHighLevelError;
   PNT::AutoPointer<Coefficient> coeffAdditions; 
/* if (thisMin <= sourceMin && thisMax >= sourceMax) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      dCentral.plusAssign(thisConstantAddition, nearestParams);
      adjustComputation(dCentral, highLevelError);
      addNoise(thisAddition, coeffAdditions, highLevelError, manager, nullptr, hasExternalCoefficient);
   }
   else if (sourceMin <= thisMin && sourceMax >= thisMax) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      dCentral.plusAssign(sourceConstantAddition, nearestParams);
      adjustComputation(dCentral, highLevelError);
      addNoise(sourceAddition, coeffAdditions, highLevelError, manager, nullptr, hasExternalCoefficient);
   }
   else { */
      if (thisMin > sourceMin)
         thisMin = sourceMin;
      if (thisMax < sourceMax)
         thisMax = sourceMax;
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      thisMin.plusAssign(thisMax, nearestParams);
      BuiltReal localHighLevelError;
      adjustComputation(thisMin, localHighLevelError);
      localHighLevelError.divAssign(2U, maxParams);
      maxParams.clear();
      thisMin.divAssign(2U, nearestParams);
      adjustComputation(thisMin, thisHighLevelError);
      thisHighLevelError.plusAssign(localHighLevelError, maxParams);
      maxParams.clear();
      dCentral.plusAssign(thisMin, nearestParams);
      adjustComputation(dCentral, thisHighLevelError);
      thisMax.minusAssign(thisMin, maxParams);
      maxParams.clear();
      addNoise(thisMax, coeffAdditions, thisHighLevelError, manager, nullptr, hasExternalCoefficient);
/* }; */
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::spatialMergeWith(const thisType& source,
      SymbolsManager& manager, bool hasExternalCoefficient) {
   if (this == &source)
      return;

   BuiltReal thisAddition, sourceAddition, thisConstantAddition, sourceConstantAddition, highLevelError;
   // [TODO] improve the symetry of treatment between this and source in all cases
   if (!hasExternalCoefficient || (!apcCentralAdditions.isValid() && !source.apcCentralAdditions.isValid())) {
      if (dCentral != source.dCentral) {
         thisConstantAddition = dCentral;
         auto& nearestParams = TypeBaseFloatAffine::nearestParams();
         dCentral.plusAssign(source.dCentral, nearestParams);
         adjustComputation(dCentral, highLevelError);
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         highLevelError.divAssign(2U, maxParams);
         maxParams.clear();
         dCentral.divAssign(2U, nearestParams);
         adjustComputation(dCentral, highLevelError);
         thisConstantAddition.minusAssign(dCentral, nearestParams);
         adjustComputation(thisConstantAddition, highLevelError);
         sourceConstantAddition = thisConstantAddition;
         sourceConstantAddition.opposite();
      };
   }
   else if (apcCentralAdditions.isValid()) {
      AssumeUnimplemented
   }
   else { // sourceCoeff.isValid()
      AssumeUnimplemented
   };

   Cursor thisCursor(*this), sourceCursor(source);
   if (thisCursor.setToFirst()) {
      Symbol* thisSymbol = &thisCursor.elementSAt();
      if (sourceCursor.setToFirst()) {
         Symbol* sourceSymbol = &sourceCursor.elementSAt();
         do {
            ++basicOperationCounter;
            ComparisonResult compare = thisSymbol->compare(*sourceSymbol);
            if (compare == CREqual) {
               Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
               BuiltReal& thisCoeffValue = thisCoeff.getSValue();
               const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
               const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
               if (!hasExternalCoefficient || (!thisCoeff.isExternal() && !sourceCoeff.isExternal())) {
                  auto& nearestParams = TypeBaseFloatAffine::nearestParams();
                  auto& maxParams = TypeBaseFloatAffine::maxParams();
                  if (thisCoeffValue.isPositive() == sourceCoeffValue.isPositive()) {
                     // thisCoeffValue <- min(|thisCoeffValue|, |sourceCoeffValue|)*sign
                     bool isGreater = thisCoeffValue > sourceCoeffValue;
                     if (thisCoeffValue.isPositive() ? isGreater : !isGreater) {
                        // |thisCoeffValue| > |sourceCoeffValue|
                        BuiltReal add = thisCoeffValue;
                        thisCoeffValue = sourceCoeffValue;
                        add.minusAssign(sourceCoeffValue, nearestParams);
                        adjustComputation(add, highLevelError);
                        if (add.isNegative())
                           add.opposite();
                        thisAddition.plusAssign(add, maxParams);
                        maxParams.clear();
                     }
                     else if (thisCoeffValue != sourceCoeffValue) {
                        // |thisCoeffValue| < |sourceCoeffValue|
                        BuiltReal add = sourceCoeffValue;
                        add.minusAssign(thisCoeffValue, nearestParams);
                        adjustComputation(add, highLevelError);
                        if (add.isNegative())
                           add.opposite();
                        sourceAddition.plusAssign(add, maxParams);
                        maxParams.clear();
                     };
                  }
                  else {
                     // thisCoeffValue <- 0
                     if (thisCoeffValue.isPositive())
                        thisAddition.plusAssign(thisCoeffValue, maxParams);
                     else
                        thisAddition.minusAssign(thisCoeffValue, maxParams);
                     maxParams.clear();
                     if (sourceCoeffValue.isPositive())
                        sourceAddition.plusAssign(sourceCoeffValue, maxParams);
                     else
                        sourceAddition.minusAssign(sourceCoeffValue, maxParams);
                     maxParams.clear();
                     thisCoeffValue.clear();
                  };
                  if (thisCoeffValue.isZero()) {
                     HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
                           && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
                     Cursor thisRemoveCursor(thisCursor);
                     thisCursor.setToPrevious();
                     removeAt(thisRemoveCursor);
                     if (symbolToFree)
                        manager.freeHighLevelSymbol(symbolToFree);
                  };
               }
               else if (thisCoeff.isExternal() || !sourceCoeff.isExternal()) {
                  AssumeUnimplemented
                  // PNT::AutoPointer<Coefficient> diffCoeff(thisCoeff);
                  // auto& nearestParams = TypeBaseFloatAffine::nearestParams();
                  // diffCoeff->minusAssign(sourceCoeff, thisHighLevelError, nearestParams, manager, *this);
                  // BuiltReal min, max, minThis, maxThis, minSource, maxSource;
                  // diffCoeff.retrieveBound(min, max);
                  // if (min.isPositive()) { // thisCoeff > sourceCoeff
                  //    
                  // };
                  // if (min.isPositive() && !min.isZero())
                  //    diff = min;
                  // if (!min.isZero() && !max.isZero())
                  //    inherited::replaceAndFreeGlobalElementAtWithCopy(thisCursor, sourceCoeff);
               }
               else {
                  AssumeUnimplemented
               };

               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else if (compare == CRLess) {
               Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
               BuiltReal& thisCoeffValue = thisCoeff.getSValue();
               if (!hasExternalCoefficient || !thisCoeff.isExternal()) {
                  auto& maxParams = TypeBaseFloatAffine::maxParams();
                  if (thisCoeffValue.isPositive())
                     thisAddition.plusAssign(thisCoeffValue, maxParams);
                  else
                     thisAddition.minusAssign(thisCoeffValue, maxParams);
                  maxParams.clear();
                  HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
                        && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
                  Cursor thisRemoveCursor(thisCursor);
                  thisCursor.setToPrevious();
                  removeAt(thisRemoveCursor);
                  if (symbolToFree)
                     manager.freeHighLevelSymbol(symbolToFree);
               }
               else {
                  AssumeUnimplemented
               }
               thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
            }
            else if (compare == CRGreater) {
               const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
               if (!hasExternalCoefficient || !sourceCoeff.isExternal()) {
                  AssumeCondition(!((const Coefficient&) sourceCoeff).isExternal())
                  const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
                  auto& maxParams = TypeBaseFloatAffine::maxParams();
                  if (sourceCoeffValue.isPositive())
                     sourceAddition.plusAssign(sourceCoeffValue, maxParams);
                  else
                     sourceAddition.minusAssign(sourceCoeffValue, maxParams);
                  maxParams.clear();
               }
               else {
                  AssumeUnimplemented
               };
               sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
            }
            else
               {  AssumeUncalled }
         } while (thisSymbol && sourceSymbol);

         while (sourceSymbol) {
            const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
            if (!hasExternalCoefficient || !sourceCoeff.isExternal()) {
               AssumeCondition(!((const Coefficient&) sourceCoeff).isExternal())
               const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
               auto& maxParams = TypeBaseFloatAffine::maxParams();
               if (sourceCoeffValue.isPositive())
                  sourceAddition.plusAssign(sourceCoeffValue, maxParams);
               else
                  sourceAddition.minusAssign(sourceCoeffValue, maxParams);
               maxParams.clear();
            }
            else {
               AssumeUnimplemented
            };
            sourceSymbol = sourceCursor.setToNext() ? &sourceCursor.elementSAt() : nullptr;
         };
      };
      while (thisSymbol) {
         Coefficient& thisCoeff = (Coefficient&) thisCursor.globalElementSAt();
         BuiltReal& thisCoeffValue = thisCoeff.getSValue();
         if (!hasExternalCoefficient || !thisCoeff.isExternal()) {
            auto& maxParams = TypeBaseFloatAffine::maxParams();
            if (thisCoeffValue.isPositive())
               thisAddition.plusAssign(thisCoeffValue, maxParams);
            else
               thisAddition.minusAssign(thisCoeffValue, maxParams);
            maxParams.clear();
            HighLevelSymbol* symbolToFree = (thisSymbol->getType() == Symbol::THighLevel
                  && !thisSymbol->isReferenced()) ? (HighLevelSymbol*) thisSymbol : nullptr;
            Cursor thisRemoveCursor(thisCursor);
            thisCursor.setToPrevious();
            removeAt(thisRemoveCursor);
            if (symbolToFree)
               manager.freeHighLevelSymbol(symbolToFree);
         }
         else {
            AssumeUnimplemented
         }
         thisSymbol = thisCursor.setToNext() ? &thisCursor.elementSAt() : nullptr;
      };
   }
   else {
      auto& maxParams = TypeBaseFloatAffine::maxParams();
      while (sourceCursor.setToNext()) {
         const Coefficient& sourceCoeff = (Coefficient&) sourceCursor.globalElementAt();
         if (!hasExternalCoefficient || !sourceCoeff.isExternal()) {
            AssumeCondition(!((const Coefficient&) sourceCoeff).isExternal())
            const BuiltReal& sourceCoeffValue = sourceCoeff.getValue();
            if (sourceCoeffValue.isPositive())
               sourceAddition.plusAssign(sourceCoeffValue, maxParams);
            else
               sourceAddition.minusAssign(sourceCoeffValue, maxParams);
            maxParams.clear();
         }
         else {
            AssumeUnimplemented
         };
      };
   };
   auto& minParams = TypeBaseFloatAffine::minParams();
   BuiltReal thisMin, sourceMin, thisMax, sourceMax;
   thisMin = thisConstantAddition;
   thisMin.minusAssign(thisAddition, minParams);
   minParams.clear();
   sourceMin = sourceConstantAddition;
   sourceMin.minusAssign(sourceAddition, minParams);
   minParams.clear();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   thisMax = thisConstantAddition;
   thisMax.plusAssign(thisAddition, maxParams);
   maxParams.clear();
   sourceMax = sourceConstantAddition;
   sourceMax.plusAssign(sourceAddition, maxParams);
   maxParams.clear();
   PNT::AutoPointer<Coefficient> coeffAdditions; 
   if (thisMin <= sourceMin && thisMax >= sourceMax) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      dCentral.plusAssign(thisConstantAddition, nearestParams);
      adjustComputation(dCentral, highLevelError);
      addNoise(thisAddition, coeffAdditions, highLevelError, manager, nullptr, hasExternalCoefficient);
   }
   else if (sourceMin <= thisMin && sourceMax >= thisMax) {
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      dCentral.plusAssign(sourceConstantAddition, nearestParams);
      adjustComputation(dCentral, highLevelError);
      addNoise(sourceAddition, coeffAdditions, highLevelError, manager, nullptr, hasExternalCoefficient);
   }
   else {
      if (thisMin > sourceMin)
         thisMin = sourceMin;
      if (thisMax < sourceMax)
         thisMax = sourceMax;
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      thisMin.plusAssign(thisMax, nearestParams);
      BuiltReal localHighLevelError;
      adjustComputation(thisMin, localHighLevelError);
      localHighLevelError.divAssign(2U, maxParams);
      maxParams.clear();
      thisMin.divAssign(2U, nearestParams);
      adjustComputation(thisMin, highLevelError);
      highLevelError.plusAssign(localHighLevelError, maxParams);
      maxParams.clear();
      dCentral.plusAssign(thisMin, nearestParams);
      adjustComputation(dCentral, highLevelError);
      thisMax.minusAssign(thisMin, maxParams);
      maxParams.clear();
      addNoise(thisMax, coeffAdditions, highLevelError, manager, nullptr, hasExternalCoefficient);
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::simplifyWith(
      const thisType& constraint, Symbol& constraintSymbol,
      const BuiltReal& constraintNormalization, SymbolsManager& manager, bool hasExternalCoefficient) {
   BuiltReal constraintSymbolValue, remainder, weightPositive, weightAll, matchAll;
      /* match = weightPositive * constraintSymbolValue */
   Cursor thisCursor(*this), constraintCursor(constraint);
   bool wasOnSymbol = true;
   int commonSymbolNumber = 0;
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   while (constraintCursor.setToNext()) {
      const Symbol& symbol = constraintCursor.elementAt();
      if (wasOnSymbol)
         thisCursor.setToNext();
      ComparisonResult compareSymbol = thisCursor.isValid()
         ? thisCursor.elementAt().compare(symbol) : CRGreater;
      while (compareSymbol == CRLess) {
         AssumeCondition(dynamic_cast<const Coefficient*>(&thisCursor.globalElementAt()))
         const BuiltReal& coeffValue = ((const Coefficient&) thisCursor.globalElementAt()).getValue();
         // ++basicOperationCounter;
         if (coeffValue.isPositive()) {
            matchAll.plusAssign(coeffValue, nearestParams);
            nearestParams.clear();
            remainder.plusAssign(coeffValue, nearestParams);
         }
         else {
            matchAll.minusAssign(coeffValue, nearestParams);
            nearestParams.clear();
            remainder.minusAssign(coeffValue, nearestParams);
         };
         nearestParams.clear();
         
         compareSymbol = thisCursor.setToNext()
            ? thisCursor.elementAt().compare(symbol) : CRGreater;
      };

      AssumeCondition(dynamic_cast<const Coefficient*>(&constraintCursor.globalElementAt()))
      const BuiltReal& constraintCoeffValue = ((const Coefficient&) constraintCursor.globalElementAt()).getValue();

      if ((wasOnSymbol = (compareSymbol == CREqual)) == false) { // compareSymbol == CRGreater
         if (!constraintSymbolValue.isZero()) {
            BuiltReal addRemainder = constraintSymbolValue;
            addRemainder.multAssign(constraintCoeffValue, nearestParams);
            nearestParams.clear();
            if (addRemainder.isNegative())
               addRemainder.opposite();
            remainder.plusAssign(addRemainder, nearestParams);
            nearestParams.clear();
         };
      }
      else {
         ++commonSymbolNumber;
         bool isNegligeable = false;
         {  // static const double DMinWeight = 0.05;
            BuiltReal inverseMinWeight(20U);
            inverseMinWeight.multAssign(constraintCoeffValue, nearestParams);
            nearestParams.clear();
            if (inverseMinWeight.isNegative())
               inverseMinWeight.opposite();
            isNegligeable = inverseMinWeight <= weightAll;
         };
         bool isConstraintSymbolNegligeable = false;
         if (!isNegligeable) {
            BuiltReal inverseMinWeight(20U);
            inverseMinWeight.multAssign(weightAll, nearestParams);
            nearestParams.clear();
            if (constraintCoeffValue.isPositive())
               isConstraintSymbolNegligeable = inverseMinWeight <= constraintCoeffValue;
            else {
               inverseMinWeight.opposite();
               isConstraintSymbolNegligeable = inverseMinWeight >= constraintCoeffValue;
            };
         };

         AssumeCondition(dynamic_cast<const Coefficient*>(&thisCursor.globalElementAt()))
         const BuiltReal& thisCoeffValue = ((const Coefficient&) thisCursor.globalElementAt()).getValue();

         if (isNegligeable) {
            // ++basicOperationCounter;
            BuiltReal addRemainder;
            if (!constraintSymbolValue.isZero()) {
               addRemainder = constraintSymbolValue;
               addRemainder.multAssign(constraintCoeffValue, nearestParams);
               nearestParams.clear();
            };
            addRemainder.minusAssign(thisCoeffValue, nearestParams);
            nearestParams.clear();
            if (addRemainder.isPositive())
               remainder.plusAssign(addRemainder, nearestParams);
            else
               remainder.minusAssign(addRemainder, nearestParams);
            nearestParams.clear();
         }
         else if (isConstraintSymbolNegligeable) {
            constraintSymbolValue = thisCoeffValue;
            constraintSymbolValue.divAssign(constraintCoeffValue, nearestParams);
            nearestParams.clear();
            BuiltReal addRemainder(constraintSymbolValue);
            addRemainder.multAssign(weightPositive, nearestParams);
            nearestParams.clear();
            addRemainder.minusAssign(matchAll, nearestParams);
            nearestParams.clear();
            if (addRemainder.isNegative())
               addRemainder.opposite();
            remainder = addRemainder;
            addRemainder = weightAll;
            addRemainder.minusAssign(weightPositive, nearestParams);
            nearestParams.clear();
            addRemainder.multAssign(constraintSymbolValue, nearestParams);
            nearestParams.clear();
            if (addRemainder.isNegative())
               addRemainder.opposite();
            remainder.plusAssign(addRemainder, nearestParams);
            nearestParams.clear();
            weightPositive = constraintCoeffValue;
            if (weightPositive.isNegative())
               weightPositive.opposite();
         }
         else { // !isNegligeable && !isConstraintSymbolNegligeable
            BuiltReal newConstraintSymbolCoefficient = thisCoeffValue;
            newConstraintSymbolCoefficient.divAssign(constraintCoeffValue, nearestParams);
            nearestParams.clear();

            if (constraintSymbolValue.isZero()) { // !isConstraintSymbolNegligeable => constraintSymbolValue remains to its old value
               if (thisCoeffValue.isPositive())
                  remainder.plusAssign(thisCoeffValue, nearestParams);
               else
                  remainder.minusAssign(thisCoeffValue, nearestParams);
               nearestParams.clear();
            }
            else {
               if (constraintSymbolValue.isNegative() == newConstraintSymbolCoefficient.isNegative()) {
                  if (constraintCoeffValue.isPositive())
                     weightPositive.plusAssign(constraintCoeffValue, nearestParams);
                  else
                     weightPositive.minusAssign(constraintCoeffValue, nearestParams);
                  nearestParams.clear();
                  ComparisonResult compare = constraintSymbolValue.compare(newConstraintSymbolCoefficient);
                  if (constraintSymbolValue.isPositive()
                        ? compare == CRGreater : compare == CRLess) {
                     if (!remainder.isZero()) {
                        remainder.divAssign(constraintSymbolValue, nearestParams);
                        nearestParams.clear();
                        remainder.multAssign(newConstraintSymbolCoefficient, nearestParams);
                        nearestParams.clear();
                     };
                     BuiltReal addRemainder(constraintSymbolValue);
                     addRemainder.minusAssign(newConstraintSymbolCoefficient, nearestParams);
                     nearestParams.clear();
                     addRemainder.divAssign(constraintSymbolValue, nearestParams);
                     nearestParams.clear();
                     addRemainder.multAssign(matchAll, nearestParams);
                     nearestParams.clear();
                     remainder.plusAssign(addRemainder, nearestParams);
                     nearestParams.clear();

                     // if (!match.isZero()) {
                     //    match.divAssign(constraintSymbolValue, nearestParams);
                     //    nearestParams.clear();
                     //    match.multAssign(newConstraintSymbolCoefficient, nearestParams);
                     //    nearestParams.clear();
                     // };
                     // if (thisCoeffValue.isPositive())
                     //    match.plusAssign(thisCoeffValue, nearestParams);
                     // else
                     //    match.minusAssign(thisCoeffValue, nearestParams);
                     // nearestParams.clear();
                     constraintSymbolValue = newConstraintSymbolCoefficient;
                  }
                  else {
                     BuiltReal addMatch(constraintCoeffValue);
                     addMatch.multAssign(constraintSymbolValue, nearestParams);
                     nearestParams.clear();
                     BuiltReal addRemainder(thisCoeffValue);
                     addRemainder.minusAssign(addMatch, nearestParams);
                     nearestParams.clear();
                     // if (addMatch.isPositive())
                     //    match.plusAssign(addMatch, nearestParams);
                     // else
                     //    match.minusAssign(addMatch, nearestParams);
                     // nearestParams.clear();
                     remainder.plusAssign(addRemainder, nearestParams);
                     nearestParams.clear();
                  };
               }
               else { // constraintSymbolValue and newConstraintSymbolCoefficient have different signs
                  constraintSymbolValue = BuiltReal();
                  remainder = matchAll;
                  if (thisCoeffValue.isPositive())
                     remainder.plusAssign(thisCoeffValue, nearestParams);
                  else
                     remainder.minusAssign(thisCoeffValue, nearestParams);
                  nearestParams.clear();
                  // match = BuiltReal();
                  weightPositive = BuiltReal();
               };
            };
         };

         if (thisCoeffValue.isPositive())
            matchAll.plusAssign(thisCoeffValue, nearestParams);
         else
            matchAll.minusAssign(thisCoeffValue, nearestParams);
         nearestParams.clear();
      }
      {  if (constraintCoeffValue.isPositive())
            weightAll.plusAssign(constraintCoeffValue, nearestParams);
         else
            weightAll.minusAssign(constraintCoeffValue, nearestParams);
         nearestParams.clear();
      };
   };
   if (constraintSymbolValue.isZero())
      return false;

   bool doesApplySubstitution = !constraintSymbolValue.isZero();
   if (doesApplySubstitution && !remainder.isZero()) {
      // DMinMatchPositive = 0.25
      BuiltReal match = weightPositive;
      match.multAssign(constraintSymbolValue, nearestParams);
      nearestParams.clear();
      if (match.isNegative())
         match.opposite();
      match.multAssign(BuiltReal(4U), nearestParams);
      nearestParams.clear();
      if (match < matchAll)
         doesApplySubstitution = false;

      if (doesApplySubstitution) {
         remainder.multAssign(BuiltReal(20U), nearestParams);
         nearestParams.clear();
         if (remainder >= match)
            doesApplySubstitution = false;
      };
   };

   if (doesApplySubstitution) {
      // ok, apply substitution with constraintSymbolValue if it significantly gains
      thisType thisCopy(*this);
      thisType constraintCopy(constraint);
      BuiltReal highLevelError;
      constraintCopy.multAssign(constraintSymbolValue, manager, highLevelError, hasExternalCoefficient);
      thisCopy.plusAssign(constraintCopy, PCSourceXValue, manager, highLevelError, true /* isMinus */,
            hasExternalCoefficient);
      if (!constraintNormalization.isZero()) {
         BuiltReal addHighLevelError;
         constraintSymbolValue.multAssign(constraintNormalization, nearestParams);
         adjustComputation(constraintSymbolValue, addHighLevelError);
         auto& maxParams = TypeBaseFloatAffine::maxParams();
         addHighLevelError.divAssign(2U, maxParams);
         maxParams.clear();
         constraintSymbolValue.divAssign(BuiltReal(2U), nearestParams);
         adjustComputation(constraintSymbolValue, addHighLevelError);

         highLevelError.plusAssign(addHighLevelError, maxParams);
         maxParams.clear();
         thisCopy.addCoefficient(constraintSymbolValue, constraintSymbol);
         PNT::AutoPointer<Coefficient> constraintSymbolValueAdditions;
         addAssignOptionCentral(thisCopy.dCentral, thisCopy.apcCentralAdditions,
               constraintSymbolValue, constraintSymbolValueAdditions, highLevelError,
               nearestParams, manager, hasExternalCoefficient);
      };
      thisCopy.addHighLevel(highLevelError, manager, hasExternalCoefficient);

      // does it have a significant gain of 5% ?
      BuiltReal midRange, midRangeCopy;
      retrieveMidRange(midRange, hasExternalCoefficient);
      thisCopy.retrieveMidRange(midRangeCopy, hasExternalCoefficient);
      auto& nearestParams = TypeBaseFloatAffine::nearestParams();
      midRange.minusAssign(midRangeCopy, nearestParams);
      nearestParams.clear();
      bool simplifyIfPositive = false;
      if (TypeBaseFloatAffine::hasSimplificationTriggerPercent()) {
         if (TypeBaseFloatAffine::getSimplificationTriggerPercent().isPositive()
               && !TypeBaseFloatAffine::getSimplificationTriggerPercent().isZero()) {
            midRange.multAssign(100U, nearestParams);
            nearestParams.clear();
            midRange.divAssign(TypeBaseFloatAffine::getSimplificationTriggerPercent(), nearestParams);
            nearestParams.clear();
         }
         else
            simplifyIfPositive = true;
      }
      else
         midRange.multAssign(20U, nearestParams);
      nearestParams.clear();
      if (!simplifyIfPositive ? midRange <= midRangeCopy : midRange.isNegative() || midRange.isZero())
         doesApplySubstitution = false;
      else
         swap(thisCopy);
   };
   bool result;
   if (!hasExternalCoefficient && TypeBaseFloatAffine::doesAllowSimplex()) {
      result = doesApplySubstitution || (commonSymbolNumber <= 1);
      if (!result) {
         BuiltReal match = weightPositive;
         match.multAssign(constraintSymbolValue, nearestParams);
         nearestParams.clear();
         match.multAssign(BuiltReal(20U), nearestParams);
         nearestParams.clear();
         if (match < matchAll)
            result = true;
      };
   }
   else
      result = doesApplySubstitution;
   return result;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::simplifyAllEquations(
      Symbol& symbol, bool isNegative, SymbolsManager& manager, bool hasExternalCoefficient) const {
   BuiltReal normalization = getNormalization(isNegative, nullptr, hasExternalCoefficient);
   bool result = true;
   notifyUpdate(
         [this, &symbol, &normalization, &result, &manager, hasExternalCoefficient]
         (thisType& equation)
      {  if (!equation.isDefinition())
            result = equation.simplifyWith(*this, symbol, normalization, manager, hasExternalCoefficient)
               && result;
      });
   return result;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::simplifyAllEquationsIf(
      Symbol& symbol, bool isNegative, SymbolsManager& manager,
      std::function<bool(const DefineEquation DefineEquationTemplateParameters(URealBitsNumber)&)> condition,
      bool hasExternalCoefficient) const {
   BuiltReal normalization = getNormalization(isNegative, nullptr, hasExternalCoefficient);
   bool result = true;
   notifyUpdate(
         [this, &symbol, &normalization, &result, &manager, &condition, hasExternalCoefficient]
         (thisType& equation)
      {  if (!equation.isDefinition() && condition(equation))
            result = equation.simplifyWith(*this, symbol, normalization, manager, hasExternalCoefficient)
               && result;
      });
   return result;
}

DefineEquationTemplateHeader(URealBitsNumber)
int
DefineEquation DefineEquationTemplateParameters(URealBitsNumber)::basicOperationCounter = 0;

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Vertex::addSymbolsFrom(
      const Equation& equation) {
   typename Vertex::Cursor vertexCursor(*this);
   bool wasOnSymbol = true;
   equation.foreachDo([this, &vertexCursor, &wasOnSymbol](const Symbol& symbol)
      {  if (wasOnSymbol)
            vertexCursor.setToNext();
         ComparisonResult compareSymbol = vertexCursor.isValid()
            ? vertexCursor.elementAt().getSymbol().compare(symbol) : CRGreater;
         while (compareSymbol == CRLess)
            compareSymbol = vertexCursor.setToNext()
               ? vertexCursor.elementAt().getSymbol().compare(symbol) : CRGreater;
         if ((wasOnSymbol = (compareSymbol == CREqual)) == false) // compareSymbol = CRGreater
            inherited::add(new ValueForSymbol(symbol),
               COL::VirtualCollection::ExtendedInsertionParameters()
                  .setFreeOnError().setBefore().setRemote(), &vertexCursor);
         return true;
      });
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::BaseEquation
   ::BaseEquation(const Symbol& symbol, const Equation& equation, bool isNegative)
   :  dConstant(equation.getCentral()), dNormalization(equation.getCentral()),
      fNegative(isNegative), psSymbol(&symbol) {
   if (isNegative)
      dNormalization.opposite();
   typename Equation::Cursor cursor(equation);
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   while (cursor.setToNext()) {
      AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
      const BuiltReal& coefficient = ((const typename Equation::Coefficient&)
            cursor.globalElementAt()).getValue();
      BaseTerm* term = new BaseTerm(cursor.elementAt(), coefficient);
      sabmEquation.insertNewAtEnd(term);
      if (coefficient.isPositive())
         dNormalization.plusAssign(coefficient, maxParams);
      else
         dNormalization.minusAssign(coefficient, maxParams);
      maxParams.clear();
   };
   dNormalization.divAssign(2U, maxParams);
   maxParams.clear();
   if (dNormalization.isZero() && dNormalization.isNegative())
      dNormalization.opposite();
   AssumeCondition(dNormalization.isPositive())
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::BaseEquation
      ::write(STG::IOObject::OSBase& out, const WriteParameters& params) const {
   if (psSymbol) {
      dNormalization.write(out, params);
      out.writesome("*(");
      // out.writesome(Equation::getSymbolPrefix(psSymbol->getType()));
      out.writesome(psSymbol->getOwnPrefix());
      out.write(psSymbol->getOrder(), false /* isRaw */);
      if (fNegative)
         out.writesome(" - 1.0) = ");
      else
         out.writesome(" + 1.0) = ");
   };
   dConstant.write(out, params);
   sabmEquation.foreachDo([&out, &params](const BaseTerm& term)
      {  out.writesome(" + ");
         term.getCoefficient().write(out, params);
         out.put('*');
         const Symbol& symbol = term.getSymbol();
         // out.writesome(Equation::getSymbolPrefix(symbol.getType()));
         out.writesome(symbol.getOwnPrefix());
         out.write(symbol.getOrder(), false /* isRaw */);
         return true;
      });
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineBuiltReal DefineSingleTemplateParameters(URealBitsNumber)
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::BaseEquation
      ::computeNormalization() const {
   BuiltReal normalization = dConstant;
   if (fNegative)
      normalization.opposite();
   typename COL::SortedArray<BaseTerm, typename BaseTerm::Key>::Cursor cursor(sabmEquation);
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   while (cursor.setToNext()) {
      const BuiltReal& coefficient = cursor.elementAt().getCoefficient();
      if (coefficient.isPositive())
         normalization.plusAssign(coefficient, maxParams);
      else
         normalization.minusAssign(coefficient, maxParams);
      maxParams.clear();
   };
   normalization.divAssign(2U, maxParams);
   maxParams.clear();
   if (normalization.isZero() && normalization.isNegative())
      normalization.opposite();
   AssumeCondition(normalization.isPositive())
   return normalization;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::BaseEquation
   ::isAdmissibleDirection(const Symbol& symbol, bool doesIncrementSymbol,
      const BuiltReal& initialSymbolValue, const BuiltReal& constraintResult,
      BuiltReal& vertexDiffSymbol, int currentIndex, int& foundIndex, const int& degeneratedIndex,
      bool isInitialOut) const {
   typename COL::SortedArray<BaseTerm, typename BaseTerm::Key>::Cursor locateCursor(sabmEquation);
   if (sabmEquation.locateKey(symbol, locateCursor)) {
      const BaseTerm& term = locateCursor.elementAt();
      const BuiltReal& coefficient = term.getCoefficient();
      bool isDiffPositive = isInitialOut != (coefficient.isPositive() == doesIncrementSymbol);
      auto& minParams = isDiffPositive ? TypeBaseFloatAffine::minParams() : TypeBaseFloatAffine::maxParams();
      auto& maxParams = doesIncrementSymbol ? TypeBaseFloatAffine::maxParams() : TypeBaseFloatAffine::minParams();
      BuiltReal newDiff;
      if (isDiffPositive == fNegative) {
         // fNegative = isInitialOut != (coefficient.isPositive() == doesIncrementSymbol)
         if (degeneratedIndex >= 0 && constraintResult.isZero()) {
            if (currentIndex < degeneratedIndex) {
               if (foundIndex < 0) {
                  foundIndex = currentIndex;
                  vertexDiffSymbol.clear();
               };
            };
            // AssumeCondition(vertexDiffSymbol.isZero())
            if (!vertexDiffSymbol.isZero())
               return false;
            return true;
         }
         else if (constraintResult.isZero() || (constraintResult.isNegative() != fNegative) != isInitialOut)
            return false;
         AssumeCondition(!isInitialOut == (constraintResult.isNegative() == fNegative))
         // remainder + initialSymbolValue*coefficient = constraintResult
         // remainder + newSymbolValue*coefficient = 0;
         // => (initialSymbolValue-newSymbolValue)*coefficient = constraintResult
         //    isDiffPositive  => 1 >= newSymbolValue >= initialSymbolValue
         //    !isDiffPositive => -1 <= newSymbolValue <= initialSymbolValue
         newDiff = constraintResult;
         // newDiff.isPositive() = fNegative == isInitialOut
         newDiff.divAssign(coefficient, minParams);
         // newDiff.isPositive() = (fNegative == isInitialOut) == coefficient.isPositive()
         minParams.clear();
         BuiltReal newSymbolValue(initialSymbolValue);
         newSymbolValue.minusAssign(newDiff, maxParams);
         maxParams.clear();
         newDiff.opposite();
         if (doesIncrementSymbol ? (newSymbolValue > BuiltReal(1U))
                                 : (newSymbolValue < BuiltReal(1U).opposite())) {
            newDiff = 1U; // initialSymbolValue + newDiff = newSymbolValue (+/-1)
            if (!doesIncrementSymbol)
               newDiff.opposite();
            newDiff.minusAssign(initialSymbolValue, maxParams);
            maxParams.clear();
         };
      }
      else {
         // fNegative  => (symbol-1)*dNormalization = dConstant + sum_i alpha_i epsilon_i <= 0
         // !fNegative => (symbol+1)*dNormalization = dConstant + sum_i alpha_i epsilon_i >= 0
         newDiff = dNormalization;
         newDiff.multAssign(2U, minParams);
         minParams.clear();
         if (!fNegative)
            newDiff.opposite();
         newDiff.plusAssign(constraintResult, minParams);
         minParams.clear();
         newDiff.divAssign(coefficient, minParams);
         minParams.clear();
         BuiltReal newSymbolValue(initialSymbolValue);
         newSymbolValue.minusAssign(newDiff, maxParams);
         maxParams.clear();
         newDiff.opposite();
         if (doesIncrementSymbol ? (newSymbolValue > BuiltReal(1U))
                                 : (newSymbolValue < BuiltReal(1U).opposite())) {
            newDiff = 1U; // initialSymbolValue + newDiff = newSymbolValue (+/-1)
            if (!doesIncrementSymbol)
               newDiff.opposite();
            newDiff.minusAssign(initialSymbolValue, maxParams);
            maxParams.clear();
         };
         // newDiff = 1U;
         // if (!doesIncrementSymbol)
         //    newDiff.opposite();
         // newDiff.minusAssign(initialSymbolValue, maxParams);
         // maxParams.clear();
      };
      if (newDiff.isZero())
         return false;
      // if (isDiffPositive ? newDiff.isNegative() : newDiff.isPositive()) // should not occur
      //    return false;
      if (newDiff.isPositive() ? (vertexDiffSymbol > newDiff) : (vertexDiffSymbol < newDiff)) {
         vertexDiffSymbol = newDiff;
         foundIndex = currentIndex;
      }
      return true;
   };
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineBuiltReal DefineSingleTemplateParameters(URealBitsNumber)
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::queryVertexResult(
      const Equation& equation, const Vertex& vertex, bool isNegative) const {
   BuiltReal result = equation.getCentral();
   typename Vertex::Cursor vertexCursor(vertex);
   typename Equation::Cursor cursor(equation);
   vertexCursor.setToFirst();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   auto& minParams = TypeBaseFloatAffine::minParams();
   while (cursor.setToNext()) {
      AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
      const auto& coefficient = (const typename Equation::Coefficient&) cursor.globalElementAt();
      const BuiltReal& coefficientValue = coefficient.getValue();
      const Symbol& symbol = cursor.elementAt();
      ComparisonResult compareSymbols = vertexCursor.elementAt().getSymbol().compare(symbol);
      while (compareSymbols == CRLess) {
         vertexCursor.setToNext();
         compareSymbols = vertexCursor.elementAt().getSymbol().compare(symbol);
      };
      AssumeCondition(compareSymbols == CREqual)
      BuiltReal coeff = vertexCursor.elementAt().getSymbolValue();
      coeff.multAssign(coefficientValue, isNegative ? maxParams : minParams);
      (isNegative ? maxParams : minParams).clear();
      result.plusAssign(coeff, isNegative ? maxParams : minParams);
      (isNegative ? maxParams : minParams).clear();
      vertexCursor.setToNext();
   };
   return result;
}

DefineEquationTemplateHeader(URealBitsNumber)
DefineBuiltReal DefineSingleTemplateParameters(URealBitsNumber)
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::getResultFor(
      const Vertex& vertex) const {
   BuiltReal result(dObjectiveConstant);
   typename COL::SortedArray<BaseTerm, typename BaseTerm::Key>::Cursor objectiveCursor(sabmObjective);
   typename COL::SortedArray<ValueForSymbol, typename ValueForSymbol::Key>::Cursor vertexCursor(vertex);
   bool isVertexCursorAfter = false, isVertexCursorAtEnd = false;
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   while (!isVertexCursorAtEnd && objectiveCursor.setToNext()) {
      const BaseTerm& objectiveTerm = objectiveCursor.elementAt();
      if (!isVertexCursorAfter && !vertexCursor.setToNext()) {
         isVertexCursorAtEnd = true;
         break;
      };
      const ValueForSymbol* vertexAssignment = &vertexCursor.elementAt();
      ComparisonResult compareResult = vertexAssignment->getSymbol().compare(
            objectiveTerm.getSymbol());
      while (!isVertexCursorAtEnd && compareResult == CRLess) {
         if (!vertexCursor.setToNext())
            isVertexCursorAtEnd = true;
         else {
            vertexAssignment = &vertexCursor.elementAt();
            compareResult = objectiveTerm.getSymbol().compare(
               vertexAssignment->getSymbol());
         };
      };
      if (isVertexCursorAtEnd)
         break;
      if (compareResult == CREqual) {
         isVertexCursorAfter = false;
         BuiltReal term = objectiveTerm.getCoefficient();
         term.multAssign(vertexAssignment->getSymbolValue(), maxParams);
         maxParams.clear();
         result.plusAssign(term, maxParams);
         maxParams.clear();
      }
      else { // compareResult == CRGreater
         isVertexCursorAfter = true;
         if (objectiveTerm.getCoefficient().isPositive())
            result.plusAssign(objectiveTerm.getCoefficient(), maxParams);
         else
            result.minusAssign(objectiveTerm.getCoefficient(), maxParams);
         maxParams.clear();
      };
   };
   if (isVertexCursorAtEnd) {
      while (objectiveCursor.setToNext()) {
         const BaseTerm& objectiveTerm = objectiveCursor.elementAt();
         if (objectiveTerm.getCoefficient().isPositive())
            result.plusAssign(objectiveTerm.getCoefficient(), maxParams);
         else
            result.minusAssign(objectiveTerm.getCoefficient(), maxParams);
         maxParams.clear();
      };
   };
   return result;
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::updateObjectiveFromPivot(
      Cursor& cursor, const BuiltReal& newNormalization, const BaseEquation& oldEquation,
      const Symbol& exitingSymbol, bool isNegativeObjective) {
   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   auto& params = isNegativeObjective ? maxParams : minParams;
   BuiltReal multCoeff(cursor.elementAt().getCoefficient());
   sabmObjective.freeAt(cursor);
   multCoeff.divAssign(newNormalization, multCoeff.isPositive() ? maxParams : minParams);
   (multCoeff.isPositive() ? maxParams : minParams).clear();
   BuiltReal add = oldEquation.getConstant();
   add.multAssign(multCoeff, params);
   params.clear();
   dObjectiveConstant.plusAssign(add, params);
   params.clear();
   typename COL::SortedArray<BaseTerm, typename BaseTerm::Key>::Cursor
         objectiveCursor(sabmObjective), substituteCursor(oldEquation.getLinearPart());
   BaseTerm* objectiveTerm = objectiveCursor.setToFirst() ? &objectiveCursor.elementSAt() : nullptr;
   while (substituteCursor.setToNext()) {
      const BaseTerm& substituteTerm = substituteCursor.elementAt();
      while (objectiveTerm && objectiveTerm->getSymbol() < substituteTerm.getSymbol())
         objectiveTerm = objectiveCursor.setToNext() ? &objectiveCursor.elementSAt() : nullptr;
      add = substituteTerm.getCoefficient();
      add.multAssign(multCoeff, params);
      params.clear();
      if (objectiveTerm && objectiveTerm->getSymbol() == substituteTerm.getSymbol()) {
         objectiveTerm->getSCoefficient().plusAssign(add, params);
         params.clear();
      }
      else
         sabmObjective.insertNewAt(objectiveCursor, new BaseTerm(substituteTerm.getSymbol(), add),
               COL::VirtualCollection::RPBefore);
      if (&substituteTerm.getSymbol() == &exitingSymbol)
         cursor = objectiveCursor;
      objectiveTerm = objectiveCursor.setToNext() ? &objectiveCursor.elementSAt() : nullptr;
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::updateBaseEquationsFromPivot(
      const Symbol& enteringSymbol, const BuiltReal& newNormalization,
      const BaseEquation& oldEquation) {
   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   const auto& services = (const inherited&) *this;
   sabeBaseEquations.foreachSDo(
         [&enteringSymbol, &oldEquation, &newNormalization, &minParams, &maxParams, &nearestParams,
          &services]
         (BaseEquation& equation)
      {  typename COL::SortedArray<BaseTerm, typename BaseTerm::Key>::Cursor locateEnteringCursor(equation.getLinearPart());
         if (equation.getLinearPart().locateKey(enteringSymbol, locateEnteringCursor, COL::VirtualCollection::RPExact)) {
            BuiltReal multCoeff(locateEnteringCursor.elementAt().getCoefficient());
            equation.getSLinearPart().freeAt(locateEnteringCursor);
            multCoeff.divAssign(newNormalization, multCoeff.isPositive() ? maxParams : minParams);
            (multCoeff.isPositive() ? maxParams : minParams).clear();
            
            auto& params = equation.isNegative() ? maxParams : minParams;
            BuiltReal add = oldEquation.getConstant();
            add.multAssign(multCoeff, params);
            params.clear();
            equation.getSConstant().plusAssign(add, params);
            params.clear();

            typename COL::SortedArray<BaseTerm, typename BaseTerm::Key>::Cursor
               substituteCursor(oldEquation.getLinearPart()),
               equationCursor(equation.getLinearPart());
            if (substituteCursor.setToFirst()) {
               bool wasOnSymbol = true;
               do {
                  const Symbol& symbol = substituteCursor.elementAt().getSymbol();
                  add = substituteCursor.elementAt().getCoefficient();
                  BuiltReal error;
                  add.multAssign(multCoeff, nearestParams);
                  services.adjustComputation(add, error);

                  if (wasOnSymbol)
                     equationCursor.setToNext();
                  ComparisonResult compareSymbol = equationCursor.isValid()
                     ? equationCursor.elementAt().getSymbol().compare(symbol) : CRGreater;
                  while (compareSymbol == CRLess)
                     compareSymbol = equationCursor.setToNext()
                        ? equationCursor.elementAt().getSymbol().compare(symbol) : CRGreater;
                  if ((wasOnSymbol = (compareSymbol == CREqual)) == false)
                     equation.getSLinearPart().add(new BaseTerm(symbol, add),
                        COL::VirtualCollection::ExtendedInsertionParameters()
                           .setFreeOnError().setBefore().setRemote(),
                        &equationCursor);
                  else {
                     BuiltReal& coefficient = equationCursor.elementSAt().getSCoefficient();
                     coefficient.plusAssign(add, nearestParams);
                     services.adjustComputation(coefficient, error);
                  };
                  if (!error.isZero()) {
                     if (equation.isNegative())
                        equation.getSConstant().plusAssign(error, params);
                     else
                        equation.getSConstant().minusAssign(error, params);
                     params.clear();
                  };
               } while (substituteCursor.setToNext());
            };
         };
         return true;
      });
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::performPivot(
      Cursor& cursor, int foundPivot, Vertex& direction, bool doesDecreaseEntering,
      bool isNegativeObjective) {
   // replace cursor.elementAt().getSymbol() by symbol in foundPivot;
   const Symbol& enteringSymbol = cursor.elementAt().getSymbol();
   typename COL::SortedArray<BaseEquation, typename BaseEquation::Key>::Cursor constraintCursor(sabeBaseEquations);
   constraintCursor.setSureIndex(foundPivot);
   PNT::AutoPointer<BaseEquation> oldEquation(
         &sabeBaseEquations.extractElementAt(constraintCursor),
         PNT::Pointer::Init());
   // example: oldEquation = -2 + 2.5*e_1 + e_3 - 0.5*e_4 = (e_c-1)*3 <= 0
   // example: oldEquation = +2 - 2.5*e_1 + e_3 - 0.5*e_4 = (e_c-1)*1 <= 0
   // example: oldEquation = +2 - 2.5*e_1 + e_3 - 0.5*e_4 = (e_c+1)*3 >= 0
   const Symbol& exitingSymbol = oldEquation->getSymbol();
   typename COL::SortedArray<BaseTerm, typename BaseTerm::Key>::Cursor locateEnteringCursor(oldEquation->getLinearPart());
   oldEquation->getLinearPart().locateKey(enteringSymbol, locateEnteringCursor);
   // oldEquation->getNormalization() = oldNormalization = 3
   // oldEquation->getNormalization() = oldNormalization = 1
   // oldEquation->getNormalization() = oldNormalization = 3
   PNT::AutoPointer<BaseTerm> oldTerm(&oldEquation->getSLinearPart().extractElementAt(locateEnteringCursor), PNT::Pointer::Init());
   // oldEquation = -2 + e_3 - 0.5*e_4 = (e_c-1)*3 - 2.5*e_1 <= -2.5*e_1 
   // oldEquation = +2 + e_3 - 0.5*e_4 = (e_c-1)*1 + 2.5*e_1 <= +2.5*e_1 
   // oldEquation = +2 + e_3 - 0.5*e_4 = (e_c+1)*3 + 2.5*e_1 >= +2.5*e_1 
   BaseTerm* newTerm = new BaseTerm(exitingSymbol, oldEquation->getNormalization());
   oldEquation->getSLinearPart().addNew(newTerm);
   newTerm->getSCoefficient().opposite();
   // oldEquation = -2 + e_3 - 0.5*e_4 - 3*e_c = -3 - 2.5*e_1 <= -3*e_c-2.5*e_1 
   // oldEquation = +2 + e_3 - 0.5*e_4 - 1*e_c = -1 + 2.5*e_1 <= -1*e_c+2.5*e_1 
   // oldEquation = +2 + e_3 - 0.5*e_4 - 3*e_c = +3 + 2.5*e_1 >= -3*e_c+2.5*e_1 
   BuiltReal& newNormalization = oldTerm->getSCoefficient();
   // newNormalization = 2.5
   // newNormalization = -2.5
   // newNormalization = -2.5
   bool hasChangedSign = newNormalization.isPositive();
   if (hasChangedSign) {
      oldEquation->getSNormalization().opposite();
      oldEquation->changeSign();
      oldEquation->getSConstant().opposite();
      oldEquation->getSLinearPart().foreachSDo([](BaseTerm& term)
         {  term.getSCoefficient().opposite(); return true; });
   }
   else
      newNormalization.opposite();
   // oldEquation = +2 - e_3 + 0.5*e_4 + 3*e_c = +3 + 2.5*e_1 >= -3*e_c-2.5*e_1 
   // oldEquation = +2 + e_3 - 0.5*e_4 - 1*e_c = -1 + 2.5*e_1 <= -1*e_c+2.5*e_1 
   // oldEquation = +2 + e_3 - 0.5*e_4 - 3*e_c = +3 + 2.5*e_1 >= -3*e_c+2.5*e_1 
   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   // oldEquation->isNegative() ? (symbol-1)*dNormalization = dConstant + sum_i alpha_i epsilon_i
   //                           : (symbol+1)*dNormalization = dConstant + sum_i alpha_i epsilon_i
   if (hasChangedSign != oldEquation->isNegative()) {
      oldEquation->getSConstant().plusAssign(oldEquation->getNormalization(), minParams);
      minParams.clear();
   }
   else {
      oldEquation->getSConstant().minusAssign(oldEquation->getNormalization(), maxParams);
      maxParams.clear();
   }
   // oldEquation = -1 - e_3 + 0.5*e_4 + 3*e_c = +2.5*e_1 >= +3*(e_c-1)+2.5*e_1 
   // oldEquation = +3 + e_3 - 0.5*e_4 - 1*e_c = +2.5*e_1 <= -1*(e_c-1)+2.5*e_1 
   // oldEquation = -1 + e_3 - 0.5*e_4 - 3*e_c = +2.5*e_1 >= -3*(e_c+1)+2.5*e_1 
   // newNormalization = 2.5
   // newNormalization = 2.5
   // newNormalization = 2.5

   updateObjectiveFromPivot(cursor, newNormalization, *oldEquation, exitingSymbol, isNegativeObjective);
   updateBaseEquationsFromPivot(enteringSymbol, newNormalization, *oldEquation);

   // oldEquation = -1 - e_3 + 0.5*e_4 + 3*e_c = +2.5*e_1 >= +3*(e_c-1)+2.5*e_1 
   // oldEquation = +3 + e_3 - 0.5*e_4 - 1*e_c = +2.5*e_1 <= -1*(e_c-1)+2.5*e_1 
   // oldEquation = -1 + e_3 - 0.5*e_4 - 3*e_c = +2.5*e_1 >= -3*(e_c+1)+2.5*e_1 
   // newNormalization = 2.5
   // newNormalization = 2.5
   // newNormalization = 2.5
   if (oldEquation->isNegative()) {
      // (symbol-1)*dNormalization = dConstant + sum_i alpha_i epsilon_i
      oldEquation->getSConstant().minusAssign(newNormalization, minParams);
      minParams.clear();
      // oldEquation = +0.5 + e_3 - 0.5*e_4 - 1*e_c = +2.5*(e_1-1) <= -1*(e_c-1)+2.5*(e_1-1) 
   }
   else {
      // (symbol+1)*dNormalization = dConstant + sum_i alpha_i epsilon_i
      oldEquation->getSConstant().plusAssign(newNormalization, maxParams);
      maxParams.clear();
      // oldEquation = +1.5 - e_3 + 0.5*e_4 + 3*e_c = 2.5*(e_1+1) >= +3*(e_c-1)+2.5*(e_1+1)
      // oldEquation = +1.5 + e_3 - 0.5*e_4 - 3*e_c = 2.5*(e_1+1) >= -3*(e_c+1)+2.5*(e_1+1) 
   };
   oldEquation->changeSymbol(enteringSymbol);
   oldEquation->getSNormalization() = newNormalization; // oldEquation->computeNormalization()

   typename Vertex::Cursor directionCursor(direction);
   direction.locateKey(enteringSymbol, directionCursor);
   direction.freeAt(directionCursor);
   ValueForSymbol* newValue = new ValueForSymbol(exitingSymbol);
   direction.addNew(newValue);
   newValue->symbolValue() = BuiltReal(1U); // getConstraintResult(pivot) ?
   if (doesDecreaseEntering != newTerm->getCoefficient().isNegative() /* oldEquation->isNegative() == hasChangedSign */)
      newValue->symbolValue().opposite();

   // update constraintResult in direction
   direction.removeConstraintResult(foundPivot);
   BuiltReal constraintResult = oldEquation->getConstant();
   bool isNegativeConstraint = oldEquation->isNegative();
   directionCursor.setToFirst();
   oldEquation->getLinearPart().foreachDo(
         [&constraintResult, &directionCursor, isNegativeConstraint, &maxParams, &minParams]
         (const BaseTerm& term)
      {  const Symbol& symbol = term.getSymbol();
         ComparisonResult compareSymbols = directionCursor.elementAt().getSymbol().compare(symbol);
         while (compareSymbols == CRLess) {
            directionCursor.setToNext();
            compareSymbols = directionCursor.elementAt().getSymbol().compare(symbol);
         };
         AssumeCondition(compareSymbols == CREqual)
         BuiltReal coeff = directionCursor.elementAt().getSymbolValue();
         coeff.multAssign(term.getCoefficient(), isNegativeConstraint ? minParams : maxParams);
         (isNegativeConstraint ? minParams : maxParams).clear();
         constraintResult.plusAssign(coeff, isNegativeConstraint ? minParams : maxParams);
         (isNegativeConstraint ? minParams : maxParams).clear();
         directionCursor.setToNext();
         return true;
      });
   if (isNegativeConstraint ? constraintResult > 0 : constraintResult < 0)
      constraintResult.clear(); // should be near 0 !!

   typename COL::SortedArray<BaseEquation, typename BaseEquation::Key>::Cursor newIndexCursor(sabeBaseEquations);
   sabeBaseEquations.addNew(oldEquation.extractElement(), newIndexCursor);
   direction.addConstraintResult(newIndexCursor.getIndex(), constraintResult);
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::Solver::transferVertex(
      const Vertex& origin, Vertex& result, const BuiltReal& constraintResult) {
   result.setConstraintResult(constraintResult);
   typename Vertex::Cursor resultCursor(result), originCursor(origin);
   bool wasOnSymbol = true;
   if (resultCursor.setToFirst()) {
      const Symbol* symbol = &resultCursor.elementAt().getSymbol();
      do {
         if (wasOnSymbol)
            originCursor.setToNext();
         ComparisonResult compareSymbol = originCursor.isValid()
            ? originCursor.elementAt().getSymbol().compare(*symbol) : CRGreater;
         while (compareSymbol == CRLess)
            compareSymbol = originCursor.setToNext()
               ? originCursor.elementAt().getSymbol().compare(*symbol) : CRGreater;
         if ((wasOnSymbol = (compareSymbol == CREqual)) == false) {
            typename decltype(sabeBaseEquations)::Cursor locateBaseEquationCursor(sabeBaseEquations);
            sabeBaseEquations.locateKey(*symbol, locateBaseEquationCursor, COL::VirtualCollection::RPExact);
            const BaseEquation& baseEquation = locateBaseEquationCursor.elementAt();
            BuiltReal resultValue = baseEquation.getConstant();
            typename Vertex::Cursor searchOriginCursor(origin);
            baseEquation.getLinearPart().foreachDo(
                  [&resultValue, &searchOriginCursor, &baseEquation](const BaseTerm& term)
               {  while (searchOriginCursor.setToNext()
                        && &searchOriginCursor.elementAt().getSymbol() != &term.getSymbol()) {};
                  BuiltReal addResult = searchOriginCursor.elementAt().getSymbolValue();
                  typename BuiltReal::ReadParameters* minParams;
                  if (baseEquation.isNegative()) // minimize the evaluation
                     minParams = searchOriginCursor.elementAt().isPositive() == term.getCoefficient().isPositive()
                        ? &TypeBaseFloatAffine::minParams() : &TypeBaseFloatAffine::maxParams();
                  else // maximize the evaluation
                     minParams = searchOriginCursor.elementAt().isNegative() == term.getCoefficient().isPositive()
                        ? &TypeBaseFloatAffine::minParams() : &TypeBaseFloatAffine::maxParams();
                  addResult.multAssign(term.getCoefficient(), *minParams);
                  minParams->clear();
                  resultValue.plusAssign(addResult, *minParams);
                  minParams->clear();
                  return true;
               });
            if (baseEquation.isNegative()) {
               auto& minParams = TypeBaseFloatAffine::minParams();
               resultValue.plusAssign(baseEquation.getNormalization(), minParams);
               minParams.clear();
               resultValue.divAssign(baseEquation.getNormalization(), minParams);
               minParams.clear();
            }
            else {
               auto& maxParams = TypeBaseFloatAffine::maxParams();
               resultValue.minusAssign(baseEquation.getNormalization(), maxParams);
               maxParams.clear();
               resultValue.divAssign(baseEquation.getNormalization(), maxParams);
               maxParams.clear();
               resultCursor.elementSAt().changeDirection();
            }
            resultCursor.elementSAt().symbolValue() = resultValue;
         }
         else {
            const ValueForSymbol& originValueForSymbol = originCursor.elementSAt();
            ValueForSymbol& resultValueForSymbol = resultCursor.elementSAt();
            resultValueForSymbol.symbolValue() = originValueForSymbol.getSymbolValue();
            if (resultValueForSymbol.isNegative() != originValueForSymbol.isNegative())
               resultValueForSymbol.changeDirection();
         };
         symbol = resultCursor.setToNext() ? &resultCursor.elementAt().getSymbol() : nullptr;
      } while (symbol != nullptr);
   }
}

// Return an optimistic result
//   if the evaluation may be positive, then it returns true
DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::isPositiveEquation(
      const Equation& equation, const Vertex& vertex, bool isPositiveDirection,
      BuiltReal& equationResult) {
   typename Equation::Cursor cursor(equation);
   typename Vertex::Cursor vertexCursor(vertex);
   equationResult = equation.getCentral();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   auto& minParams = TypeBaseFloatAffine::minParams();
   while (cursor.setToNext()) {
      const Symbol& symbol = cursor.elementAt();
      while (vertexCursor.setToNext()) {
         if (&vertexCursor.elementAt().getSymbol() == &symbol)
            break;
      };
      BuiltReal local = ((typename Equation::Coefficient&) cursor.globalElementAt()).getValue();
      const BuiltReal& localValue = vertexCursor.elementAt().getSymbolValue();
      if (isPositiveDirection) {
         local.multAssign(localValue, maxParams);
         maxParams.clear();
         equationResult.plusAssign(local, maxParams);
         maxParams.clear();
      }
      else {
         local.multAssign(localValue, minParams);
         minParams.clear();
         equationResult.plusAssign(local, minParams);
         minParams.clear();
      }
   };
   return (isPositiveDirection ? equationResult.isPositive() : equationResult.isNegative())
         || equationResult.isZero();
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::close(bool hasAdmissibleVertex) {
   if (!hasAdmissibleVertex && mpParent.isValid()) {
      AssumeCondition(dynamic_cast<const thisType*>(&*mpParent))
      vAdmissibleVertex = ((const thisType&) *mpParent).vAdmissibleVertex;
   };
   vAdmissibleVertex.addSymbolsFrom(eEquation);
   BuiltReal equationResult;
   if (!isPositiveEquation(eEquation, vAdmissibleVertex, !fNegative, equationResult)) {
      Vertex direction(vAdmissibleVertex, typename Vertex::SolverInit());
      Solver solver(eEquation, !fNegative);
      if (mpParent.isValid()) {
         auto parent = (const PNT::TMngPointer<thisType>&) mpParent;
         do {
            solver.addBase(*parent);
            direction.setConstraintResult(solver.queryVertexResult(parent->eEquation, direction, fNegative));
            parent = (const PNT::TMngPointer<thisType>&) parent->mpParent;
         } while (parent.isValid());
      };

      auto& maxParams = TypeBaseFloatAffine::maxParams();
      auto& minParams = TypeBaseFloatAffine::minParams();
      int degeneratedIndex = -1;
      do {
         typename Vertex::Cursor vertexCursor(direction);
         typename Solver::Cursor cursor(solver);
         bool hasCompleteCycle = true;
         while (cursor.setToNext()) {
            const typename Solver::BaseTerm& term = cursor.elementAt();
            const Symbol& symbol = term.getSymbol();
            while (vertexCursor.setToNext()) { // synchronization
               if (&vertexCursor.elementAt().getSymbol() == &symbol)
                  break;
            };
            const BuiltReal& currentCoefficient = term.getCoefficient();
            if (!currentCoefficient.isZero()
                  && currentCoefficient.isNegative() == vertexCursor.elementAt().isNegative()) {
               BuiltReal initialVertexSymbol(vertexCursor.elementAt().getSymbolValue()),
                         vertexDiffSymbol(+1U);
               bool doesInverse = vertexCursor.elementAt().isNegative();
               if (doesInverse)
                  vertexDiffSymbol.opposite();
               vertexDiffSymbol.minusAssign(initialVertexSymbol, doesInverse ? minParams : maxParams);
               (doesInverse ? minParams : maxParams).clear();
               int foundPivot = -1;
               if (solver.isAdmissibleDirection(symbol,
                     currentCoefficient.isNegative() != fNegative,
                     vertexCursor.elementAt().getSymbolValue(), direction, vertexDiffSymbol,
                     foundPivot, degeneratedIndex, false /* isInitialOut */)) { // pivot
                  BuiltReal& symbolValue = vertexCursor.elementSAt().symbolValue();
                  symbolValue.plusAssign(vertexDiffSymbol, minParams);
                  bool doesDecreaseEntering = vertexDiffSymbol.isNegative();
                  vertexCursor.elementSAt().changeDirection();
                  minParams.clear();
                  BuiltReal temp(1U);
                  temp.opposite();
                  if (symbolValue < temp) {
                     BuiltReal newValue = temp;
                     temp.minusAssign(symbolValue, minParams);
                     symbolValue = newValue;
                     minParams.clear();
                     vertexDiffSymbol.plusAssign(temp, maxParams);
                     maxParams.clear();
                  };
                  solver.updateConstraintResult(direction, symbol, vertexDiffSymbol);
                  vertexDiffSymbol.multAssign(currentCoefficient, minParams);
                  minParams.clear();
                  AssumeCondition(vertexDiffSymbol.isPositive() || vertexDiffSymbol.isZero())
                  if (fNegative) { // currentCoefficient is inversed w.r.t equation coefficient
                     equationResult.minusAssign(vertexDiffSymbol, maxParams);
                     maxParams.clear();
                  }
                  else {
                     equationResult.plusAssign(vertexDiffSymbol, minParams);
                     minParams.clear();
                  };
                  if (degeneratedIndex >= 0 && !vertexDiffSymbol.isZero())
                     degeneratedIndex = -1;
                  if (foundPivot >= 0) {
                     solver.performPivot(cursor, foundPivot, direction, doesDecreaseEntering, fNegative);
                     if (degeneratedIndex >= 0)
                        degeneratedIndex = foundPivot;
                  };
                  hasCompleteCycle = false;
                  break;
               }
            };
         };
         if (!cursor.isValid()) {
            if (!hasCompleteCycle) {
               hasCompleteCycle = true;
               continue;
            }
            else { // try degenerated cases
               if (degeneratedIndex < 0 && solver.countBases() > 0)
                  degeneratedIndex = solver.countBases()-1;
               else
                  return false;
            };
         };
      } while (!equationResult.isZero() && equationResult.isNegative() != fNegative);
      solver.transferVertex(direction, vAdmissibleVertex, equationResult);
      if (mpParent.isValid()) {
         BuiltReal constraintResult;
         auto parent = (const PNT::TMngPointer<thisType>&) mpParent;
         int constraintIndex = 0;
         do {
            constraintResult.clear();
            bool isPositive = isPositiveEquation(parent->eEquation, vAdmissibleVertex,
                  !parent->fNegative, constraintResult);
            if (!isPositive) { // near 0, but evaluation is pessimistic
               if (!improveResult(parent->eEquation, vAdmissibleVertex,
                     !parent->fNegative, constraintResult, (const thisType*) mpParent.key(), parent.key()))
                  return false;
            };
            vAdmissibleVertex.changeConstraintResult(constraintIndex, constraintResult);
            ++constraintIndex;
            parent = (const PNT::TMngPointer<thisType>&) parent->mpParent;
         } while (parent.isValid());
         if (!isPositiveEquation(eEquation, vAdmissibleVertex, !fNegative, constraintResult)) {
            if (!improveResult(eEquation, vAdmissibleVertex,
                  !fNegative, constraintResult, (const thisType*) mpParent.key(), nullptr))
               return false;
         };
      };
   }
   else
      vAdmissibleVertex.setConstraintResult(equationResult);
   return true;
}

DefineEquationTemplateHeader(URealBitsNumber)
class DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::CandidatesForImprovement {
  public:
   class Candidate : public EnhancedObject {
     private:
      const Symbol* psSymbol;
      BuiltReal dCurrentValue;
      BuiltReal dDiffValue;
      bool fInactive;
      Candidate* pcInactiveParent;

     public:
      Candidate(const Symbol& symbol, const BuiltReal& currentValue, const BuiltReal& diffValue)
         :  psSymbol(&symbol), dCurrentValue(currentValue), dDiffValue(diffValue),
            fInactive(false), pcInactiveParent(nullptr) {}
      Candidate(const Candidate& source) = default;
      Candidate& operator=(const Candidate& source) = default;
      DefineCopy(Candidate)
      DDefineAssign(Candidate)

      bool isActive() const { return !fInactive; }
      void setInactive() { fInactive = true; }
      const Symbol& getSymbol() const { return *psSymbol; }
      const BuiltReal& getCurrentValue() const { return dCurrentValue; }
      BuiltReal& getSCurrentValue() { return dCurrentValue; }
      const BuiltReal& getDiffValue() const { return dDiffValue; }
      Candidate* getSParent() const { return pcInactiveParent; }
      void setParent(Candidate& parent)
         {  AssumeCondition(pcInactiveParent == nullptr) pcInactiveParent = &parent; }

      class Key {
        public:
         typedef Symbol TypeOfKey;
         typedef const Symbol& KeyType;
         typedef const Symbol& ControlKeyType;
         static const Symbol& key(const Candidate& source) { return *source.psSymbol; }
         static ComparisonResult compare(KeyType fstKey, KeyType sndKey)
            {  return fstKey.compare(sndKey); }
      };
      friend class Key;
   };

  private:
   typedef COL::TCopyCollection<COL::SortedArray<Candidate, typename Candidate::Key> > Candidates;
   Candidates sacCandidates;

  public:
   CandidatesForImprovement() {}

   void addCandidate(const Symbol& symbol, const BuiltReal& currentValue, const BuiltReal& diffValue)
      {  sacCandidates.insertNewAtEnd(new Candidate(symbol, currentValue, diffValue)); }
   bool hasActiveCandidates() const
      {  return !sacCandidates.foreachDo([](const Candidate& candidate)
               {  return !candidate.isActive(); });
      }
   bool isEmpty() const { return sacCandidates.isEmpty(); }
   Candidates& candidates() { return sacCandidates; }
   const Candidates& candidates() const { return sacCandidates; }

   class Cursor : public Candidates::Cursor {
     public:
      Cursor(const CandidatesForImprovement& candidates) : Candidates::Cursor(candidates.sacCandidates) {}
   };
   friend class Cursor;
};

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::verifyAllPositiveEquations(
         const Vertex& vertex, const thisType* rootConstraint, const thisType* currentConstraint) const {
   bool result = true;
   while (result && rootConstraint && rootConstraint != currentConstraint) {
      BuiltReal equationResult;
      result = isPositiveEquation(rootConstraint->eEquation, vertex,
            !rootConstraint->fNegative, equationResult);
      rootConstraint = rootConstraint->getParent().key();
   }
   return result;
}

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::improveOwnResult(
      const Equation& equation, const Vertex& vertex, bool isPositiveDirection,
      const BuiltReal& equationResult, CandidatesForImprovement& candidatesForImprovement) const {
   // If the solver operations were based on the backward transfer functions
   // instead of the forward inverse one, this method would have been unuseful.
   auto& minParams = TypeBaseFloatAffine::minParams();
   auto& maxParams = TypeBaseFloatAffine::maxParams();
   typename CandidatesForImprovement::Cursor candidatesCursor(candidatesForImprovement);
   while (candidatesCursor.setToNext()) {
      typename CandidatesForImprovement::Candidate& candidate = candidatesCursor.elementSAt();
      if (!candidate.isActive())
         continue;

      typename Equation::Cursor cursor(equation);
      while (cursor.setToNext() && cursor.elementAt() < candidate.getSymbol());
      if (cursor.isValid() && cursor.elementAt() != candidate.getSymbol())
         continue;

      const BuiltReal& coefficientValue = ((typename Equation::Coefficient&)
            cursor.globalElementAt()).getValue();
      if ((candidate.getDiffValue().isPositive() == coefficientValue.isPositive()) == isPositiveDirection)
         continue;

      AssumeCondition(equationResult.isZero()
            || isPositiveDirection ? equationResult.isPositive() : equationResult.isNegative())
      BuiltReal expectedDiff(candidate.getDiffValue());
      {  auto& params = (expectedDiff.isPositive() == coefficientValue.isPositive()) ? maxParams : minParams;
         expectedDiff.multAssign(coefficientValue, params);
         params.clear();
      }
      expectedDiff.opposite();
      if (isPositiveDirection ? expectedDiff <= equationResult : expectedDiff >= equationResult)
         continue;

      {  auto& params = isPositiveDirection ? minParams : maxParams;
         expectedDiff.minusAssign(equationResult, params);
         params.clear();
      };
      expectedDiff.opposite();
      candidate.setInactive();

      typename Vertex::Cursor vertexCursor(vertex);
      ValueForSymbol* vertexValue = vertexCursor.setToFirst() ? &vertexCursor.elementSAt() : nullptr;
      for (bool doesContinue = cursor.setToFirst(); doesContinue; doesContinue = cursor.setToNext()) {
         const Symbol& symbol = cursor.elementAt();
         if (symbol == candidate.getSymbol())
            continue;
         typename CandidatesForImprovement::Cursor locateCursor(candidatesForImprovement);
         auto locate = candidatesForImprovement.candidates().locateKey(symbol, locateCursor);
         if (locate) // active or inactive
            continue;

         AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
         const BuiltReal& coeffValue = ((typename Equation::Coefficient&)
               cursor.globalElementSAt()).getSValue();

         while (vertexValue && vertexValue->getSymbol() < symbol) 
            vertexValue = vertexCursor.setToNext() ? &vertexCursor.elementSAt() : nullptr;
         AssumeCondition(vertexValue && vertexValue->getSymbol() == symbol)

         BuiltReal diffValue(expectedDiff);
         {  auto& params = (diffValue.isPositive() == coeffValue.isPositive()) ? maxParams : minParams;
            diffValue.divAssign(coeffValue, params);
            params.clear();
         };
         BuiltReal newValue = vertexValue->getSymbolValue();
         newValue.plusAssign(diffValue, diffValue.isPositive() ? maxParams : minParams);
         (diffValue.isPositive() ? maxParams : minParams).clear();
         if (newValue > BuiltReal(1U) || newValue < BuiltReal(1U).opposite())
            continue;

         auto* newCandidate = new typename CandidatesForImprovement::Candidate(symbol,
               vertexValue->getSymbolValue(), diffValue);
         candidatesForImprovement.candidates().add(newCandidate,
               locate.queryInsertionParameters().setFreeOnError(), &locateCursor);
         newCandidate->setParent(candidate);
      };
   };
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::improveAllPositiveEquations(
      Vertex& vertex, CandidatesForImprovement& candidatesForImprovement, const thisType* rootConstraint,
      const thisType* currentConstraint) const {
   bool result = true;
   while (!result && rootConstraint && rootConstraint != currentConstraint) {
      const Equation& equation = rootConstraint->eEquation;
      bool isPositiveDirection = !rootConstraint->fNegative;
      BuiltReal equationResult;
      isPositiveEquation(equation, vertex, isPositiveDirection, equationResult);
      improveOwnResult(equation, vertex, isPositiveDirection, equationResult, candidatesForImprovement);
      result = candidatesForImprovement.hasActiveCandidates();
      rootConstraint = ((const PNT::TMngPointer<thisType>&) rootConstraint->getParent()).key();
   }
   return result;
}

DefineEquationTemplateHeader(URealBitsNumber)
bool
DefineConstraint DefineEquationTemplateParameters(URealBitsNumber)::improveResult(
      const Equation& equation, Vertex& vertex, bool isPositiveDirection, BuiltReal& equationResult,
      const thisType* rootConstraint, const thisType* currentConstraint) const {
   // If the solver operations were based on the backward transfer functions
   // instead of the forward inverse one, this method would have been unuseful.
   CandidatesForImprovement candidatesForImprovement;
   // if any element of candidatesForImprovement is a candidate to solve the problem
   typename Vertex::Cursor vertexCursor(vertex);
   ValueForSymbol* vertexValue = vertexCursor.setToFirst() ? &vertexCursor.elementSAt() : nullptr;
   typename Equation::Cursor cursor(equation);
   auto& nearestParams = TypeBaseFloatAffine::nearestParams();
   while (cursor.setToNext()) {
      AssumeCondition(dynamic_cast<const typename Equation::Coefficient*>(&cursor.globalElementAt()))
      BuiltReal& coefficientValue = ((typename Equation::Coefficient&)
            cursor.globalElementSAt()).getSValue();
      const Symbol& symbol = cursor.elementAt();
      while (vertexValue && vertexValue->getSymbol() < symbol) 
         vertexValue = vertexCursor.setToNext() ? &vertexCursor.elementSAt() : nullptr;
      AssumeCondition(vertexValue && vertexValue->getSymbol() == symbol)
      BuiltReal expectedDiff(equationResult);
      expectedDiff.multAssign(4U, nearestParams);
      nearestParams.clear();
      expectedDiff.divAssign(coefficientValue, nearestParams);
      nearestParams.clear();
      if (expectedDiff.isInfty() || expectedDiff > BuiltReal(1U)
            || expectedDiff < BuiltReal(1U).opposite()) {
         vertexValue = vertexCursor.setToNext() ? &vertexCursor.elementSAt() : nullptr;
         continue;
      };
         
      BuiltReal newValue(vertexValue->getSymbolValue());
      if ((expectedDiff.isPositive() == coefficientValue.isPositive()) == isPositiveDirection)
         newValue.plusAssign(expectedDiff, nearestParams);
      else
         newValue.minusAssign(expectedDiff, nearestParams);
      nearestParams.clear();
      if (newValue > BuiltReal(1U) || newValue < BuiltReal(1U).opposite()) {
         vertexValue = vertexCursor.setToNext() ? &vertexCursor.elementSAt() : nullptr;
         continue;
      };
      if ((vertexValue->isPositive() == coefficientValue.isPositive()) == isPositiveDirection) {
         newValue.swap(coefficientValue);
         if (!isPositiveEquation(equation, vertex, isPositiveDirection, equationResult)
               || !verifyAllPositiveEquations(vertex, rootConstraint, currentConstraint))
            newValue.swap(coefficientValue);
         else
            return true;
      }
      else
         candidatesForImprovement.addCandidate(symbol, vertexValue->getSymbolValue(), expectedDiff);
      vertexValue = vertexCursor.setToNext() ? &vertexCursor.elementSAt() : nullptr;
   };
   if (candidatesForImprovement.isEmpty())
      return false;
   if (improveAllPositiveEquations(vertex, candidatesForImprovement, rootConstraint,
         currentConstraint)) {
      typename CandidatesForImprovement::Cursor cursor(candidatesForImprovement);
      while (cursor.setToNext()) {
         if (cursor.elementAt().isActive()) {
            auto* candidate = &cursor.elementSAt();
            do {
               vertex.locateKey(candidate->getSymbol(), vertexCursor, COL::VirtualCollection::RPExact);
               AssumeCondition(vertexCursor.elementAt().getSymbolValue() == candidate->getCurrentValue())
               candidate->getSCurrentValue().plusAssign(candidate->getDiffValue(), nearestParams);
               vertexCursor.elementSAt().symbolValue().swap(candidate->getSCurrentValue());
               nearestParams.clear();
            } while ((candidate = candidate->getSParent()) != nullptr);

            if (!isPositiveEquation(equation, vertex, isPositiveDirection, equationResult)
                  || !verifyAllPositiveEquations(vertex, rootConstraint, currentConstraint))
               vertexCursor.elementSAt().symbolValue().swap(cursor.elementSAt().getSCurrentValue());
            else
               return true;
         };
      };
   }
   return false;
}

/*
DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraintsSet DefineEquationTemplateParameters(URealBitsNumber)::mergeWith(
      const thisType& source) {
   int length = 0, sourceLength = 0;
   Constraint::Pointer cursor = mpLast;
   while (cursor.isValid()) {
      ++length;
      cursor = cursor->getParent();
   };
   Constraint::Pointer sourceCursor = source.mpLast;
   while (sourceCursor.isValid()) {
      ++sourceLength;
      sourceCursor = sourceCursor->getParent();
   };
   cursor = mpLast;
   sourceCursor = source.mpLast;
   while (length > sourceLength) {
      cursor = cursor->getParent();
      --length;
   };
   while (sourceLength > length) {
      sourceCursor = sourceCursor->getParent();
      --sourceLength;
   };
   while (length > 0 && cursor.key() != sourceCursor.key()) {
      cursor = cursor->getParent();
      --length;
      sourceCursor = sourceCursor->getParent();
   }
   AssumeCondition(cursor.key() == sourceCursor.key())
   while (mpLast.key() != cursor.key()) {
      Constraint::Pointer cursor = mpLast->getParent();
      mpLast.release();
      mpLast = cursor;
   };
}
*/

DefineEquationTemplateHeader(URealBitsNumber)
void
DefineConstraintsSet DefineEquationTemplateParameters(URealBitsNumber)::retrieveBound(
      const Equation& equation, BuiltReal& min, BuiltReal& max) const {
   equation.retrieveBound(min, max, false /* hasExternalCoefficient */);
   if (mpLast.isValid()) {
      typename Constraint::Solver maxSolver(equation, true /* isPositive */);
      typename Constraint::Vertex minVertex(mpLast->getAdmissibleVertex(), typename Constraint::Vertex::SolverInit());
      minVertex.addSymbolsFrom(equation);
      typename Constraint::Vertex maxVertex(minVertex, typename Constraint::Vertex::SolverInit());
      {  auto parent = (const PNT::TMngPointer<Constraint>&) mpLast;
         do {
            maxSolver.addBase(*parent);
            maxVertex.setConstraintResult(maxSolver
                  .queryVertexResult(parent->eEquation, maxVertex, false /* fNegative */));
            minVertex.setConstraintResult(maxSolver
                  .queryVertexResult(parent->eEquation, minVertex, true /* fNegative */));
            parent = (const PNT::TMngPointer<Constraint>&) parent->mpParent;
         } while (parent.isValid());
      };
      typename Constraint::Solver minSolver(maxSolver);
      minSolver.changeObjectiveSign();

      BuiltReal newMin = minSolver.getResultFor(minVertex);
      BuiltReal oldMin;
      int degeneratedIndex = -1;
      do {
         oldMin = newMin;
         typename Constraint::Vertex::Cursor vertexCursor(minVertex);
         typename Constraint::Solver::Cursor cursor(minSolver);
         bool hasCompleteCycle = true;
         while (cursor.setToNext()) {
            const typename Constraint::Solver::BaseTerm& term = cursor.elementAt();
            const Symbol& symbol = term.getSymbol();
            while (vertexCursor.setToNext()) { // synchronization
               if (&vertexCursor.elementAt().getSymbol() == &symbol)
                  break;
            };
            const BuiltReal& currentCoefficient = term.getCoefficient();
            if (!currentCoefficient.isZero()
                  && currentCoefficient.isNegative() == vertexCursor.elementAt().isNegative()) {
               BuiltReal initialVertexSymbol(vertexCursor.elementAt().getSymbolValue()),
                         vertexDiffSymbol(+1U);
               typename BuiltReal::ReadParameters& minParams
                     = currentCoefficient.isPositive() ? TypeBaseFloatAffine::minParams()
                        : TypeBaseFloatAffine::maxParams();
               typename BuiltReal::ReadParameters& maxParams
                     = currentCoefficient.isPositive() ? TypeBaseFloatAffine::maxParams()
                        : TypeBaseFloatAffine::minParams();
               if (currentCoefficient.isNegative()) { // isPositive() ?
                  initialVertexSymbol.opposite();
                  vertexDiffSymbol.opposite();
               };
               vertexDiffSymbol.minusAssign(initialVertexSymbol, maxParams);
               maxParams.clear();
               int foundPivot = -1;
               if (minSolver.isAdmissibleDirection(symbol,
                     currentCoefficient.isNegative(),
                     vertexCursor.elementAt().getSymbolValue(), minVertex, vertexDiffSymbol,
                     foundPivot, degeneratedIndex, false /* isInitialOut */)) {
                  BuiltReal& symbolValue = vertexCursor.elementSAt().symbolValue();
                  symbolValue.plusAssign(vertexDiffSymbol, minParams);
                  minParams.clear();
                  bool doesDecreaseEntering = vertexDiffSymbol.isNegative();
                  BuiltReal temp(1U);
                  if (currentCoefficient.isPositive())
                     temp.opposite();
                  if (currentCoefficient.isPositive() ? symbolValue < temp : symbolValue > temp) {
                     symbolValue = temp;
                     temp.minusAssign(symbolValue, minParams);
                     minParams.clear();
                     vertexDiffSymbol.plusAssign(temp, maxParams);
                     maxParams.clear();
                  };
                  minSolver.updateConstraintResult(minVertex, symbol, vertexDiffSymbol);
                  vertexDiffSymbol.multAssign(currentCoefficient, minParams);
                  minParams.clear();
                  AssumeCondition(vertexDiffSymbol.isPositive() && !vertexDiffSymbol.isZero())
                  newMin.minusAssign(vertexDiffSymbol, minParams);
                  minParams.clear();
                  if (degeneratedIndex >= 0 && !vertexDiffSymbol.isZero())
                     degeneratedIndex = -1;
                  if (foundPivot >= 0) {
                     minSolver.performPivot(cursor, foundPivot, minVertex, doesDecreaseEntering, true /* isNegativeObjective */);
                     if (degeneratedIndex >= 0)
                        degeneratedIndex = foundPivot;
                  };
                  hasCompleteCycle = false;
                  break;
               }
            }
         };
         if (!cursor.isValid()) {
            if (!hasCompleteCycle) {
               hasCompleteCycle = true;
               continue;
            }
            else { // try degenerated cases
               if (degeneratedIndex < 0 && minSolver.countBases() > 0)
                  degeneratedIndex = minSolver.countBases()-1;
               else
                  break;
            };
         };
      } while (newMin < oldMin);
      newMin.opposite();
      if (newMin > min)
         min = newMin;

      BuiltReal newMax = maxSolver.getResultFor(maxVertex);
      BuiltReal oldMax;
      degeneratedIndex = -1;
      do {
         oldMax = newMax;
         typename Constraint::Vertex::Cursor vertexCursor(maxVertex);
         typename Constraint::Solver::Cursor cursor(maxSolver);
         bool hasCompleteCycle = true;
         while (cursor.setToNext()) {
            const typename Constraint::Solver::BaseTerm& term = cursor.elementAt();
            const Symbol& symbol = term.getSymbol();
            while (vertexCursor.setToNext()) {
               if (&vertexCursor.elementAt().getSymbol() == &symbol)
                  break;
            };
            const BuiltReal& currentCoefficient = term.getCoefficient();
            if (!currentCoefficient.isZero()
                  && currentCoefficient.isPositive() == vertexCursor.elementAt().isNegative()) {
               BuiltReal initialVertexSymbol(vertexCursor.elementAt().getSymbolValue()),
                         vertexDiffSymbol(+1U);
               typename BuiltReal::ReadParameters& minParams = currentCoefficient.isPositive()
                     ? TypeBaseFloatAffine::minParams() : TypeBaseFloatAffine::maxParams();
               typename BuiltReal::ReadParameters& maxParams = currentCoefficient.isPositive()
                     ? TypeBaseFloatAffine::maxParams() : TypeBaseFloatAffine::minParams();
               if (currentCoefficient.isNegative()) { // == fNegative ?
                  initialVertexSymbol.opposite();
                  vertexDiffSymbol.opposite();
               };
               vertexDiffSymbol.minusAssign(initialVertexSymbol, minParams);
               minParams.clear();
               int foundPivot = -1;
               if (maxSolver.isAdmissibleDirection(symbol,
                     currentCoefficient.isPositive(),
                     vertexCursor.elementAt().getSymbolValue(), maxVertex, vertexDiffSymbol,
                     foundPivot, degeneratedIndex, false /* isInitialOut */)) {
                  BuiltReal& symbolValue = vertexCursor.elementSAt().symbolValue();
                  symbolValue.plusAssign(vertexDiffSymbol, maxParams);
                  maxParams.clear();
                  bool doesDecreaseEntering = vertexDiffSymbol.isNegative();
                  BuiltReal temp(1U);
                  if (currentCoefficient.isNegative())
                     temp.opposite();
                  if (currentCoefficient.isNegative() ? symbolValue < temp : symbolValue > temp) {
                     symbolValue = temp;
                     temp.minusAssign(symbolValue, maxParams);
                     maxParams.clear();
                     vertexDiffSymbol.plusAssign(temp, minParams);
                     minParams.clear();
                  };
                  maxSolver.updateConstraintResult(maxVertex, symbol, vertexDiffSymbol);
                  vertexDiffSymbol.multAssign(currentCoefficient, maxParams);
                  maxParams.clear();
                  AssumeCondition(vertexDiffSymbol.isPositive() && !vertexDiffSymbol.isZero())
                  newMax.minusAssign(vertexDiffSymbol, maxParams);
                  maxParams.clear();
                  if (degeneratedIndex >= 0 && !vertexDiffSymbol.isZero())
                     degeneratedIndex = -1;
                  if (foundPivot >= 0) {
                     maxSolver.performPivot(cursor, foundPivot, maxVertex, doesDecreaseEntering, false /* isNegativeObjective */);
                     if (degeneratedIndex >= 0)
                        degeneratedIndex = foundPivot;
                  };
                  hasCompleteCycle = false;
                  break;
               }
            }
         };
         if (!cursor.isValid()) {
            if (!hasCompleteCycle) {
               hasCompleteCycle = true;
               continue;
            }
            else {
               if (degeneratedIndex < 0 && maxSolver.countBases() > 0)
                  degeneratedIndex = maxSolver.countBases()-1;
               else
                  break;
            };
         };
      } while (newMax < oldMax);
      if (newMax < max)
         max = newMax;
   }
}

} // end of namespace DAffine

#undef DefineEquationTemplateHeader
#undef DefineEquationTemplateParameters
#undef DefineEquationServices
#undef DefineEquation
#undef DefineSingleTemplateParameters
#undef DefineSizeofBaseTypeInBits
#undef DefineDefinedSymbol
#undef DefineConstraint
#undef DefineConstraintsSet
#undef DefineBuiltReal

